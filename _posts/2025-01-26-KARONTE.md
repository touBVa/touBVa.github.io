---
layout: post
title: 'KARONTE: Detecting Insecure Multi-binary Interactions in Embedded Firmware ì½ê¸°'
summary: ë…¼ë¬¸ ê³µë¶€ ì¢€ í–ˆìˆ˜ë‹¤
author: TouBVa
date: '2025-01-26 13:00:00 +09'
category: ['fuzzing','paper_study']
thumbnail: /assets/img/posts/2025-01-26-KARONTE/image.png
keywords: fuzzing
usemathjax: true
permalink: /blog/fuzzing/2025-01-26-KARONTE
---

* TOC
{:toc}

<br>

# 0. ì£¼ì•ˆì 

ë…¼ë¬¸ì˜ ìš”ì§€ â†’ 1) ì–´ë–¤ ìƒˆë¡œìš´ ê¸°ìˆ ì„ ë„ì…í•´ 2) ì´ë§Œí¼ì˜ í–¥ìƒëœ ê²°ê³¼ë¥¼ ëƒˆë‹¤

- ì¦‰, ë…¼ë¬¸ì˜ í•µì‹¬ì€ â†’ â€˜í–¥ìƒëœ ê²°ê³¼â€™ë¥¼ ë‚¼ ìˆ˜ ìˆì—ˆë˜ ì›ì¸ì´ â€˜ì–´ë–¤ ê¸°ìˆ â€™ ì¸ê°€
- ì¶”ê°€ë¡œ, â€˜ì´ë§Œí¼ í–¥ìƒëìŒâ€™ì˜ ê·¼ê±°ëŠ” ë¬´ì—‡ì¸ê°€

ì´ë²ˆ ë…¼ë¬¸ ê³¼ì œì˜ ì˜ë„ëŠ” ì—°êµ¬ì‹¤ì´ ê¸°ë°˜í•˜ê³  ìˆëŠ” ì—°êµ¬ ë¶„ì•¼ê°€ ë¬´ì—‡ì¸ì§€ ì´í•´í•˜ëŠ” ê²ƒì´ë¼ê³  ìƒê°

ë”°ë¼ì„œ â€˜ê¸°ìˆ â€™ì— ì£¼ì•ˆì ì„ ë‘ê³  ë…¼ë¬¸ ë¦¬ë”© ì§„í–‰


<div class="notice--primary">

<p><strong>ğŸ’¡ë…¼ë¬¸ì—ì„œ ë‚´ê°€ ì–»ì–´ì•¼ í•  ê²ƒì€? </strong></p>
<p>â†’ í–¥ìƒëœ ê²°ê³¼ì˜ ê¸°ë°˜ì´ ë˜ì—ˆë˜ ê¸°ìˆ ì  ë°œì „ì€ ë¬´ì—‡ì¸ê°€?</p>
<ul>
    <li>multiple binaries analysis + inter-binary data flow analysis</li>
</ul>
<p>â†’ ê·¸ê²ƒì€ ì–´ë–¤ ì•„ì´ë””ì–´ì— ê¸°ë°˜í•˜ì˜€ëŠ”ê°€?</p>
<ul>
    <li>
        Modeling &amp;Tracking <strong>multi-binary interactions</strong>
    </li>
    <li>
        <strong>IPC paradigm used in one firmware is likely to be finite(concept)</strong>
        <ul>
            <li>
                <strong>í•œ ë°”ì´ë„ˆë¦¬ì˜ data I/O íŒŒì•…(mid-implementation)</strong>
                â†’ inter-binary data flow recovery
            </li>
        </ul>
    </li>
    <li>
        by leveraging <strong>CPF(Communication Paradigm Finder) modules(Implementation)</strong>
    </li>
</ul>

</div>

<br>

**ì‹œí–‰ì°©ì˜¤**

- Appendixê°€ ê¸°ìˆ set ì„¤ëª…ê³¼ ë§¤ìš° ë°€ì ‘í•´ ë³´ì—¬, ì›í™œí•œ ì´í•´ë¥¼ ìœ„í•´ Approach Overviewë¥¼ ì½ê³  ë°”ë¡œ Appendixë¥¼ ì½ì—ˆìŒ.
    - ê·¸ëŸ¬ë‚˜ AppendixëŠ” í•µì‹¬ ê¸°ìˆ ì˜ component ë ˆë²¨ ìš”ì†Œì— ê´€í•œ ì„¸ë¶€ ì„¤ëª…ì´ì—ˆìŒ
    - ì¦‰ ë…¼ë¬¸ ë³¸ë¬¸ì„ ë‹¤ ì½ê³  Appendixë¥¼ ì½ëŠ” ê²ƒì´ íš¨ìœ¨ì ì´ì—ˆìŒ


<br>


# 1. Introduction

## 1.1. Abstract

![image.png](/assets/img/posts/2025-01-26-KARONTE/image.png){: width="100%" height="100%"}

- IoT devices - Software on these systems(Firmware)
    - Analysis challenged
        - Hardware-dependent
        - Not-standardized Environment â†’ 1) unique & minimal 2) non-standard configurations
    - Analysis complicated
        - Multiple Binaries
            - Addressing the communication between executables is complicated
- KARONTE
    - Static
    - Modeling & Tracking **multi-binary interactions**
    - Starting from taint information â†’ insecure interactions â†’ vulnerability identification
    - Evaluation
        1. On Tracking&Constraining Multi-binary interactions abilities
        2. On Scaling ability about:
            1. firmwares with various size and complexity 

<br>

# 2. Background

### Emersion of IoT devices

- Vast amount of IoT devices introduced new-coined threats into cybersecurity landscape
- Techniques that are invented, especially in the perspective of unpacking binaries, were insufficient

<br>

### Constraint of traditional analysis techniques

- **Interconnected components**(functionality based on multiple programs execution)
    
    â†” analysis without accounting for the **internal flow of data**
    
    â†’ Ignore **meaningful constraints** arise from inter-binary communication
    
    â†’ Inability to **differentiate sources of input**(attacker-controlled or non-attacker-controlled)
    
    â†’ Limited search performance that leads to uncovering **only superficial bugs**
    

**Hence**,

- Consideration about **multiple binary execution** is necessary
- Analysis on the **data shared** among multiple binary is necessary

<br>

### KARONTE

- Static
- Track data flow
- Intuition:
    1. **IPC paradigm used in one firmware is likely to be finite**
    2. Derive commonalities in the paradigm set
    3. Use the commonalities to detect input locations & inter-component interactions
    4. Use the verified interactions to track inter-component data flow
    5. Perform cross-binary taint analysis
    6. Detect insecure uses(potential vulnerabilities)

<br>    

# 3. Approach Overview

ì—¬ê¸° ì„¤ëª…ëœ í•­ëª© ì •ë¦¬í•˜ê³  Appendixì— ë‚˜ì˜¨ ê±°ë‘ ë§¤í•‘í•´ì„œ ì •ë¦¬í•˜ì

<br>

## 3.1. Firmware Pre-processing

- unpack firmware sample using â€˜binwalkâ€™

<br>

## 3.2. Border Binaries Discovery

- â€˜Border Binaryâ€™: Binaries that export the device functionality to the outside world
    - Represents the point where accepts user requests & references user-controlled data

<br>

## 3.3. Binary Dependency Graph(BDG) Recovery

- â€˜BDGâ€™
    - Directed graph
    - Models communication among border binaries by leveraging **CPF(Communication Paradigm Finder) modules**

<br>

## 3.4. Multi-binary Data-flow Analysis

- By using â€˜static taint engineâ€™, the KARONTE:
    - Tracks data propagation
    - Collects data constraints
- Simulate data propagation applying features gathered
    - from the target binary b to other binaries that have inbound edges from b

<br>

## 3.5. Insecure Interactions Detection

- Identifying security issues

<br>

# 4. Border Binaries Discovery

<br>

# 5. Binary Dependency Graph(ì‚¬ì‹¤ìƒ CPFê°€ í•µì‹¬)

<br>

## 5.1. Purpose and Overview

- BDG: detects data dependencies & model data propagation (setter binary â†’ getter binary)
- Challenges:
    - Inter-binary data propagation:
        - control flow information is useless because:
            - processes do NOT normally access other processesâ€™ memory regions.
- Solution:
    1. Model IPC paradigms by using CPFes(Communication Paradigm Finders)
    2. Use modeled paradigms to build a graph == BDG(Binary Dependency Graph)

<br>

## 5.2. Communication Paradigm Finders

### Objective

- Detect & Describe specific IPC paradigm which binary uses to share data
- 1)  explore binary & program path â†’ 2) Does the path contains the necessary code to share data through the communication paradigm? â†’ 3) If so, conduct deeper analysis using techniques below â†’ 4) create edges of BDG utilizing features distinguished
    1. Data Key Recovery
    2. Flow Direction Determination
    3. Binary Set Magnification

<br>

### Key Functionalities

1. **Data Key Recovery**
    1. referenced by the binary for IPCs
    2. fundamental & essential â†’ THE MOST IMPORTANT TECHNIQUE
2. Flow Direction Determination(scope: one binary)
    1. Role of each program points: â€˜Setterâ€™ & â€˜Getterâ€™
    2. program points: access the data keys
3. Binary Set Magnification(scope: whole firmware)
    1. if any â€˜binariesâ€™ refer to the data keys â†’ scheduled for further analysis

<br>

### Implementation

- â€˜Semantic CPFâ€™: OS-Independent
    - Intuition: â€˜Data Keysâ€™ *IPC must rely on them *Often hard-coded in binaries
- KARONTE uses:
    - Environment CPFes
    - File CPFes
    - Socket CPFes
    - Semantic CPFes

<br>

## 5.3. Building the BDG

(ì‹œê°„ì´ ë¶€ì¡±í•œ ê´€ê³„ë¡œ ìš°ì„ ìˆœìœ„ í•˜ê°•)

<br>

# 6. Static Taint Analysis

The operation of the underlying taint engine

<br>

# **7. Multi-Binary Data-Flow Analysis**

How KARONTE combines the taint engine with the BDG to do detection

BDG

BFG

<br>

## 7.1. Key Insight & Concepts

- Paths with fewer constraints on user data dd are more likely to expose vulnerabilities.
- BFG: Extended version of the BDG in the direction of â€˜least strict set of constraint applied to the data shared among multiple binariesâ€™

<br>

### 7.2. BFG Building

1. Initialization
2. Constraint Propagation

<br>

# 8. Insecure Interations Detection

Detection Target:

1. Memory-Corruption bugs
2. DoS vulnerabilities

<br>

# 9. Discussion

<br>

# 10. Evaluation

<br>

# 12. Conclusion

KARONTE: Detect insecure interactions among components of embedded firmware

+) Emphasizing the effectiveness of KARONTE

â†’ ì–´ë–»ê²Œ insecure interactionsë¥¼ ì•Œì•„ëƒˆëŠ”ì§€ì— ê´€í•´ ì„¤ëª…í•  ìˆ˜ ìˆëŠ” ê²Œ ì¤‘ìš”í•œ ë“¯í•´, Evaluation íŒŒíŠ¸ëŠ” ë‚˜ì¤‘ì— ì½ì–´ë³´ëŠ” ê²ƒìœ¼ë¡œ í•¨


<br>

---

<br>

# Appendix

> Backgroundë¥¼ ì½ìœ¼ë©´ì„œ ì´ê±¸ ê°™ì´ ë´ì•¼ í•  ê²ƒ ê°™ìŒ
> 

<br>

### A. Functions Identification

3 types of functions is the goal of distinguishment

<br>

1. **memcmp-like functions**
    
    
    ğŸ‘¥: sementically equvalent to memory comparisons
    {: .notice}
    
    1. **methodology**
        1. If the target function $f$ contains at least one loop, then:
            1. Scan the instructions in the body of the loop in the linear manner and list every program point $p$ which contains memory comparison instructions
            2. Compute a static backward slice $p$ â†’ $f$â€™s entry point
            3. Inspect $f$â€™s args to clarify whether they could affect operands in $p$ and if so, then:
                1. $f$ becomes a candidate of memcmp-like functions
                2. Calculate the size of $f$(based on number of its basic blocks)
                3. Adopt `BootStomp`â€™s threshold to decrease the number of false positives
2. **strlen-like functions**
    
    
    ğŸ‘¥: calculate the length of a buffer
    {: .notice}
    
    1. **methodology**
        1. **similar to memcmp-like function search** implementation + â€˜the existence of **counter**, which increases as the number of loop iteration goesâ€™
3. **memcpy-like functions**
    
    
    ğŸ‘¥: copy the content of a memory location to another
    {: .notice}
    
    1. **methodology**
        1. same with the methodology of `Bootstomp`
4. **function body is not available**
    1. Heuristically match strings on the name of the function
    
    (opinion) It may become an armpit of this system
    
5. **Optimization strategy**
    1. Harness function generation: abstract the functions described above to minimize the resource of repeated execution
        
        â†’ mitigate the â€˜path explosion problemâ€™
        
        â†’ speed up, without losing precision.
        
<br>

### B. Border Binaries Discovery

**Connection mark â†’ Flag**

**Network mark â†’ Counter**

Calculation Hardness: Connection mark >>>>>>>> Network mark

1. Network mark calculation
    1. Retrieve all the **memory comparisons** within a binary == Assume these will **refer to hard-coded network related strings**
    2. The strings mostly referred within **the basic block(the call to the memory comparison, too)**
2. Connenction mark calculation
    1. Forward static taint analysis + Backward static taint analysis
    2. Limitation on the {Number of functions analyzed, Time of symbolic exploration}
    3. For the case of path(source-sink) exploration failed:
        1. any imprecision from a function $f$ analysisâ‡’ analysis for $f$ is incomplete
        2. over 50%(setted threshold) of experiments ends up in incomplete analysis, then:
            1. conservatively set the connection mark.
    4.  Regarding OS dependency: if the OS is unknown, then simply set the connection mark.
3. Utilize the feature â€˜cmpâ€™ when calculating Parsing Score.

### C. Communication Paradigm Finders

<mark> Purpose of CPF: When recovering BDG(Binary Dependency Graph), by leveraging CPF, it becomes able to map inter-binary data flow.</mark>

<br>

| Aspect | Environment CPF | Semantic CPF |
| --- | --- | --- |
| Trigger for Analysis | Calls that set/get environment variables or execute binaries. | Memory operations using hardcoded data keys as indices or references. |
| Primary Detection | Strings representing environment keys or binary names. | Functions setting or getting data based on predefined data keys. |
| Application Context | More suited for analyzing high-level OS interactions. | Ideal for low-level memory and firmware analysis. |

<br>

1. OS-dependent CPF: Environment CPF
    1. Key Idea
        1. Calling to a function setting (or getting) environment variables is almost necessary when sharing data through environment variables before executing another binary.
            1. Binary Execution Block Searching
            2. Path (entry-block) searching to find out program points calling environment variable setting functions
            3. reach-def analysis on path(entry-point)  â†’ arguments values determination
            4. Determined values == â€˜data keysâ€™
            5. + â€˜Binary Set Magnification Functionalityâ€™ â‡’ reach-def analysis â†’ arg strings collection â†’ possible binary names inference
            6. If binary names are unable to resolve â†’ find all the binaries that rely on the data keys previously recovered.
    2. Detection Focus
        1. Program Path
        2. Binary Level Interaction
2. OS-independent CPF: Semantic CPF
    1. Key Idea
        1. IPC often relies on predefined data keys, which is often hardcoded as constants.
    2. Detection Focus
        1. Function-Level Data Flow
        2. Memory Operations


<br>

### D. Binary Dependency Graph Algorithm

<br>

### E. Static Taint Analysis

<br>

### F. Multi-binary Data-flow Analysis

<br>

### G. Vulnerability Example

<br>