<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TouBVa</title>
    <description>Better than you thought, Worse than you expected</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 16 Jul 2022 15:36:20 +0900</pubDate>
    <lastBuildDate>Sat, 16 Jul 2022 15:36:20 +0900</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>

    
      <item>
        <title>System Hackig Step 3-2</title>
        <description>&lt;h1 id=&quot;stage-3-2&quot;&gt;STAGE 3-2&lt;/h1&gt;

&lt;h1 id=&quot;tool-pwntools&quot;&gt;Tool: PwnTools&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬을 이용해 익스플로잇을 수행할 때, 자주 사용하는 함수들이 있음. 예시) 리틀 엔디언 ↔ 빅 엔디언을 수행하는 함수&lt;/li&gt;
  &lt;li&gt;이런 함수들을 미리 구현해 둔 모듈을 만듦 → ‘pwntools’의 탄생&lt;/li&gt;
  &lt;li&gt;익스플로잇 대부분이 pwntools를 이용해 제작되고 공유되므로 반드시 알아 둬야 함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;설치 방법은 생략한다. 인터넷에 검색하면 나오기 때문에…&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;pwntools-api-사용법&quot;&gt;PwnTools API 사용법&lt;/h1&gt;

&lt;p&gt;공식 매뉴얼: &lt;a href=&quot;http://docs.pwntools.com/en/latest/&quot;&gt;여기!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;요즘은 매뉴얼화가 잘 되어 있기 때문에 어떤 모듈을 다운받으면 그 모듈의 매뉴얼부터 얼추 숙지해 두는 걸 추천한다. 보통은 영어로 되어 있으므로 파파고를 쓰거나, 영어 실력을 늘려서 언어 장벽을 낮추는 게 좋다.&lt;/p&gt;

&lt;p&gt;여기에서는 자주 사용되는 몇몇 함수만 간략히 소개한다.&lt;/p&gt;

&lt;h2 id=&quot;1-process--remote&quot;&gt;1. process &amp;amp; remote&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;process&lt;/code&gt; 를 이용해 전달할 수 있는 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote&lt;/code&gt; 를 통해서도 전달 및 실행할 수 있다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes/processes.html&quot;&gt;자세한 설명&lt;/a&gt;]
    &lt;ul&gt;
      &lt;li&gt;로컬 바이너리를 대상으로 익스플로잇을 테스트하고 디버깅할 때 사용한다.&lt;/li&gt;
      &lt;li&gt;새로운 프로세스를 새 스레드에서 실행하면서, 커뮤니케이션이 가능한 튜브로 래핑해 둔다.&lt;/li&gt;
      &lt;li&gt;즉, process 함수가 실행된 원래 함수와는 별개의 스레드에서 원하는 프로세스를 실행하면서 원래 함수에서 전달하려는 인수나 실행된 프로세스의 결과 등을 주고받을 수 있게 해준다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;print(&apos;this is a shellcode&apos;)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;remote [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes/sockets.html?highlight=remote#pwnlib.tubes.remote.remote&quot;&gt;자세한 설명&lt;/a&gt;]
    &lt;ul&gt;
      &lt;li&gt;원격 서버를 대상으로 익스플로잇을 실제로 실행할 때 사용한다.&lt;/li&gt;
      &lt;li&gt;TCP나 UDP 연결을 만들어서 통신하게 해 주고, IPv4와 IPc6를 모두 지원한다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;example.com&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30909&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &apos;example.com&apos;의 30909 포트에서 서비스 중인 프로세스를 대상으로 익스 수행
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;GET /&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r\n\r\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-send&quot;&gt;2. send&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 프로세스에 전송하기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;여러 variation이 있고, 각자 상황에 맞게 사용할 수 있다. [&lt;a href=&quot;http://docs.pwntools.com/en/latest/tubes.html?highlight=send#pwnlib.tubes.tube.tube.send&quot;&gt;자세한 설명&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test에 &apos;A&apos;를 입력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# &apos;A&apos;+&apos;\n&apos;
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test가 &apos;hello&apos;를 출력하면 &apos;A&apos;를 입력. Data로는 무조건 패킹된(스트링) 데이터가 들어가야 한다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendlineafter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;A&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# ./test가 &apos;hello&apos;를 출력하면 &apos;A&apos;+&apos;\n&apos;을 입력
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-recv&quot;&gt;3. recv&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스에서 데이터를 받기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;여러 variation이 있고, 각자 상황에 맞게 사용할 수 있다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pwnlib.tubes.process&lt;/code&gt; 의 하위에 정의된 메소드이다)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv()&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recvn()&lt;/code&gt; 의 차이점을 주의해야 한다!
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recv(m)&lt;/code&gt; : 최대 m 바이트를 받는 것이기 때문에, 그만큼을 받지 못해도 에러를 발생시키지 않는다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recvn(m)&lt;/code&gt; : 정확히 m 바이트의 데이터를 받는 것이기 때문에 조건을 만족시키는 데이터를 받지 못하면 계속해서 기다린다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# p가 출력하는 데이터를 최대 1024 바이트까지 받을 수 있다.
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until &apos;\n&apos; comes in
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# get exactly 5 bytes of data
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvuntil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;hello&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until &apos;hello&apos; comes in
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recvall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# store data printed out from p until p is terminated 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4-packing--unpacking&quot;&gt;4. packing &amp;amp; unpacking&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;원래 기능은 hex ↔ string&lt;/li&gt;
  &lt;li&gt;부가적 기능으로 엔디언을 바꾸는 데 사용한다.&lt;/li&gt;
  &lt;li&gt;패킹(hex → string)을 위한 함수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p32()&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p64()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p32(int, endian=&apos;big/little&apos;)&lt;/code&gt;&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
        
  &lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x41424344&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# p64 사용법은 동일하므로 생략
&lt;/span&gt;        
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: b&apos;DCBA&apos;
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;big&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 파라미터 추가 명시로 엔디언 변경 가능. 결과: b&apos;ABCD&apos;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;언패킹(string → hex)을 위한 함수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u32()&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u64()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;u32((uint32_t*)addr, endian=’big/little’)&lt;/code&gt; , 리턴값은 int 형식.&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
        
  &lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ABCD&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# s64 사용법은 동일하므로 생략
&lt;/span&gt;        
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: 0x44434241
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;big&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 결과: 0x41424344
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5-interactive&quot;&gt;5. interactive&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;셸을 획득했거나, 익스플로잇의 특정 상황에 직접 입력을 주면서 출력을 확인하고 싶을 때 사용하는 함수.
    &lt;ul&gt;
      &lt;li&gt;쌍방 세션을 생성해 준다.&lt;/li&gt;
      &lt;li&gt;실제로 호출하면 터미널이 뜨게 되고, 거기에서 입력 및 출력이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pwnlib.tubes.ssh.ssh.interactive이고, process나 remote를 사용하면서 그 하위 메소드로 이용할 수 있다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interactive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6-elf&quot;&gt;6. ELF&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step3-1/&quot;&gt;앞서 보았듯&lt;/a&gt;, ELF 파일의 헤더에는 각종 정보가 기록되어 있고, 이들은 높은 확률로 익스플로잇에 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;pwntools가 이런 정보들을 쉽게 참조할 수 있도록 보조해 준다.&lt;/li&gt;
  &lt;li&gt;[&lt;a href=&quot;http://docs.pwntools.com/en/latest/elf/elf.html?highlight=ELF&quot;&gt;자세한 메소드와 사용예&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ELF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;./test&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
  &lt;span class=&quot;c1&quot;&gt;# 이하 ELF 메소드에 정의된 하위 메소드들 사용 가능
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7-contextlog&quot;&gt;7. context.log&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;작성한 익스플로잇도 디버깅이 필요한데, 이때 사용하는 로깅 기능&lt;/li&gt;
  &lt;li&gt;로그 레벨은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;context.log_level&lt;/code&gt; 에 특정 값을 할당함으로써 조절 가능하다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imort&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;error&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 에러만 출력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;debug&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 대상 프로세스와 익스플로잇 간에 오가는 모든 데이터를 화면에 출력
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;info&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 비교적 중요한 정보들만 추려서 출력
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;8-contextarch&quot;&gt;8. context.arch&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;architecture의 준말&lt;/li&gt;
  &lt;li&gt;즉, 공격 대상의 아키텍처 정보를 프로그래머가 원하는 대로 지정할 수 있게 함으로써 호환성을 높임&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;amd64&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# x86-64
&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;i386&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;arm&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;9-shellcraft&quot;&gt;9. shellcraft&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;셸코드를 작성해 익스플로잇을 수행하는 과정에서 상황에 따라 여러 제약 조건이 존재할 수 있다. 따라서, 이를 맞추기 위해 직접 셸코드를 작성해야 할 때가 있다.&lt;/li&gt;
  &lt;li&gt;pwntools에는 자주 사용되는 셸코드들이 저장되어 있어서 별다른 제약 조건이 없다면 꺼내 쓰면 된다.&lt;/li&gt;
  &lt;li&gt;amd64(x86-64) 타겟으로 생성할 수 있는 셸코드 목록: &lt;a href=&quot;https://docs.pwntools.com/en/stable/shellcraft/amd64.html&quot;&gt;여기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwm&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;amd64&apos;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 아키텍처 지정을 하지 않으면 이후 shellcraft.amd64.{} 식으로 명시해 줘야 한다.
&lt;/span&gt;    
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;10-asm&quot;&gt;10. asm&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pwntools에서 제공하는 어셈블 기능&lt;/li&gt;
  &lt;li&gt;기계어로 어셈블하는 것이므로, 대상 아키텍처가 중요하다. 따라서, 아키텍처를 꼭 지정해 주고 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용예:&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pwn&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&apos;amd64&apos;&lt;/span&gt;
    
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcraft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 셸을 실행하는 셸 코드를 기계어로 어셈블
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;결과:&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;pwntools-실습&quot;&gt;pwntools 실습&lt;/h1&gt;

&lt;p&gt;아래의 코드에서 get_shell() 함수를 실행시키는 것이 목적이다. (시스템 해킹의 목적은 셸을 딴 후 루트 권한을 탈취하는 것이기 때문이다)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%201.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 이전에 배웠던 내용을 다시 돌아볼 필요가 있다.&lt;/p&gt;

&lt;p&gt;어떤 함수의 스택 프레임이 생성될 때 직전까지 rip가 위치해 있던 함수의 스택 프레임과의 관계는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 리눅스의 프로세스에게 할당되는 메모리 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 배운 내용을 기반으로 하여 주어진 문제를 어떻게 해결할지 계획을 세워 보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;단계&lt;/strong&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;get_shell 함수의 시작 주소를 알아낸다.&lt;/li&gt;
    &lt;li&gt;유저가 익스플로잇을 수행할 수 있는 부분을 좁힌다.
      &lt;ol&gt;
        &lt;li&gt;“Input: “이 출력됐을 때 값을 입력하는 부분이 유일하게 유저가 프로세스와 소통할 수 있는 부분이다.&lt;/li&gt;
        &lt;li&gt;따라서 유저 입력값을 받을 때 malicious 한 입력값을 넣어야 한다.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;현재 코드에서는 유저 입력값을 어디에 넣는지 확인한다.
      &lt;ol&gt;
        &lt;li&gt;buf[0x28]에 넣는 것으로 설정되어 있고, 입력값이 범위를 넘어가는 것을 차단하지 않는다.&lt;/li&gt;
        &lt;li&gt;따라서 BOF(Buffer OverFlow) 공격을 수행하는 것으로 결정한다.&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;유저가 입력값을 입력할 때 스택의 구조를 알아내어 현재 스택 프레임이 종료된 후 실행될 인스트럭션의 주소를 오염시킨다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;각 페이즈의 목적을 차근차근 달성해 보자.&lt;/p&gt;

&lt;h3 id=&quot;get_shell-함수의-시작-주소-알아내기&quot;&gt;get_shell() 함수의 시작 주소 알아내기&lt;/h3&gt;

&lt;p&gt;특정 프로그램을 구성하는 함수들은 프로세스가 메모리에 올라갈 때 한꺼번에 코드 세그먼트에 로딩된다. c 언어의 경우 위에서부터 아래로 컴파일되기 때문에, 함수가 코드 세그먼트에 로딩되는 순서는 코드가 쓰인 순서와 일치하게 된다. 즉, get_shell() 함수 다음에 main() 함수가 코드 세그먼트에 로딩된다.&lt;/p&gt;

&lt;p&gt;이제 gdb를 이용해 get_shell() 함수의 위치를 알아내 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;딱히 난독화하지 않았기 때문에 심볼이 그대로 살아 있다. 브레이크 포인트를 get_shell에 걺으로써 get_shell의 주소를 알아낼 수 있었다.&lt;/p&gt;

&lt;p&gt;추가적으로, main() 함수의 주소는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%205.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;코드상에서 get_shell보다 아래에 main이 쓰여 있었기 때문에 메모리의 코드 영역에도 main이 get_shell보다 뒤에 로딩된 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;유저-입력값을-받을-당시-스택의-구조-확인하기&quot;&gt;유저 입력값을 받을 당시 스택의 구조 확인하기&lt;/h3&gt;

&lt;p&gt;위에서 짚어본 것처럼, 새롭게 콜된 함수의 스택 프레임과 이전 함수의 스택 프레임 간의 관계는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%202.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스택에는 로컬 변수가 저장되기 때문에 우리가 BOF의 매개로 사용하는 buf[0x28] 변수 또한 스택에 있을 것을 예상하고 있다. 또한 변수는 선언된 순서대로 스택에 들어가므로 buf 변수는 main 함수의 rbp에 위치해 있을  것이다. 따라서 우리가 익스플로잇할 당시의 스택의 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp-0x1]~[rbp-0x28]&lt;/strong&gt;: buf[0x28]&lt;/p&gt;

&lt;p&gt;================main() 스택 프레임 끝====================&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x7]~[rbp]&lt;/strong&gt;: start_main()의 rbp 주소(0x0000000000000000)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x0e]~[rbp+0x07]&lt;/strong&gt;: main()이 끝난 후 이어서 실행될 인스트럭션 주소&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;과연 추측이 맞는지 gdb를 붙여서 확인해 보자.&lt;/p&gt;

&lt;h3 id=&quot;실제-스택의-구조를-디버거로-확인하기&quot;&gt;실제 스택의 구조를 디버거로 확인하기&lt;/h3&gt;

&lt;p&gt;주어진 함수를 gcc로 컴파일할 때 스택 카나리를 끄고(-fno-stack-protector) PIE를 끔으로써 ASLR도 적용되지 않도록(-no-pie) 해두었기 때문에 아마 스택의 구조는 비교적 간단할 것이다. 목표 프로세스인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rao&lt;/code&gt; 에 gdb를 붙여서 사용자 입력값을 받고 저장하는 시점의 스택의 구조를 해당 시점에서의 rbp까지 포함되도록 확인해 보았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/syshack3-2/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흰색으로 하이라이트한 부분, 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf80&lt;/code&gt; 이 rbp이며, 스택의 구조 자체는 예상했던 바와 일치함을 확인할 수 있었다. 그러나, 딱 한 가지 다른 부분이 있었다.&lt;/p&gt;

&lt;p&gt;buf[0x28] 변수는 애초에 0x28 byte 만큼의 크기를 가지기 때문에 예상대로라면 buf[0x28]이 차지하는 주소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf7e&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf58&lt;/code&gt; 이었어야 하지만, 실제로 확인한 결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf7e&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x7fffffffdf50&lt;/code&gt; 이었다. 즉 8byte 만큼이 더 할당되어 있었다. buf[0x28] 이 실제로는 buf[0x30] 이었던 것이다.&lt;/p&gt;

&lt;p&gt;이 이유가 궁금해 알아보니, 스택 보호의 일환으로 c 컴파일러가 char 배열을 할당할 때 8byte 정도를 더 할당해 준다는 사실을 알 수 있었다. 단순히 이론상으로만 문제에 접근할 게 아니라 실제로 구동하는 상황에서의 메모리 구조를 확인한 이후 익스플로잇을 작성하는 게 좋겠다는 교훈을 얻을 수 있었다.&lt;/p&gt;

&lt;h3 id=&quot;익스플로잇-작성하기&quot;&gt;익스플로잇 작성하기&lt;/h3&gt;

&lt;p&gt;익스플로잇에서 프로세스에게 보낼 페이로드를 먼저 구상해 보자. 프로세스가 구동중일 때 실제 스택의 구조는 아래와 같았다.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp-0x1]~[rbp-0x30]&lt;/strong&gt;: buf[0x28]                                                              //0x30 byte&lt;/p&gt;

&lt;p&gt;================main() 스택 프레임 끝====================&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x7]~[rbp]&lt;/strong&gt;: start_main()의 rbp 주소(0x0000000000000000)      //0x08 byte&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[rbp+0x0e]~[rbp+0x07]&lt;/strong&gt;: main()이 끝난 후 이어서 실행될 인스트럭션 주소  //0x08 byte&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++&lt;/p&gt;

&lt;p&gt;따라서 우리는 총 0x38 byte를 더미값으로 채운 후, 마지막 0x08 byte에 실행되길 원하는 get_shell() 함수의 시작 주소를 붙인 페이로드를 만들면 된다.&lt;/p&gt;

&lt;p&gt;이렇게 생성한 페이로드를 정상적으로 프로세스에 입력해줄 수 있는 python 스크립트를 만들어 실행하면 셸이 실행될 것이다. 여기에 해당 스크립트를 적고 자세한 분석 내용을 쓸까 고민했지만, 그렇게 하면 스포일러가 될지도 모르겠다는 생각이 들어 생략한다.&lt;/p&gt;

&lt;p&gt;다만, 우리가 이제까지 배운 pwn 라이브러리 상에서 문제를 해결할 수 있으며, 어떤 메소드가 어떤 형식의 값을 받아 어떤 형식의 값을 리턴하는지, 그리고 셸을 땄음을 어떻게 확인할 수 있을지를 생각하고 스크립트를 작성하는 것을 추천한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Jul 2022 18:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system-hacking-step3-2/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system-hacking-step3-2/</guid>
      </item>
    
      <item>
        <title>System Hackig Step 3-1</title>
        <description>&lt;h1 id=&quot;stage-3-1&quot;&gt;STAGE 3-1&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;gdb 설치와 pwndbg 플러그인 설치하기.&lt;/li&gt;
  &lt;li&gt;만일 뭔가 잘못해서 aslr 커맨드의 화이트리스트로~ 라는 경고문이 나온다면, 그건 여러 gdb 플러그인을 설치했기 때문에 .gdbinit 파일이 중복돼서 생기는 문제이므로 ~/.gdbinit 파일을 깨끗하게 지우고 설치했던 플러그인 폴더들을 다 지운 후 gdb가 여전히 남아 있는지 확인 한 번 해보고 다시 플러그인을 설치하는 것을 추천한다. 설치할 때의 instruction을 잘 따르자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;gdb-사용하기-기초&quot;&gt;gdb 사용하기 기초&lt;/h1&gt;

&lt;h2 id=&quot;tldr&quot;&gt;TL;DR&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb는 리눅스의 대표적인 디버거&lt;/li&gt;
  &lt;li&gt;무료로 설치할 수 있고, 수많은 유용한 플러그인을 결합해 사용할 수 있음.&lt;/li&gt;
  &lt;li&gt;다양한 명령어가 존재하며, 적재적소에 명령어를 사용할 때 그 진가를 발휘할 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;prolog&quot;&gt;Prolog&lt;/h2&gt;

&lt;p&gt;리눅스의 실행파일은 .elf이다. 이런 elf 파일의 정보를 읽어오기 위해 리눅스에서 기본으로 제공하고 있는 명령어가 있는데, 그것은 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readelf&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readelf -h {file path}&lt;/code&gt; 를 실행해 대상 실행 파일의 헤더 정보를 읽어온 결과는 아래와 같이 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled.jpeg&quot; alt=&quot;readelf로 elf 파일의 헤더 정보를 읽어온 결과&quot; /&gt;&lt;/p&gt;

&lt;p&gt;readelf로 elf 파일의 헤더 정보를 읽어온 결과&lt;/p&gt;

&lt;p&gt;이를 이용해 대상 파일의 EP, 즉 entry point를 알 수 있다. &lt;strong&gt;리버싱할 때 제일 중요한 게 바로 이 EP를 찾는 것&lt;/strong&gt;인데, 리눅스 환경에서 ELF 파일은 손쉽게 EP를 알 수 있으므로 스타트는 쉽게 끊을 수 있다.&lt;/p&gt;

&lt;p&gt;다만 ASLR 이라고 리눅스 자체 메모리 보호 기법이 있는데, 힙이나 스택 등 어떤 프로세스를 실행할 때마다 그 프로세스에게 할당되는 가상 메모리의 주소가 전부 달라지는 기능이 있다. ASLR이 설정되어 있다면 디버깅할 때마다 모든 주소가 달라지는 진기명기를 확인할 수 있으니, ASLR을 꺼두는 것을 추천한다.&lt;/p&gt;

&lt;p&gt;ASLR이 함수의 EP에도 영향을 주는지는 내가 방금 ASLR을 끄고 디버깅해서 확인했다. 진짜로 끄는 것을 강력 추천한다.&lt;/p&gt;

&lt;p&gt;ASLR을 해제하기 위해서는 아래의 명령어를 터미널에 입력하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo sysctl -w kernel.randomize_va_space=0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;해당 elf 파일의 헤더 정보를 알아냈다면, 드디어 gdb를 이용해 실행 파일을 분석해 볼 시간이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gdb {file_path}&lt;/code&gt; 를 실행해 gdb를 해당 파일에 붙인다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 명령어를 입력한다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%201.jpeg&quot; alt=&quot;start 명령어를 실행한 결과.&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;start 명령어를 실행한 결과.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;gdb의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 명령어는 EP부터 프로그램을 분석할 수 있게 해준다.&lt;/li&gt;
      &lt;li&gt;현재 rip의 값은 DISASM 섹션의 화살표가 가리키고 있는 주소이다.
        &lt;ul&gt;
          &lt;li&gt;이 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x555555555149&lt;/code&gt; 임을 확인할 수 있다.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 에 BP가 걸린 걸 보니 이 프로세스의 EP는 오프셋 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 일 것이다.&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;아니 앞에서는 EP 주소가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1060&lt;/code&gt; 인데 왜 main의 엔트리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x1149&lt;/code&gt; 인 거야???&lt;/p&gt;

            &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%202.jpeg&quot; alt=&quot;이해가 안 돼서 main의 엔트리와 원래 엔트리로 예상되는 주소의 데이터를 체크해 보았다.&quot; /&gt;&lt;/p&gt;

            &lt;p&gt;이해가 안 돼서 main의 엔트리와 원래 엔트리로 예상되는 주소의 데이터를 체크해 보았다.&lt;/p&gt;

            &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_start&lt;/code&gt; 함수는 컴파일할 때 자동으로 따라와 붙는 함수인데, 해당 함수의 끝 부분에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__libc_start_main&lt;/code&gt; 이라는 dll을 호출한다. 해당 dll에서 연쇄적인 호출 과정을 거쳐서 내가 만든 프로세스의 진짜 엔트리인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 이 호출되기 때문이 이와 같은 불일치 현상이 일어나는 것이다.&lt;/p&gt;

            &lt;p&gt;한 마디로 elf 파일의 엔트리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_start&lt;/code&gt; 함수부터라고 인식하지만, gdb를 붙여서 돌렸을 때 gdb는 쓸데없는 dll 실행은 넘겨 버리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 에 BP를 만들기 때문에 발생하는 현상이다. &lt;del&gt;gdb가 너무 똑똑해서 생긴 문제였다…!&lt;/del&gt;&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;context-pwndbg의-대시보드&quot;&gt;Context: pwndbg의 대시보드&lt;/h2&gt;

&lt;p&gt;사실 Context라는 말은 프로세스 관련해서 많이 쓰이는 말이다. pwndbg는 이런 context의 특성을 차용해 &lt;strong&gt;프로세스 실행 시 주요 메모리들의 실시간 상태를 보여주는&lt;/strong&gt; 자신의 대시보드를 &lt;strong&gt;Context&lt;/strong&gt;라고 칭하고 있다.&lt;/p&gt;

&lt;p&gt;pwndbg의 context는 크게 4개의 영역으로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%203.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Registers: 레지스터의 상태를 보여준다. 레지스터의 종류가 뭐였지? 라는 의문이 든다면 &lt;a href=&quot;https://toubva.github.io/blog/system-hacking-step2/#/&quot;&gt;System Hacking Step2: Computer Architecture&lt;/a&gt; 참고.&lt;/li&gt;
  &lt;li&gt;Disasm: rip부터 시작해서 여러 줄에 걸쳐 디스어셈블된 결과를 보여주는 섹션이다. 즉, 앞으로 실행될 인스트럭션들을 어셈블리어로 보여주는 섹션이다.&lt;/li&gt;
  &lt;li&gt;Stack: rsp부터 여러 줄에 걸쳐 스택의 값들을 보여준다. 스택의 맨 위부터 뭐가 있는지(스택에 뭐가 들어있는지 가장 최신의 것부터)를 어느 정도 보여준다는 뜻이다.&lt;/li&gt;
  &lt;li&gt;Backtrace: 현재 rip에 도달할 때까지 어떤 함수들이 중첩되어 호출됐는지 보여준다. 화살표가 있는 부분이 현재 rip가 있는 함수이고, 그 밑에 있는 것들이 이제까지 호출됐던 함수 목록이다. 보통 이러면 콜스택 보여주지 않나? 왜 굳이 이미 지나가서 기능이 끝난 함수들을 보여주려 하지?&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;breakcontinue&quot;&gt;break&amp;amp;continue&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb를 이용해 프로그램을 분석할 땐, 프로그램의 동작 중 아주 일부분에만 관심이 있을 때이다.&lt;/li&gt;
  &lt;li&gt;이러한 목적 달성을 위해 break와 continue라는 기능이 있다.
    &lt;ul&gt;
      &lt;li&gt;break: 특정 주소에 중단점(breakpoint)를 설정하는 기능&lt;/li&gt;
      &lt;li&gt;continue: 현재 지점에서 다음 중단점까지 멈춤 없이 실행하는 기능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;run&quot;&gt;run&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램을 단순히 실행만 시키는 명령어.&lt;/li&gt;
  &lt;li&gt;중단점에서 멈추지만, &lt;strong&gt;프로그램을 처음부터 시작한다-중단점이 있으면 멈춘다&lt;/strong&gt;의 시퀀스이므로 &lt;strong&gt;중단점에서 시작한다-다음 중단점에서 멈춘다&lt;/strong&gt;의 시퀀스를 가진 &lt;strong&gt;continue와는 확연한 차이점&lt;/strong&gt;이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;aside&gt;
⚙ gdb는 명령어 줄여쓰기 기능을 제공하기 때문에, 명령어를 특정할 수 있는 최소한의 문자열만 입력하면 자동으로 명령어를 찾아서 수행해 준다. 예를 들어서, 앞서 설명한 break는 b만 쳐도 되고, continue의 경우에는 c만 쳐도 된다. run 또한 r만 쳐도 자동으로 실행된다.

&lt;/aside&gt;

&lt;h2 id=&quot;disassembly&quot;&gt;disassembly&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb에서 기본으로 제공하는 디스어셈블 명령어.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수 이름을 인자로 전달하면 해당 함수가 리턴될 때까지 전부 디스어셈블해 보여준다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%204.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pwndbg에서는 &lt;strong&gt;u, nearpc, pdisassemble&lt;/strong&gt;을 제공한다. 디스어셈블된 코드를 가독성 좋게 출력해준다는 점에서 쓸 만하다!&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%205.jpeg&quot; alt=&quot;확실히 낫다.&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;확실히 낫다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;navigate-ni-si-finish&quot;&gt;navigate: ni, si, finish&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;명령어를 한 줄씩 자세히 분석하는 기능.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ni(next instruction)&lt;/strong&gt;: 어셈블리 명령어를 딱 한 줄 실행한다. &lt;strong&gt;서브루틴의 내부로 들어가지 않는다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;si(step into)&lt;/strong&gt;: 어셈블리 명령어를 딱 한 줄 실행한다. &lt;strong&gt;서브루틴의 내부로 들어간다.&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;finish&lt;/strong&gt;: 함수 규모가 너무 커서 ni로는 도무지 원래 함수로 돌아올 수 없는 경우, 현재 위치한 함수의 맨 끝까지 한번에 실행할 수 있는 명령어.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서브루틴이란?
    &lt;ul&gt;
      &lt;li&gt;함수 내부에서 다른 함수를 콜할 때, 그 다른 함수의 실행 루틴을 서브루틴이라고 한다.&lt;/li&gt;
      &lt;li&gt;즉 서브루틴의 내부=현재 함수에서 콜한 다른 함수의 내부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;examine-x&quot;&gt;examine: x&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가상 메모리에 존재하는 임의 주소의 값을 관찰해야 할 때 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;x&lt;/strong&gt;: &lt;strong&gt;원하는 주소&lt;/strong&gt;에서, &lt;strong&gt;원하는 길이&lt;/strong&gt;만큼의 데이터를 &lt;strong&gt;원하는 형식으로 인코딩&lt;/strong&gt;해 확인할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;형식: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x/{원하는 데이터 묶음 수}{한 데이터 묶음의 길이}{데이터 형식}  {메모리 주소}&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;한 데이터 묶음의 길이(size): b(byte), h(halfword), w(word), g(giant; 8 bytes)&lt;/li&gt;
          &lt;li&gt;데이터의 형식(format): o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string), z(hex, zero padded on the left)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;telescope&quot;&gt;telescope&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pwndbg가 제공하는 메모리 덤프 기능. 메모리가 참조하고 있는 주소를 재귀적으로 탐색해 값을 보여주기까지 함!&lt;/li&gt;
  &lt;li&gt;현재 보이는 이 값이 어떤 주소에서 어떻게 사용되는지까지 알 수 있으므로 굉장히 유용하다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;rsp 기준으로 8개의 메모리 주소를 보여주기 때문에 콜스택의 역사를 알 수 있다.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%206.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;vmmap&quot;&gt;vmmap&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;가상 메모리의 레이아웃을 보여주며, 어떤 파일이 매핑된 영역일 때 해당 파일의 경로까지 보여줌.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cat /proc/{pid}/maps와 동일한 일을 한다. 물론 가독성은 훨씬 좋다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%207.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;aside&gt;
⚙ 파일 매핑:

- 어떤 파일을 메모리에 적재하는 것.
- 리눅스에서 ELF를 실행할 때의 과정:
    1. ELF 자체의 코드, 데이터 등을 가상 메모리에 매핑 
    2. 해당 ELF에 링크된 공유 오브젝트(.so)를 추가로 메모리에 매핑
        - 리눅스의 so = 윈도우의 dll
    3. so에 구현된 함수를 호출할 땐 매핑된 메모리에 존재하는 함수를 대신 호출(메모리에 적재된 so 내부의 함수를 호출)
&lt;/aside&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;gdbpython&quot;&gt;gdb/python&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;gdb를 이용해 디버깅 시, 숫자/알파벳 이외의 값은 입력값으로 직접 입력해줄 수 없는 문제가 있다.&lt;/li&gt;
  &lt;li&gt;첫번째 방식: python argv
    &lt;ul&gt;
      &lt;li&gt;목표 프로그램에 gdb를 붙이고 r 명령어의 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$({원하는 내용을 줄 수 있는 파이썬 코드})&lt;/code&gt; 를 입력하면 프로그램의 &lt;strong&gt;‘인자’&lt;/strong&gt;를 전달할 수 있다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예:&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%208.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두번째 방식: python input
    &lt;ul&gt;
      &lt;li&gt;목표 프로그램에 gdb를 붙이고, r 명령어의 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt; $({파이썬 코드})&lt;/code&gt; 를 입력하면 프로그램 실행 중에 받는 &lt;strong&gt;‘입력값’&lt;/strong&gt;을 미리 전달할 수 있다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;사용예: *(해당 프로그램은 인자와 입력값 모두를 요구하기 때문에 첫번째 방식과 두번째 방식이 함께 쓰였다.)&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/syshack3-1/Untitled%209.jpeg&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;그-외-자주-사용되는-명령어들과-그-단축키&quot;&gt;그 외 자주 사용되는 명령어들과, 그 단축키&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;b: break&lt;/li&gt;
  &lt;li&gt;c: continue&lt;/li&gt;
  &lt;li&gt;r: run&lt;/li&gt;
  &lt;li&gt;si: step into
    &lt;ul&gt;
      &lt;li&gt;어떤 함수 안으로 들어가는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ni: next instruction
    &lt;ul&gt;
      &lt;li&gt;명령어를 딱 한 줄 더 실행하는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;i: info
    &lt;ul&gt;
      &lt;li&gt;접두어로 주로 사용되고, 접미로 붙는 요소의 정보를 확인하는 데 사용된다.&lt;/li&gt;
      &lt;li&gt;예시: info b (현재 브레이크 포인트 보기)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;k: kill
    &lt;ul&gt;
      &lt;li&gt;kill process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pd: pdisas
    &lt;ul&gt;
      &lt;li&gt;기존 gdb 명령어의 peda 버전으로, disas의 확장판이다.&lt;/li&gt;
      &lt;li&gt;화면이 좀 더 예쁘게, 가독성 좋게 나온다. &lt;del&gt;기부니가 조크든요&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
        <pubDate>Sun, 10 Jul 2022 21:10:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system-hacking-step3-1/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system-hacking-step3-1/</guid>
      </item>
    
      <item>
        <title>System Hackig Step 2-2</title>
        <description>&lt;h1 id=&quot;stage-2&quot;&gt;STAGE 2&lt;/h1&gt;

&lt;h1 id=&quot;x86-assembly-part-1&quot;&gt;x86 Assembly: Part 1&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;리버싱 공부하면서 이미 했던 거라 여기에서는 간단하게 메모만 하고 넘어갑니다.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어셈블리어 → (by 어셈블러) → 기계어&lt;/li&gt;
  &lt;li&gt;역어셈블러 ↔  어셈블러
    &lt;ul&gt;
      &lt;li&gt;즉, 역어셈블러는 기계어 → 어셈블리어. 우리가 리버싱 할 때 없으면 안되는 것!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;어셈블리어와-x86-64&quot;&gt;어셈블리어와 x86-64&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;요약&gt;

- CPU의 ISA(Instruction Set Architecture) 종류별로 어셈블리어가 다르다.
- 여기에서 다룰 어셈블리어는 x64 어셈블리어.
&lt;/요약&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;어셈블리어의-기본-구조&quot;&gt;어셈블리어의 기본 구조&lt;/h3&gt;

&lt;aside&gt;
💡 OpCode    Operand1, Operand2

&lt;/aside&gt;

&lt;p&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov   eax, 3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;어셈블리-명령어--중-알아두면-좋을-것&quot;&gt;어셈블리 명령어  중 알아두면 좋을 것&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령 코드&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Data Transfer&lt;/td&gt;
      &lt;td&gt;mov, lea&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Arithmetic&lt;/td&gt;
      &lt;td&gt;inc, dec, add, sub&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Logical&lt;/td&gt;
      &lt;td&gt;and, or, xor, not&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Comparison&lt;/td&gt;
      &lt;td&gt;cmp, test&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Branch&lt;/td&gt;
      &lt;td&gt;jmp, je, jg&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stack&lt;/td&gt;
      &lt;td&gt;push, pop&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Procedure&lt;/td&gt;
      &lt;td&gt;call, ret, leave&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;System call&lt;/td&gt;
      &lt;td&gt;syscall&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;어셈블리-명령어의-피연산자&quot;&gt;어셈블리 명령어의 피연산자&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;“총 3가지 종류”&lt;/strong&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;상수(Immediate Value): {immediate_value}&lt;/li&gt;
    &lt;li&gt;레지스터(Register): {register_name}&lt;/li&gt;
    &lt;li&gt;메모리(Memory): &lt;strong&gt;[{memory_address}] …&lt;/strong&gt; &lt;em&gt;몰랐음!!&lt;/em&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;strong&gt;앞에 크기 지정자(Size Directive)인 TYPE PTR 추가될 수 있다.&lt;/strong&gt;&lt;/li&gt;
        &lt;li&gt;BYTE(1 byte), WORD(2 byte), DWORD(4 byte), QWORD(8 byte)
          &lt;ul&gt;
            &lt;li&gt;WORD가 2 byte인 이유: 맨 처음 인텔의 아키텍처가 16비트였는데, 나중에 아키텍처 확장 과정을 거치다 보니 WORD 자료형 크기를 변경해 버리면 다른 아키텍처에서 프로그램 호환이 안 되는 문제가 생겨서 그냥 16비트 유지.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;x86-64-어셈블리-명령어&quot;&gt;x86-64 어셈블리 명령어&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;리버싱과 시스템 해킹의 원리에서 공부했던 내용이므로 간략히 정리하고 넘어감.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-이동-명령어&quot;&gt;데이터 이동 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;mov dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;src의 값을 dst에 이동.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;lea dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;src의 &lt;strong&gt;유효 주소&lt;/strong&gt;를 dst에 저장.&lt;/li&gt;
    &lt;li&gt;즉, src는 memory 타입의 피연산자로 오게 된다.
      &lt;ul&gt;
        &lt;li&gt;ex) lea rsi, [rbx+8&lt;em&gt;rcx]: rbx+8&lt;/em&gt;rcx를 rsi에 대입한다.&lt;/li&gt;
        &lt;li&gt;많이 헷갈리니까 주의!!!&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;산술-연산-명령어&quot;&gt;산술 연산 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;add dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst+=src&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;sub dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst-=src&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;inc op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op ++&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;dec op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op –&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;논리-연산-명령어&quot;&gt;논리 연산 명령어&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;and&lt;/strong&gt; dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst&amp;amp;=src&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;마스킹&lt;/strong&gt; 연산
      &lt;ul&gt;
        &lt;li&gt;eax=0xffff, ebx=0xcafe일 때, and eax, ebx를 시행하면 eax=0xcafe&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;or&lt;/strong&gt; dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;dst&lt;/td&gt;
            &lt;td&gt;=src&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;역 마스킹&lt;/strong&gt; 연산
      &lt;ul&gt;
        &lt;li&gt;eax=0xffff0000, ebx=0xdeadbeef일 때, or eax, ebx를 시행하면 eax=0xffffbeef&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;xor dst, src&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;dst^=src&lt;/li&gt;
    &lt;li&gt;비트가 다르면 1, 같으면 0&lt;/li&gt;
    &lt;li&gt;따라서, xor 연산을 동일한 값으로 두 번 실행할 경우, 원래 값으로 돌아감.
      &lt;ul&gt;
        &lt;li&gt;ex) rax=0x35014541, rbx=0xdeadbeef일 때,
          &lt;ul&gt;
            &lt;li&gt;xor rax, rbx 시행 후 rax=0xebacfbae&lt;/li&gt;
            &lt;li&gt;또 다시 xor rax, rbx 시행하면 rax=0x35014541&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;이런 성질을 이용해 XOR cipher가 개발(블록 암호화에서도 XOR의 성질을 이용해서 암호화하는 방식이 많은 것으로 기억함!)&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;not op&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;~(op) 즉, op의 비트 전부 반전(1의 보수)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;xor rax, rbx
xor rax, rbx
not eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;를 수행했을 때, 맨 마지막의 not eax까지를 수행하면 rax의 하위 32비트가 1의 보수를 취하여 다시 rax의 하위 32비트를 채우게 된다. rax의 하위 32비트가 eax이고, 실제로 그렇게 사용할 수 있다는 점 잊지 말자!&lt;/p&gt;

&lt;h3 id=&quot;비교-연산-명령어&quot;&gt;비교 연산 명령어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;“두 피연산자의 값을 비교하고, 플래그를 설정한다.”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cmp와 test의 비교는 리버싱을 공부할 때 많이 헷갈렸던 부분이다. 주의하자!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;cmp op1, op2&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op1과 op2를 비교한다.&lt;/li&gt;
    &lt;li&gt;“빼서” 비교한다.&lt;/li&gt;
    &lt;li&gt;연산의 결과는 ZF에 설정된다.&lt;/li&gt;
    &lt;li&gt;보통 “같은지” 확인하기 위해 사용한다.
      &lt;ul&gt;
        &lt;li&gt;같다면 ZF=1로 설정되고, jmp 분기문에서 설정에 따라 코드 플로우를 분기시키게 된다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;test op1, op2&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;op1과 op2를 비교한다.&lt;/li&gt;
    &lt;li&gt;“AND”를 취해 비교한다.&lt;/li&gt;
    &lt;li&gt;연산의 결과는 ZF에 설정된다.&lt;/li&gt;
    &lt;li&gt;보통 “자기 자신이” 0이었는지 확인하기 위해 사용한다.
      &lt;ul&gt;
        &lt;li&gt;자신이 0이었다면 ZF=1로 설정된다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;왜냐하면 자기 자신과 AND를 취했을 때 0이 나올 수 있는 경우는 오로지 자기 자신이 0일 때 뿐이므로!&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;분기-명령어&quot;&gt;분기 명령어&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;“rip를 이동시켜 실행 흐름을 바꾼다!”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리버싱을 할 때 정말 잘 알아둬야 한다. 왜냐하면 보통의 프로그램들은 분기에 따른 경우수를 기반으로 행동을 하기 때문이다.&lt;/p&gt;

&lt;p&gt;rip가 이동되는 이유는 컴퓨터 아키텍처를 공부한 적 있다면 알 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU는 jmp등의 분기문을 만나면 PC에 저장된 다음 인스트럭션 주소를 바꿔서 jmp 명령어가 가리키는 인스트럭션을 수행하게 되는데, 이때 PC가 rip이기 때문에 분기 명령어는 결론적으로 rip를 이동시켜 실행 흐름을 바꾸게 된다.&lt;/li&gt;
  &lt;li&gt;jmp 계열 명령어는 jmp op1, op2일 때 op1을 기준으로 이름을 붙이게 된다.
    &lt;ul&gt;
      &lt;li&gt;ex) jg op1, op2 // jump if op1 is greater than op2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;x86-assembly-part-2&quot;&gt;x86 Assembly: Part 2&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;리버싱 공부하면서 이미 했던 거라 여기에서는 간단하게 하고 넘어갑니다.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스택: 운영체제의 핵심 자료구조&lt;/li&gt;
  &lt;li&gt;프로시저: C언어의 함수에 대응&lt;/li&gt;
  &lt;li&gt;시스템 콜: 시스템 해킹의 관점에서 정말 중요함.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;x86-64-어셈블리-명령어-pt2&quot;&gt;x86-64 어셈블리 명령어 Pt.2&lt;/h2&gt;

&lt;h3 id=&quot;스택&quot;&gt;스택&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;push: 스택에 쌓아넣기
pop: 스택에서 빼내기&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;push val: val에 들어있는 값을 스택의 최상단에 쌓음
      &lt;ul&gt;
        &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```wasm
rsp -= 8 //stack grows from high to low
[rsp] = val
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;pop reg: 스택 최상단의 값을 꺼내서 reg에 대입
    &lt;ul&gt;
      &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  rsp += 8 // decrease stack span
  reg = [rsp-8] //pop
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로시저&quot;&gt;프로시저&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;프로시저의 호출 및 반환과 관련해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leave&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; 명령어를 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로시저 불러서 진입하기: &lt;strong&gt;call&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;프로시저에서 나가서 원래의 함수로 돌아오기: &lt;strong&gt;return&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;스택프레임 정리하기: &lt;strong&gt;leave&lt;/strong&gt;&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;프로시저를 call 할 당시, 원래의 함수에서 call 다음에 수행할 인스트럭션의 명령어 주소를 스택에 push 해둔 뒤, 콜했던 프로시저의 시작으로 rip를 이동하게 되는데, 이 때 스택에 저장되는 인스트럭션의 주소를 ‘Return address’라 칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;call addr: addr에 있는 프로시저 호출
    &lt;ul&gt;
      &lt;li&gt;이 때 일어나는 연산을 pseudo-code로 표현하면 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  push return_address // push return address into the stack
  jmp addr
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;leave: 스택프레임 정리해서 원래 함수의 스택프레임 복구하기
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;leave 명령어와 동일한 기능을 수행하는 어셈블리 명령어의 조합은 아래와 같다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  **mov** rsp, rbp // 현재 함수에서의 스택 밑바닥이 원래 함수에서의 스택의 가장 꼭대기가 된다.
               // 즉, 현재 스택 꼭대기: 원래 함수의 스택 꼭대기에서 하나 더 간 상태.
  						 // 지금 rsp가 가리키는 위치에는 원래 함수의 스택 베이스 주소가 있다.
  **pop** rbp // 원래 함수의 스택 베이스 주소를 빼서 rbp에 넣어 준다.
  				// 또한 rsp를 하나 내림으로써 원래 함수의 스택 꼭대기와 일치시킨다.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;ret: return address로 rip를 위치시킨다.
    &lt;ul&gt;
      &lt;li&gt;ret 명령어와 동일한 기능을 수행하는 어셈블리 명령어는 아래와 같다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-wasm&quot;&gt;  pop rip // leave를 거친 이후 rsp가 가리키는 곳에는 콜했던 프로시저의 주소로 rip를 움직이기 전에
  			  // 넣어 두었던 다음 인스트럭션의 주소가 저장되어 있다.
  				// 따라서 다음에 수행할 인스트럭션의 주소를 스택에서 빼서 rip에 넣어 줌으로써
  				// 원래의 코드 플로우를 수복한다. 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;해당 명령어가 실제로 펑션콜과 리턴 과정에서 어떻게 사용되는지 시나리오 형식으로 설명해 보자.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;함수 A를 실행하다가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call function_B&lt;/code&gt; 명령어를 맞닥뜨렸다.
    &lt;ol&gt;
      &lt;li&gt;4에서 실행될 다음 인스트럭션의 주소가 스택에 push 된다.&lt;/li&gt;
      &lt;li&gt;함수 A의 스택 프레임을 유지하기 위해 A 스택 프레임의 rbp가 스택에 push 된다.&lt;/li&gt;
      &lt;li&gt;새로운 스택 프레임을 할당해 주기 위해 rbp를 rsp의 위치로 옮긴다.&lt;/li&gt;
      &lt;li&gt;앞에서 배웠듯, OS는 스택 프레임을 할당할 때 소규모로 할당한 후 가변적으로 운영한다. 따라서, 새로운 스택 프레임 공간을 할당하기 위해 rsp에서 0x30 정도를 뺀다.(통상적)&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이렇게 새롭게 할당된 스택 프레임과 기존의 A의 스택 프레임 구조를 확인하면 아래와 같다.&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;========새로운========&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;=======스택 프레임======&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;=========공간=========&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;A의 rbp 주소&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;A 상에서의 다음 인스트럭션 주소&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td&gt;기존에 A에서 쓰고 있던 임시 데이터들&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 B를 실행한다.
    &lt;ol&gt;
      &lt;li&gt;앞에서 배웠듯, 스택에는 지역 변수가 저장된다. 따라서 함수 B의 지역 변수를 새로운 스택 프레임에 저장해 준다.&lt;/li&gt;
      &lt;li&gt;스택 프레임 위에서 여러 연산을 수행한다. 스택 프레임은 함수별로 할당되므로 해당 함수 한정으로만 유효할 수 있는 데이터를 스택에 저장할 것이다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 A로 복귀한다.
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leave&lt;/code&gt; 명령어가 실행된다. 따라서, rsp가 rbp의 위치로 이동하고 스택에 있던 A의 rbp 주소가 pop 되면서 rbp가 기존의 A의 스택 프레임의 rbp 주소를 가지게 된다.
        &lt;ul&gt;
          &lt;li&gt;한 마디로, B의 스택 프레임이 정리된 이후 A의 스택 프레임이 복구된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 A 상에서의 다음 인스트럭션을 실행한다.
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; 명령어가 실행된다. 따라서, A 상에서의 다음 인스트럭션 주소가 rip로 들어간다.
        &lt;ul&gt;
          &lt;li&gt;이 시점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; 을 수행하기 이전의 A의 스택 프레임 상태가 완전히 복구된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;rip가 가리키는 주소의 명령어를 실행한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;시스템-콜&quot;&gt;시스템 콜&lt;/h3&gt;

&lt;p&gt;OS를 공부했다면 쉽게 이해할 수 있는 내용이다. 사실 OS 책의 1장 1페이지 정도 펼쳐봤다면 이해할 수 있는 내용이다. 따라서 자세한 부연 설명을 붙이지 않고, 간단히 정리만 하고 넘어간다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;OS는 시스템 보호를 위해 시스템과 직결된 행위(ex: 네트워크 통신, 파일시스템 테이블 생성/추가/삭제, 파일 Read/Write…)는 실행 권한을 분리해서 관리한다. 이럴 때 부여하는 권한이 바로 커널 권한과 유저 권한이다. 유저 권한을 가진 프로세스들은 커널 권한이 필요한 시스템 행위에 직접 엑세스할 수 없고, &lt;strong&gt;OS에게 요청해&lt;/strong&gt; OS가 대신 커널 권한이 필요한 시스템 행위를 수행하고 그 결과를 받아보는 것이 기본이다.&lt;/p&gt;

  &lt;p&gt;이때 OS는 유저 권한과 커널 권한을 사용하는 상태를 오가는데, 유저 권한을 사용할 때를 ‘유저 모드’, 커널 권한을 사용할 때를 ‘커널 모드’에 있다고 표현한다.&lt;/p&gt;

  &lt;p&gt;개인적으로 OS는 정말 재미있고 흥미로운 문제와 해결의 연속이라고 느꼈기 때문에, 만일 흥미가 생겼다면 공부해 보는 것을 추천한다. 리눅스부터 공부하는 게 좋을 것이다. 멀웨어 분석이 목표라면 윈도우를 공부해야 하겠지만…&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Q. 그럼 프로세스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec echo HOSTNAME&lt;/code&gt; 을 실행할 때 프로세스는 커널 모드로 진입하게 되는 건가요?&lt;/li&gt;
    &lt;li&gt;A. 아닙니다. OS의 구성요소가 아닌 유저 레벨에서 생성되고 관리되는 요소들이라면 무조건 유저 모드에서 벗어날 수 없습니다. 해당 프로세스는 커널 권한이 필요한 행위를 수행하고 싶을 때 &lt;strong&gt;OS에게 수행을 요청&lt;/strong&gt;하고 그 결과만 받아보게 됩니다. 즉 OS가 커널 모드로 진입하고 빠져나옵니다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, OS를 침해하는 해킹이 가장 심각한 결과를 이끌어내는 경우는 해당 해킹이 OS의 커널 모드 권한을 빼앗았을 때 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면 시스템 콜(System Call)이란 무엇일까? 위에 서술한 내용 중에 답이 있다… (소곤소곤)&lt;/p&gt;

&lt;p&gt;굵은 글씨로 쓰인 내용을 보자. 그리고 다음 설명을 보자. System Call이란 유저 모드에서 커널 모드에서의 수행이 필요할 때 ‘요청하는 것’이다. 이해가 확 될 것이다.&lt;/p&gt;

&lt;p&gt;정리해서,&lt;/p&gt;

&lt;aside&gt;
⚙ 유저 모드의 프로세스에서 커널 모드의 동작이 필요하다. → System Call을 한다. → OS는 해당 요청을 승인해 커널 모드의 동작을 수행한다. → OS는 수행 결과를 반환한다. → 프로세스는 반환받은 결과를 이용한다.

&lt;/aside&gt;

&lt;p&gt;x64 아키텍처에서는 시스템콜을 하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어를 쓴다. &lt;del&gt;나도 프로그래밍 하다가 본 것 같다… 아마도?&lt;/del&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기에서 끝나면 안된다. 지금 이 포스트의 목적은 ‘어셈블리어’를 공부하는 것이지 OS 개론을 공부하는 게 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어로 사용할 수 있는 시스템 콜은 함수다. 즉, 인자가 있고, 해당 인자를 이용해 어떠한 행위를 한다. 이 경우에는 커널에게 ‘사전 정보’를 주면서 ‘원하는 행위’를 요청하는 것임을 추측할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 원하는 행위와 사전 정보를 전달할 때, 아키텍처 레벨로 내려가 본다면 당연히 레지스터가 개입할 것이다. 파라미터가 있는 펑션콜이 수행되는 과정을 한 번 어셈블리 디버거로 보게 되면 직관적으로 알 수 있다. 그렇다면 어떤 레지스터가 통상적으로 개입할까? 그리고 어떤 레지스터에 ‘사전 정보’와 ‘원하는 행위’가 들어갈까?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;리눅스의 경우 ‘원하는 행위’를 가리키는 데이터는 rax에 저장된다.&lt;/strong&gt; 해당 값은 시스템 콜 테이블이라는 시스템 콜이 저장되어 있는 테이블의 인덱스 넘버이므로, 어떠한 행위를 원하는지를 시스템이 인식할 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 행위를 원하는지 알았다면 그 행위에 필요한 인자를 받아야 할 차례다. 한 예로, 현재 메모리에 있는 값을 읽어 와 콘솔에 write하려 한다고 하자. (write가 핵심이다. 프로세스가 선언한 데이터가 저장되어 있는 영역을 read할 땐 유저 권한으로 한다. 애초에 메모리에는 커널만을 위한 영역이 따로 있어서 엄격하게 커널과 유저 권한을 분리한다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;write를 하기 위해서는 ‘어디에’ ‘무엇을’ ‘얼마만큼의 길이로’ 쓸 것인지를 알려 줘야 한다.&lt;/strong&gt; 그리고 OS는 정확하게 이 세 가지 요건을 입력받아 write 연산에 사용한다. 각 정보는 rdi, rsi, rdx에 저장된다. 레지스터의 용도를 고려해 보면 일리가 있게 저장되는 셈이다.&lt;/p&gt;

&lt;p&gt;rdi는 destination, 즉 정보가 어디로 향할지를 저장하는 데 쓰이고, rsi는 source, 즉 정보의 출처가 어디인지 지정하는 데 쓰이므로 각각 ‘어디에’와 ‘무엇을’ 을 저장하는 데 적합한 논리를 가지고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;그렇다면 ‘얼마만큼의 길이로’를 저장하는 rdx는? 이건 사실 일반적인 convention 때문에 쓰인다. 그 convention이란 무엇이냐면…&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rdi&lt;/td&gt;
      &lt;td&gt;첫 번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rsi&lt;/td&gt;
      &lt;td&gt;두번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rdx&lt;/td&gt;
      &lt;td&gt;세번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rcx&lt;/td&gt;
      &lt;td&gt;네번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r8&lt;/td&gt;
      &lt;td&gt;다섯번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r9&lt;/td&gt;
      &lt;td&gt;여섯번째 인자 저장&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;바로 위의 테이블이다. 일반적으로 함수의 파라미터를 전달할 때 레지스터는 위와 같은 순서로 인자를 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그런데 좀 이상하네… 지금 이걸 쓰면서 생긴 의문인데, 이런 convention은 system call에 인자를 전달하면서 생겨나서 유저 권한의 함수를 콜할 때도 쓰게 된 거 아닌가? 그럼 system call에 rdx를 세번째 인자를 전달할 때 쓰는 이유는 대체 왜지? 언젠가 알게 되겠지… 지금은 이게 핵심이 아니니까 넘어가자.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;정리해 보자. 만일 콘솔에 메모리 상의 어떤 정보를 읽어와 write한다고 치면&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 명령어가 실행된다. 이렇게 syscall 명령어가 실행되면 &lt;strong&gt;CPU는 rax부터 쳐다보게 된다.&lt;/strong&gt; &lt;del&gt;(언니 뭐부터 할까요)&lt;/del&gt; 그렇게 어떤 시스템 콜을 실행할지 결정하면 CPU는 해당 시스템 콜에 사용할 인자를 확인하기 위해 아래의 순서로 레지스터를 참조한다.(유저 권한에서 시스템 콜을 요청할 때는 아래의 sequence로 진행되고, 커널 권한의 인터페이스에서 뭔가를 할 땐 또 다른 sequence로 레지스터를 읽는다)&lt;/p&gt;

&lt;aside&gt;
⚙ **rdi → rsi → rdx → rcx → r8 → r9 → stack**

&lt;/aside&gt;

&lt;p&gt;rax에서 write system call을 가리키고 있기 때문에, 이제 커널은 write(out_mode, data_add, length)를 수행하게 된다. 인자가 3개이므로 커널이 참조하는 레지스터는 rdi, rsi, rdx가 된다.&lt;/p&gt;

&lt;p&gt;참고로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syscall&lt;/code&gt; 이 리턴되면 레지스터 컨벤션에 따라 rax에 시스템 콜의 결과가 저장된다. 에러 번호라든가 성공 여부라든가…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;부록: System call table 중 주요 몇 가지 시스템 콜(검색하면 나옴)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;syscall&lt;/th&gt;
          &lt;th&gt;rax&lt;/th&gt;
          &lt;th&gt;arg0 (rdi)&lt;/th&gt;
          &lt;th&gt;arg1 (rsi)&lt;/th&gt;
          &lt;th&gt;arg2 (rdx)&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;read&lt;/td&gt;
          &lt;td&gt;0x00&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;write&lt;/td&gt;
          &lt;td&gt;0x01&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt;const char *buf&lt;/td&gt;
          &lt;td&gt;size_t count&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;open&lt;/td&gt;
          &lt;td&gt;0x02&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;int flags&lt;/td&gt;
          &lt;td&gt;umode_t mode&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;close&lt;/td&gt;
          &lt;td&gt;0x03&lt;/td&gt;
          &lt;td&gt;unsigned int fd&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mprotect&lt;/td&gt;
          &lt;td&gt;0x0a&lt;/td&gt;
          &lt;td&gt;unsigned long start&lt;/td&gt;
          &lt;td&gt;size_t len&lt;/td&gt;
          &lt;td&gt;unsigned long prot&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;connect&lt;/td&gt;
          &lt;td&gt;0x2a&lt;/td&gt;
          &lt;td&gt;int sockfd&lt;/td&gt;
          &lt;td&gt;struct sockaddr * addr&lt;/td&gt;
          &lt;td&gt;int addrlen&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;execve&lt;/td&gt;
          &lt;td&gt;0x3b&lt;/td&gt;
          &lt;td&gt;const char *filename&lt;/td&gt;
          &lt;td&gt;const char *const *argv&lt;/td&gt;
          &lt;td&gt;const char *const *envp&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 28 Jun 2022 18:25:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system-hacking-step2-2/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system-hacking-step2-2/</guid>
      </item>
    
      <item>
        <title>System Hackig Step 2</title>
        <description>&lt;h1 id=&quot;stage-2&quot;&gt;STAGE 2&lt;/h1&gt;

&lt;h1 id=&quot;background-computer-architecture&quot;&gt;Background: Computer Architecture&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Instruction Set Architecture: CPU가 사용하는 명령어와 관련된 설계. CPU가 해석하는 명령어의 집합.
    &lt;ul&gt;
      &lt;li&gt;가장 널리 사용되는 ISA: Intel x86-64, ARM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;x86-64-architectureamd64-architecture&quot;&gt;X86-64 Architecture=AMD64 Architecture&lt;/h2&gt;

&lt;h3 id=&quot;x64-아키텍쳐의-레지스터&quot;&gt;x64 아키텍쳐의 레지스터&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;General Register
    &lt;ul&gt;
      &lt;li&gt;주용도는 있지만, 그 외의 다양한 용도로 사용될 수 있는 레지스터.
        &lt;ul&gt;
          &lt;li&gt;32비트 아키텍쳐 CPU가 제공할 수 있는 가상메모리의 크기: 4GB&lt;/li&gt;
          &lt;li&gt;64비트 아키텍쳐 CPU가 제공할 수 있는 가상메모리의 크기: 16EB(엑사바이트)-어마어마하게 큰 공간으로, 프로세스의 성능에 제한을 걸 일이 없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;x64의 경우 각 범용 레지스터에는 8바이트 저장&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이름이 r로 시작함-64비트 아키텍쳐. 32비트 아키텍쳐는 e로 시작함.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;x64의 general register중 주용도가 정해진 레지스터들.&lt;/p&gt;

        &lt;p&gt;→ ebx는 rbx와는 다르게 메모리 주소를 저장하기 위한 용도로 사용됐었음.&lt;/p&gt;

        &lt;p&gt;→ edx는 rdx와는 다르게 부호 관련한 명령을 저장하기 위한 용도로 사용됐었음.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Segment Register
    &lt;ul&gt;
      &lt;li&gt;6개 종류: cs, ss, ds, es, fs, gs&lt;/li&gt;
      &lt;li&gt;64비트로 아키텍처 확장되면서 용도에 큰 변화가 생김.
        &lt;ul&gt;
          &lt;li&gt;32비트 시절… general register 크기가 작으니 사용 가능한 메모리 주소 폭도 좁았음.&lt;/li&gt;
          &lt;li&gt;따라서 오프셋에 필요한 세그먼트 주소를 저장해 주기 위해 사용됐었음.=사용 가능한 메모리 주소 폭을 늘려 줬음.
            &lt;ul&gt;
              &lt;li&gt;실제 주소 = 오프셋 주소 + 세그먼트 주소&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;그런데 64비트 구조가 되면서 사용 가능한 메모리 주소 폭이 매우 넓어짐.&lt;/li&gt;
          &lt;li&gt;따라서, 이젠 주소를 간접적으로 표현해 주기 위해 사용하는 일이 없어짐.&lt;/li&gt;
          &lt;li&gt;x64에서 cs, ds, ss는 코드 영역, 데이터, 스택 메모리 영역을 가리킬 때 사용됨.&lt;/li&gt;
          &lt;li&gt;나머지 레지스터는 운영체제 별로 용도를 결정할 수 있도록 범용적으로 제작되었음.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Instruction Pointer Register
    &lt;ul&gt;
      &lt;li&gt;다음에 실행할 instruction 가리키기.&lt;/li&gt;
      &lt;li&gt;x64: rip(8 byte), x86-64: eip(4 byte)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Flag Register
    &lt;ul&gt;
      &lt;li&gt;프로세서의 현재 상태를 저장하고 있는 레지스터.&lt;/li&gt;
      &lt;li&gt;x86: 16 bit → x64: 64 bit, “RFLAGS”&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;RFLAGS는 64개의 플래그를 사용할 수 있지만, 실질적으로는 오른쪽 20개 정도 비트만 사용.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2_1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;시스템 해킹을 할 때 주로 접할 플래그&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;레지스터-호환&quot;&gt;레지스터 호환&lt;/h3&gt;

&lt;p&gt;16비트 아키텍처: 앞에 아무것도 안 붙음&lt;/p&gt;

&lt;p&gt;32비트 아키텍처: 앞에 e 붙음&lt;/p&gt;

&lt;p&gt;64비트 아키텍처: 앞에 r 붙음&lt;/p&gt;

&lt;p&gt;예시: ax(eax의 하위 16비트) &amp;lt; eax(rax의 하위 32비트) &amp;lt; rax&lt;/p&gt;

&lt;p&gt;그 와중에 16비트 아키텍처의 레지스터는 eax의 상위 8비트, 하위 8비트를 차지하는 것도 있음. (AX, BX, CX, DX 계열 중 끝이 H면 High로 상위 8비트, L면 Low로 하위 8비트)&lt;/p&gt;

&lt;h1 id=&quot;background-linux-memory-layout&quot;&gt;Background: Linux Memory Layout&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Memory Corruption: 공격자가 악의적으로 조작한 메모리 값에 의해 CPU가 잘못된 동작을 하게 되는 공격. 시스템 해킹의 공격 기법의 기본이 되는 기법.&lt;/li&gt;
  &lt;li&gt;Memory Corruption을 이용한 취약점의 종류:
    &lt;ul&gt;
      &lt;li&gt;Stack Buffer Overflow&lt;/li&gt;
      &lt;li&gt;Off by One&lt;/li&gt;
      &lt;li&gt;Format String Bug&lt;/li&gt;
      &lt;li&gt;Double Free Bug&lt;/li&gt;
      &lt;li&gt;Use After Free&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리눅스-프로세스의-메모리-구조&quot;&gt;리눅스 프로세스의 메모리 구조&lt;/h2&gt;

&lt;h3 id=&quot;5개-segment&quot;&gt;“5개 Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;적재되는 데이터 용도별로 메모리의 구획을 나눈 것.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;리눅스에서 프로세스의 메모리를 구분하는 방식.&lt;/li&gt;
    &lt;li&gt;1) 코드 세그먼트, 2) 데이터 세그먼트, 3) BSS 세그먼트, 4) 힙 세그먼트, 5) 스택 세그먼트&lt;/li&gt;
    &lt;li&gt;구획별로 권한이 다르고, CPU는 해당 구역에 부여된 권한에 맞는 행위만 할 수 있음.
      &lt;ul&gt;
        &lt;li&gt;READ&lt;/li&gt;
        &lt;li&gt;WRITE&lt;/li&gt;
        &lt;li&gt;EXECUTE&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;더 자세히 알고 싶다면, 세그먼테이션 기법 &amp;amp;&amp;amp; x86-64 하드웨어 설계 참고.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/systemHackingStep2_2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우와~ 리눅스에서는 실행 중인 프로세스의 메모리가 5개의 영역으로 구분되고, 각 영역별로 CPU가 부여받은 권한이 다르구나!&lt;/p&gt;

&lt;h3 id=&quot;code-segment&quot;&gt;“Code Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;실행 가능한 기계 코드가 위치하는 영역&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ &amp;amp; EXECUTE: CPU가 코드를 “읽어서” “실행”해야 하므로.&lt;/li&gt;
    &lt;li&gt;WRITE 권한이 절대 있으면 안되는 영역: 악의적인 코드를 “쓰면” 안 되니까.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;data-segment&quot;&gt;“Data Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일 시점에 값이 정해진 전역 변수 &amp;amp; 전역 상수가 위치하는 영역.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Initialized Global&lt;/li&gt;
    &lt;li&gt;READ + (상황에 따라 WRITE)&lt;/li&gt;
    &lt;li&gt;데이터 세그먼트에는 두 종류가 있음.
      &lt;ul&gt;
        &lt;li&gt;Data Segment
          &lt;ul&gt;
            &lt;li&gt;WRITABLE: 프로그램이 실행되면서 값이 변할 수 있는 데이터들. 예) 글로벌 “변수” 등…&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;ROData Segment: Read-Only
          &lt;ul&gt;
            &lt;li&gt;Non-WRITABLE: 프로그램이 실행되면서 값이 변하면 안 되는 데이터들. 예) 글로벌 “상수”&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;bss-segment&quot;&gt;“BSS Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 영역.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Block Started by Symbol Segment&lt;/li&gt;
    &lt;li&gt;Not Initialized Global; 선언만 하고 초기화는 안한 전역 변수들&lt;/li&gt;
    &lt;li&gt;프로그램 시작 시 모두 0으로 값이 초기화됨.&lt;/li&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;stack-segment&quot;&gt;“Stack Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스의 스택이 위치하는 영역. 함수의 인자, 지역 변수 등의 임시 변수들이 ‘프로세스 실행 중’에 저장되는 공간.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
    &lt;li&gt;“스택 프레임(Stack Frame)”이라는 단위로 사용됨.
      &lt;ul&gt;
        &lt;li&gt;함수가 호출될 때 생성되고, 반환될 때 해제됨(우리가 익히 아는 그것)&lt;/li&gt;
        &lt;li&gt;프로그램의 코드 플로우를 정확히 예측하는 건 불가능하므로, 스택도 가변적으로 할당됨.
          &lt;ul&gt;
            &lt;li&gt;작은 크기의 스택 세그먼트를 먼저 할당해 주고, 부족해지면 확장.&lt;/li&gt;
            &lt;li&gt;“아래로 자란다”: 높은 주소→낮은 주소로 확장.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;heap-segment&quot;&gt;“Heap Segment”&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;힙 데이터가 위치하는 세그먼트. 메모리 할당 시 할당된 메모리가 저장된다.&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;READ + WRITE&lt;/li&gt;
    &lt;li&gt;스택과 동일하게 실행중에 동적으로 할당된다.&lt;/li&gt;
    &lt;li&gt;리눅스에서는 스택 세그먼트와 반대 방향으로 자란다: 낮은 주소 → 높은 주소로 확장.&lt;/li&gt;
    &lt;li&gt;할당된 메모리가 저장된다: C언의 경우 malloc(), calloc()등으로 할당받은 메모리가 저장된다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Q. 힙과 스택 세그먼트가 자라는 방향이 반대인 이유?&lt;/p&gt;

&lt;p&gt;A. 동일하면 충돌하니까. 따라서 리눅스는 스택 베이스를 메모리 끝에 위치시키고 힙 베이스는 낮은 주소에 위치시켜서 충돌할 일이 거의 없게 만들어 놨음.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Jun 2022 12:24:23 +0900</pubDate>
        <link>http://localhost:4000/blog/system-hacking-step2/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/system-hacking-step2/</guid>
      </item>
    

    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
        
          <item>
            <title>About</title>
            <description>&lt;p&gt;This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyllrb.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can find the source code for Minima at GitHub:
&lt;a href=&quot;https://github.com/jekyll&quot;&gt;jekyll&lt;/a&gt; /
&lt;a href=&quot;https://github.com/jekyll/minima&quot;&gt;minima&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can find the source code for Jekyll at GitHub:
&lt;a href=&quot;https://github.com/jekyll&quot;&gt;jekyll&lt;/a&gt; /
&lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;jekyll&lt;/a&gt;&lt;/p&gt;

</description>
            <link>http://localhost:4000/about/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title></title>
            <description>&lt;h3&gt;   &lt;/h3&gt;

&lt;div id=&quot;categories&quot;&gt;

  &lt;div class=&quot;category-box&quot;&gt;
    
    &lt;div id=&quot;#System Hacking Basic&quot;&gt;&lt;/div&gt;
    &lt;h4 class=&quot;category-head&quot;&gt;&lt;a href=&quot;/blog/categories/System Hacking Basic&quot;&gt;System Hacking Basic&lt;/a&gt;&lt;/h4&gt;
    &lt;a name=&quot;System Hacking Basic&quot;&gt;&lt;/a&gt;
     
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system-hacking-step3-2/&quot;&gt;System Hackig Step 3-2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system-hacking-step3-1/&quot;&gt;System Hackig Step 3-1&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system-hacking-step2-2/&quot;&gt;System Hackig Step 2-2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    
    &lt;article class=&quot;center&quot;&gt;
      &lt;h6&gt;&lt;a href=&quot;/blog/system-hacking-step2/&quot;&gt;System Hackig Step 2&lt;/a&gt;&lt;/h6&gt;
    &lt;/article&gt;


    

  &lt;/div&gt;

&lt;/div&gt;

</description>
            <link>http://localhost:4000/blog/categories/</link>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>Guides</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.guides %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/guides/</link>
          </item>
        
      
    
      
    
      
    
      
    
      
    
      
        
          <item>
            <title>Get Started</title>
            <description>## Getting Started - How to use “devlopr-jekyll” theme

## What&apos;s Jekyll ?

If you aren’t familiar with Jekyll yet, you should know that it is a static site generator. It will transform your plain text into static websites and blogs. No more databases, slow loading websites, risk of being hacked…just your content. And not only that, with Jekyll you get free hosting with GitHub Pages! If you are a beginner we recommend you start with [Jekyll’s Docs](https://jekyllrb.com/docs/installation/). Now, if you know how to use Jekyll, let’s move on to using this theme in Jekyll:

## Watch Tutorial

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cXBEfpn0qrg?rel=0&amp;amp;controls=0&amp;amp;showinfo=0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;


### Steps to create your blog using devlopr-jekyll and Host using Github Pages :

&gt;  **Step 1.**  Fork the repo - [click here](https://github.com/sujaykundu777/devlopr-jekyll/fork)

![Devlopr Jekyll Repo](/assets/img/posts/fork1.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 2.** Use **your-github-username.github.io** as the new repo  ( Replace your-github-username with yours). Remember if you use the name other than your-github-username.github.io , your blog will be built using gh-pages branch.

![Devlopr Jekyll Repo](/assets/img/posts/fork2.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork3.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 3.** Clone the new repo locally to make changes :

![Devlopr Jekyll Repo](/assets/img/posts/fork31.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork32.PNG){:class=&quot;img-fluid&quot;}

![Devlopr Jekyll Repo](/assets/img/posts/fork33.PNG){:class=&quot;img-fluid&quot;}

```bash
 $ git clone https://github.com/yourusername/yourusername.github.io
 $ cd yourusername.github.io
 $ code .
```

&gt; **Step 4.** Open the files using VSCode and edit _config.yml and edit with your details:

- _config.yml file - replace with your own details
- _posts - Add your blog posts here
- _includes - You can replace the contents of the files with your data. (contains widgets)
- _assets/img - Add all your images here

![Devlopr Jekyll Repo](/assets/img/posts/fork34.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 5** - Install the development requirements:

### Set up local development environment

1. [Git](https://git-scm.com/)
2. [Ruby](https://www.ruby-lang.org/) and [Bundler](https://bundler.io/)
3. [VSCode](https://code.visualstudio.com/download)

We need ruby and bundler to build our site locally. After installation check if its working:

For ruby :

```bash
$ ruby -v
ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux-gnu]
```
For bundler :

```bash
$ gem install bundler
$ bundler -v
Bundler version 2.2.29
```
Add jekyll :

```bash
$ bundle update
$ bundle add jekyll
```
 This command will add the Jekyll gem to our Gemfile and install it to the ./vendor/bundle/ folder.

You can check the jekyll version

```
$ bundle exec jekyll -v
jekyll 4.2.0
```

&gt; **Step 6.** Install the gem dependencies by running the following command

```bash
$ bundle update
$ bundle install
```

&gt; **Step 7.** Serve the site locally by running the following command below:

```bash
$ bundle exec jekyll serve --watch
```
or you can also serve using :

```bash
$ jekyll serve
```

Visit [http://localhost:4000](http://localhost:4000) for development server

![Devlopr Jekyll Repo](/assets/img/posts/fork41.PNG){:class=&quot;img-fluid&quot;}


### Adding Content

Start populating your blog by adding your .md files in _posts. devlopr-jekyll already has a few examples.

#### YAML Post Example:

```yml
---
layout: post
title: Sample Post
author: Sujay Kundu
date: &apos;2019-05-21 14:35:23 +0530&apos;
category:
        - jekyll
summary: This is the summary for the sample post
thumbnail: sample.png
---

Hi ! This is sample post.

```

#### YAML Page Example:

```yml
---
layout: page
title: Sample Page
permalink: /sample-page/
---

Hi ! This is sample page.
```

#### Editing stylesheet

You’ll only work with a single file to edit/add theme style: assets/css/main.scss.

### Deploy your Changes

Once happy with your blog changes. Push your changes to master branch.

&gt; **Step 8.** Push Your Local Changes

```bash
 $ git add .
 $ git commit -m &quot;my new blog using devlopr-jekyll&quot;
 $ git push origin master
```

Visit your Github Repo settings ! Enable master branch as Github Pages Branch :

![Devlopr Jekyll Repo](/assets/img/posts/fork6.PNG){:class=&quot;img-fluid&quot;}

&gt; **Step 9.** Deploy your Blog :

![Devlopr Jekyll Repo](/assets/img/posts/fork7.PNG){:class=&quot;img-fluid&quot;}

&gt; Congrats ! On your new shining Blog !

You can visit the blog using [http://your-github-username.github.io](http://your-github-username.github.io).

</description>
            <link>http://localhost:4000/get-started/</link>
          </item>
        
      
    
      
    
      
    
      
        
          <item>
            <title>Guides</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.sample_category %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/sample_category/</link>
          </item>
        
      
    
      
    
      
        
          <item>
            <title>Our Sponsors</title>
            <description>Thanks to all the amazing contributors and our Backers for the support.

- [Dirish Mohan](https://dirishmohan.com)</description>
            <link>http://localhost:4000/sponsors/</link>
          </item>
        
      
    
      
        
          <item>
            <title>Styleguide</title>
            <description>### devlopr - Styleguide

&lt;hr /&gt;

 &lt;img src=&quot;/assets/img/styleguide.png&quot; class=&quot;img-fluid&quot;&gt;

&lt;p&gt; Lets try the different text styles  &lt;b&gt; Bold &lt;/b&gt; , &lt;strong&gt; Strong &lt;/strong&gt;, &lt;em&gt; Emphasis &lt;/em&gt;, &lt;i&gt; Italic &lt;/i&gt; &lt;/p&gt;


&lt;p&gt; Now, lets try different heading styles : &lt;/p&gt;

&lt;h1&gt; Hello in h1 ! &lt;/h1&gt;
&lt;h2&gt; Hello in h2 ! &lt;/h2&gt;
&lt;h3&gt; Hello in h3 ! &lt;/h3&gt;
&lt;h4&gt; Hello in h4 ! &lt;/h4&gt;
&lt;h5&gt; Hello in h5 ! &lt;/h5&gt;
&lt;h6&gt; Hello in h6 ! &lt;/h6&gt;

&lt;hr /&gt;
&lt;p&gt; Unordered List &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; List Item 1 &lt;/li&gt;
&lt;li&gt; List Item 2 &lt;/li&gt;
&lt;li&gt; List Item 3 &lt;/li&gt;
&lt;li&gt; List Item 4 &lt;/li&gt;
&lt;li&gt; List Item 5 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; Ordered List &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; List Item 1 &lt;/li&gt;
&lt;li&gt; List Item 2 &lt;/li&gt;
&lt;li&gt; List Item 3 &lt;/li&gt;
&lt;li&gt; List Item 4 &lt;/li&gt;
&lt;li&gt; List Item 5 &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a Block Quote,  It can Expand Multiple Lines &lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;You can use the mark tag to &lt;mark&gt;highlight&lt;/mark&gt; text. &lt;/p&gt;

&lt;p&gt;&lt;del&gt; This line of text is meant to be deleted text &lt;/del&gt; &lt;/p&gt;

&lt;p&gt;&lt;u&gt;This line of text will render as underlined&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;This line of text is meant to be treated as fine print.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This line rendered as bold text.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This line rendered as italicized text.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;abbr title=&quot;attribute&quot;&gt;attr&lt;/abbr&gt;&lt;/p&gt;
&lt;p&gt;&lt;abbr title=&quot;HyperText Markup Language&quot; class=&quot;initialism&quot;&gt;HTML&lt;/abbr&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;responsive-table&quot;&gt;
&lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;col&quot;&gt;#&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
          &lt;th scope=&quot;col&quot;&gt;Heading&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;2&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;th scope=&quot;row&quot;&gt;3&lt;/th&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
          &lt;td&gt;Cell&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;/div&gt;

&lt;hr /&gt;

&lt;h3&gt; Instagram Embed &lt;/h3&gt;

&lt;blockquote class=&quot;instagram-media&quot; data-instgrm-captioned data-instgrm-permalink=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; data-instgrm-version=&quot;13&quot; style=&quot; background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px; max-width:540px; min-width:326px; padding:0; width:99.375%; width:-webkit-calc(100% - 2px); width:calc(100% - 2px);&quot;&gt;&lt;div style=&quot;padding:16px;&quot;&gt; &lt;a href=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; style=&quot; background:#FFFFFF; line-height:0; padding:0 0; text-align:center; text-decoration:none; width:100%;&quot; target=&quot;_blank&quot;&gt; &lt;div style=&quot; display: flex; flex-direction: row; align-items: center;&quot;&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 40px; margin-right: 14px; width: 40px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: column; flex-grow: 1; justify-content: center;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; margin-bottom: 6px; width: 100px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; width: 60px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;padding: 19% 0;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display:block; height:50px; margin:0 auto 12px; width:50px;&quot;&gt;&lt;svg width=&quot;50px&quot; height=&quot;50px&quot; viewBox=&quot;0 0 60 60&quot; version=&quot;1.1&quot; xmlns=&quot;https://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;https://www.w3.org/1999/xlink&quot;&gt;&lt;g stroke=&quot;none&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; fill-rule=&quot;evenodd&quot;&gt;&lt;g transform=&quot;translate(-511.000000, -20.000000)&quot; fill=&quot;#000000&quot;&gt;&lt;g&gt;&lt;path d=&quot;M556.869,30.41 C554.814,30.41 553.148,32.076 553.148,34.131 C553.148,36.186 554.814,37.852 556.869,37.852 C558.924,37.852 560.59,36.186 560.59,34.131 C560.59,32.076 558.924,30.41 556.869,30.41 M541,60.657 C535.114,60.657 530.342,55.887 530.342,50 C530.342,44.114 535.114,39.342 541,39.342 C546.887,39.342 551.658,44.114 551.658,50 C551.658,55.887 546.887,60.657 541,60.657 M541,33.886 C532.1,33.886 524.886,41.1 524.886,50 C524.886,58.899 532.1,66.113 541,66.113 C549.9,66.113 557.115,58.899 557.115,50 C557.115,41.1 549.9,33.886 541,33.886 M565.378,62.101 C565.244,65.022 564.756,66.606 564.346,67.663 C563.803,69.06 563.154,70.057 562.106,71.106 C561.058,72.155 560.06,72.803 558.662,73.347 C557.607,73.757 556.021,74.244 553.102,74.378 C549.944,74.521 548.997,74.552 541,74.552 C533.003,74.552 532.056,74.521 528.898,74.378 C525.979,74.244 524.393,73.757 523.338,73.347 C521.94,72.803 520.942,72.155 519.894,71.106 C518.846,70.057 518.197,69.06 517.654,67.663 C517.244,66.606 516.755,65.022 516.623,62.101 C516.479,58.943 516.448,57.996 516.448,50 C516.448,42.003 516.479,41.056 516.623,37.899 C516.755,34.978 517.244,33.391 517.654,32.338 C518.197,30.938 518.846,29.942 519.894,28.894 C520.942,27.846 521.94,27.196 523.338,26.654 C524.393,26.244 525.979,25.756 528.898,25.623 C532.057,25.479 533.004,25.448 541,25.448 C548.997,25.448 549.943,25.479 553.102,25.623 C556.021,25.756 557.607,26.244 558.662,26.654 C560.06,27.196 561.058,27.846 562.106,28.894 C563.154,29.942 563.803,30.938 564.346,32.338 C564.756,33.391 565.244,34.978 565.378,37.899 C565.522,41.056 565.552,42.003 565.552,50 C565.552,57.996 565.522,58.943 565.378,62.101 M570.82,37.631 C570.674,34.438 570.167,32.258 569.425,30.349 C568.659,28.377 567.633,26.702 565.965,25.035 C564.297,23.368 562.623,22.342 560.652,21.575 C558.743,20.834 556.562,20.326 553.369,20.18 C550.169,20.033 549.148,20 541,20 C532.853,20 531.831,20.033 528.631,20.18 C525.438,20.326 523.257,20.834 521.349,21.575 C519.376,22.342 517.703,23.368 516.035,25.035 C514.368,26.702 513.342,28.377 512.574,30.349 C511.834,32.258 511.326,34.438 511.181,37.631 C511.035,40.831 511,41.851 511,50 C511,58.147 511.035,59.17 511.181,62.369 C511.326,65.562 511.834,67.743 512.574,69.651 C513.342,71.625 514.368,73.296 516.035,74.965 C517.703,76.634 519.376,77.658 521.349,78.425 C523.257,79.167 525.438,79.673 528.631,79.82 C531.831,79.965 532.853,80.001 541,80.001 C549.148,80.001 550.169,79.965 553.369,79.82 C556.562,79.673 558.743,79.167 560.652,78.425 C562.623,77.658 564.297,76.634 565.965,74.965 C567.633,73.296 568.659,71.625 569.425,69.651 C570.167,67.743 570.674,65.562 570.82,62.369 C570.966,59.17 571,58.147 571,50 C571,41.851 570.966,40.831 570.82,37.631&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div style=&quot;padding-top: 8px;&quot;&gt; &lt;div style=&quot; color:#3897f0; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:550; line-height:18px;&quot;&gt; View this post on Instagram&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;padding: 12.5% 0;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: row; margin-bottom: 14px; align-items: center;&quot;&gt;&lt;div&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(0px) translateY(7px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color: #F4F4F4; height: 12.5px; transform: rotate(-45deg) translateX(3px) translateY(1px); width: 12.5px; flex-grow: 0; margin-right: 14px; margin-left: 2px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;background-color: #F4F4F4; border-radius: 50%; height: 12.5px; width: 12.5px; transform: translateX(9px) translateY(-18px);&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: 8px;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 50%; flex-grow: 0; height: 20px; width: 20px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; width: 0; height: 0; border-top: 2px solid transparent; border-left: 6px solid #f4f4f4; border-bottom: 2px solid transparent; transform: translateX(16px) translateY(-4px) rotate(30deg)&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;margin-left: auto;&quot;&gt; &lt;div style=&quot; width: 0px; border-top: 8px solid #F4F4F4; border-right: 8px solid transparent; transform: translateY(16px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; flex-grow: 0; height: 12px; width: 16px; transform: translateY(-4px);&quot;&gt;&lt;/div&gt; &lt;div style=&quot; width: 0; height: 0; border-top: 8px solid #F4F4F4; border-left: 8px solid transparent; transform: translateY(-4px) translateX(8px);&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;div style=&quot;display: flex; flex-direction: column; flex-grow: 1; justify-content: center; margin-bottom: 24px;&quot;&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; margin-bottom: 6px; width: 224px;&quot;&gt;&lt;/div&gt; &lt;div style=&quot; background-color: #F4F4F4; border-radius: 4px; flex-grow: 0; height: 14px; width: 144px;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/a&gt;&lt;p style=&quot; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;&quot;&gt;&lt;a href=&quot;https://www.instagram.com/p/CBXO7AypXkM/?utm_source=ig_embed&amp;amp;utm_campaign=loading&quot; style=&quot; color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;&quot; target=&quot;_blank&quot;&gt;A post shared by Sujay (@sujaykundu777)&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt; &lt;script async src=&quot;//www.instagram.com/embed.js&quot;&gt;&lt;/script&gt;

&lt;hr&gt;

&lt;h3&gt; Twitter Embed &lt;/h3&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;I just published “Deploying a blog using Jekyll and Github Pages with SSL certificate for Free” &lt;a href=&quot;https://t.co/B3T3IQVU93&quot;&gt;https://t.co/B3T3IQVU93&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sujay Kundu (@SujayKundu777) &lt;a href=&quot;https://twitter.com/SujayKundu777/status/1012601950469160962?ref_src=twsrc%5Etfw&quot;&gt;June 29, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&quot;https://platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;


&lt;h3&gt;YouTube Responsive Embed&lt;/h3&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/bBpKMH3nBzE?rel=0&amp;amp;controls=0&amp;amp;showinfo=0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3&gt;Vimeo Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://player.vimeo.com/video/212114694?title=0&amp;amp;byline=0&amp;amp;portrait=0&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ted-responsive-embed&quot;&gt;TED Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://embed.ted.com/talks/ted_halstead_a_climate_solution_where_all_sides_can_win&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;twitch-responsive-embed&quot;&gt;Twitch Responsive Embed&lt;/h3&gt;

&lt;iframe src=&quot;https://player.twitch.tv/?autoplay=false&amp;amp;video=v248755437&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot; scrolling=&quot;no&quot; height=&quot;378&quot; width=&quot;620&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;soundcloud-embed&quot;&gt;SoundCloud Embed&lt;/h3&gt;

&lt;iframe width=&quot;100%&quot; height=&quot;166&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/29738591&amp;amp;color=ff5500&amp;amp;auto_play=false&amp;amp;hide_related=false&amp;amp;show_comments=true&amp;amp;show_user=true&amp;amp;show_reposts=false&quot;&gt;&lt;/iframe&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;codepen-embed&quot;&gt;CodePen Embed&lt;/h3&gt;

&lt;p data-height=&quot;265&quot; data-theme-id=&quot;light&quot; data-slug-hash=&quot;YWvpRo&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;kharrop&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;Referral Form&quot; class=&quot;codepen&quot;&gt;&lt;/p&gt;
&lt;script async=&quot;&quot; src=&quot;https://production-assets.codepen.io/assets/embed/ei.js&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;syntax-highlighting&quot;&gt;Syntax Highlighting&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&apos;use strict&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;markdown&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Editor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;markdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toHTML&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;editor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can add inline code just like this, E.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;.code { color: #fff; }&lt;/code&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot; data-lang=&quot;css&quot;&gt;&lt;span class=&quot;nt&quot;&gt;pre&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f4f4f4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;github-gist-embed&quot;&gt;GitHub gist Embed&lt;/h3&gt;

&lt;script src=&quot;https://gist.github.com/ahmadajmi/dbb4f713317721668bcbc39420562afc.js&quot;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;input-style&quot;&gt;Input Style&lt;/h3&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; placeholder=&quot;I&apos;m an input field!&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;


</description>
            <link>http://localhost:4000/styleguide/</link>
          </item>
        
      
    
      
        
          <item>
            <title>System Hacking Basic</title>
            <description>&lt;h5&gt; Posts by Category : {{ page.title }} &lt;/h5&gt;

&lt;div class=&quot;card&quot;&gt;
{% for post in site.categories.jekyll %}
 &lt;li class=&quot;category-posts&quot;&gt;&lt;span&gt;{{ post.date | date_to_string }}&lt;/span&gt; &amp;nbsp; &lt;a href=&quot;{{ post.url }}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/div&gt;</description>
            <link>http://localhost:4000/blog/categories/system-hacking-basic/</link>
          </item>
        
      
    
      
    
      
    

  </channel>
</rss>